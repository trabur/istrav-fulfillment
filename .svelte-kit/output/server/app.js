import {respond} from "@sveltejs/kit/ssr";
import {create_ssr_component, validate_component, missing_component, escape, null_to_empty, add_attribute, each} from "svelte/internal";
import {setContext, afterUpdate, onMount} from "svelte";
import {writable} from "svelte/store";
import axios from "axios";
var root_svelte_svelte_type_style_lang = "";
const css$5 = {
  code: "#svelte-announcer.svelte-1j55zn5{position:absolute;left:0;top:0;clip:rect(0 0 0 0);clip-path:inset(50%);overflow:hidden;white-space:nowrap;width:1px;height:1px}",
  map: `{"version":3,"file":"root.svelte","sources":["root.svelte"],"sourcesContent":["<!-- This file is generated by @sveltejs/kit \u2014 do not edit it! -->\\n<script>\\n\\timport { setContext, afterUpdate, onMount } from 'svelte';\\n\\n\\t// stores\\n\\texport let stores;\\n\\texport let page;\\n\\n\\texport let components;\\n\\texport let props_0 = null;\\n\\texport let props_1 = null;\\n\\texport let props_2 = null;\\n\\n\\tsetContext('__svelte__', stores);\\n\\n\\t$: stores.page.set(page);\\n\\tafterUpdate(stores.page.notify);\\n\\n\\tlet mounted = false;\\n\\tlet navigated = false;\\n\\tlet title = null;\\n\\n\\tonMount(() => {\\n\\t\\tconst unsubscribe = stores.page.subscribe(() => {\\n\\t\\t\\tif (mounted) {\\n\\t\\t\\t\\tnavigated = true;\\n\\t\\t\\t\\ttitle = document.title || 'untitled page';\\n\\t\\t\\t}\\n\\t\\t});\\n\\n\\t\\tmounted = true;\\n\\t\\treturn unsubscribe;\\n\\t});\\n</script>\\n\\n<svelte:component this={components[0]} {...(props_0 || {})}>\\n\\t{#if components[1]}\\n\\t\\t<svelte:component this={components[1]} {...(props_1 || {})}>\\n\\t\\t\\t{#if components[2]}\\n\\t\\t\\t\\t<svelte:component this={components[2]} {...(props_2 || {})}/>\\n\\t\\t\\t{/if}\\n\\t\\t</svelte:component>\\n\\t{/if}\\n</svelte:component>\\n\\n{#if mounted}\\n\\t<div id=\\"svelte-announcer\\" aria-live=\\"assertive\\" aria-atomic=\\"true\\">\\n\\t\\t{#if navigated}\\n\\t\\t\\t{title}\\n\\t\\t{/if}\\n\\t</div>\\n{/if}\\n\\n<style>\\n\\t#svelte-announcer {\\n\\t\\tposition: absolute;\\n\\t\\tleft: 0;\\n\\t\\ttop: 0;\\n\\t\\tclip: rect(0 0 0 0);\\n\\t\\tclip-path: inset(50%);\\n\\t\\toverflow: hidden;\\n\\t\\twhite-space: nowrap;\\n\\t\\twidth: 1px;\\n\\t\\theight: 1px;\\n\\t}\\n</style>"],"names":[],"mappings":"AAsDC,iBAAiB,eAAC,CAAC,AAClB,QAAQ,CAAE,QAAQ,CAClB,IAAI,CAAE,CAAC,CACP,GAAG,CAAE,CAAC,CACN,IAAI,CAAE,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CACnB,SAAS,CAAE,MAAM,GAAG,CAAC,CACrB,QAAQ,CAAE,MAAM,CAChB,WAAW,CAAE,MAAM,CACnB,KAAK,CAAE,GAAG,CACV,MAAM,CAAE,GAAG,AACZ,CAAC"}`
};
const Root = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let {stores} = $$props;
  let {page} = $$props;
  let {components} = $$props;
  let {props_0 = null} = $$props;
  let {props_1 = null} = $$props;
  let {props_2 = null} = $$props;
  setContext("__svelte__", stores);
  afterUpdate(stores.page.notify);
  let mounted = false;
  let navigated = false;
  let title = null;
  onMount(() => {
    const unsubscribe = stores.page.subscribe(() => {
      if (mounted) {
        navigated = true;
        title = document.title || "untitled page";
      }
    });
    mounted = true;
    return unsubscribe;
  });
  if ($$props.stores === void 0 && $$bindings.stores && stores !== void 0)
    $$bindings.stores(stores);
  if ($$props.page === void 0 && $$bindings.page && page !== void 0)
    $$bindings.page(page);
  if ($$props.components === void 0 && $$bindings.components && components !== void 0)
    $$bindings.components(components);
  if ($$props.props_0 === void 0 && $$bindings.props_0 && props_0 !== void 0)
    $$bindings.props_0(props_0);
  if ($$props.props_1 === void 0 && $$bindings.props_1 && props_1 !== void 0)
    $$bindings.props_1(props_1);
  if ($$props.props_2 === void 0 && $$bindings.props_2 && props_2 !== void 0)
    $$bindings.props_2(props_2);
  $$result.css.add(css$5);
  {
    stores.page.set(page);
  }
  return `


${validate_component(components[0] || missing_component, "svelte:component").$$render($$result, Object.assign(props_0 || {}), {}, {
    default: () => `${components[1] ? `${validate_component(components[1] || missing_component, "svelte:component").$$render($$result, Object.assign(props_1 || {}), {}, {
      default: () => `${components[2] ? `${validate_component(components[2] || missing_component, "svelte:component").$$render($$result, Object.assign(props_2 || {}), {}, {})}` : ``}`
    })}` : ``}`
  })}

${mounted ? `<div id="${"svelte-announcer"}" aria-live="${"assertive"}" aria-atomic="${"true"}" class="${"svelte-1j55zn5"}">${navigated ? `${escape(title)}` : ``}</div>` : ``}`;
});
function set_paths(paths) {
}
function set_prerendering(value) {
}
var user_hooks = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module"
});
const template = ({head, body}) => '<!doctype html>\n<html lang="en">\n<head>\n	<meta charset="utf-8">\n	<meta name="viewport" content="width=device-width,initial-scale=1.0">\n	<meta name="theme-color" content="#333333">\n\n	<!-- Import Google Icon Font -->\n	<link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">\n	<!-- Import materialize.css -->\n	<link type="text/css" rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/css/materialize.min.css"  media="screen,projection"/>\n	\n	<link rel="stylesheet" href="/global.css">\n	<link rel="manifest" href="manifest.json" crossorigin="use-credentials">\n	<link rel="icon" type="image/png" href="favicon.png">\n\n	' + head + '\n</head>\n<body>\n	<div id="svelte">' + body + '</div>\n\n	<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/js/materialize.min.js"></script>	\n</body>\n</html>\n';
let options = null;
function init$j(settings) {
  set_paths(settings.paths);
  set_prerendering(settings.prerendering || false);
  options = {
    amp: false,
    dev: false,
    entry: {
      file: "/./_app/start-4c6dbd91.js",
      css: ["/./_app/assets/start-a8cd1609.css"],
      js: ["/./_app/start-4c6dbd91.js", "/./_app/chunks/vendor-105b73e2.js", "/./_app/chunks/preload-helper-9f12a5fd.js"]
    },
    fetched: void 0,
    floc: false,
    get_component_path: (id) => "/./_app/" + entry_lookup[id],
    get_stack: (error2) => String(error2),
    handle_error: (error2) => {
      console.error(error2.stack);
      error2.stack = options.get_stack(error2);
    },
    hooks: get_hooks(user_hooks),
    hydrate: true,
    initiator: void 0,
    load_component,
    manifest,
    paths: settings.paths,
    read: settings.read,
    root: Root,
    router: true,
    ssr: true,
    target: "#svelte",
    template,
    trailing_slash: "never"
  };
}
const empty = () => ({});
const manifest = {
  assets: [{"file": "favicon.png", "size": 3127, "type": "image/png"}, {"file": "global.css", "size": 710, "type": "text/css"}, {"file": "logo-192.png", "size": 4760, "type": "image/png"}, {"file": "logo-512.png", "size": 13928, "type": "image/png"}, {"file": "manifest.json", "size": 324, "type": "application/json"}, {"file": "particles.js", "size": 43009, "type": "application/javascript"}, {"file": "particles.json", "size": 1970, "type": "application/json"}, {"file": "poweredByISTRAV.png", "size": 95, "type": "image/png"}],
  layout: "src/routes/__layout.svelte",
  error: ".svelte-kit/build/components/error.svelte",
  routes: [
    {
      type: "page",
      pattern: /^\/$/,
      params: empty,
      a: ["src/routes/__layout.svelte", "src/routes/index.svelte"],
      b: [".svelte-kit/build/components/error.svelte"]
    }
  ]
};
const get_hooks = (hooks) => ({
  getSession: hooks.getSession || (() => ({})),
  handle: hooks.handle || (({request, render: render2}) => render2(request))
});
const module_lookup = {
  "src/routes/__layout.svelte": () => Promise.resolve().then(function() {
    return __layout;
  }),
  ".svelte-kit/build/components/error.svelte": () => Promise.resolve().then(function() {
    return error;
  }),
  "src/routes/index.svelte": () => Promise.resolve().then(function() {
    return index;
  })
};
const metadata_lookup = {"src/routes/__layout.svelte": {"entry": "/./_app/pages/__layout.svelte-d7cf9447.js", "css": [], "js": ["/./_app/pages/__layout.svelte-d7cf9447.js", "/./_app/chunks/vendor-105b73e2.js", "/./_app/chunks/api-5fa53d0a.js"], "styles": null}, ".svelte-kit/build/components/error.svelte": {"entry": "/./_app/error.svelte-08da241b.js", "css": [], "js": ["/./_app/error.svelte-08da241b.js", "/./_app/chunks/vendor-105b73e2.js"], "styles": null}, "src/routes/index.svelte": {"entry": "/./_app/pages/index.svelte-5d5c0c5a.js", "css": ["/./_app/assets/pages/index.svelte-8536c73b.css"], "js": ["/./_app/pages/index.svelte-5d5c0c5a.js", "/./_app/chunks/vendor-105b73e2.js", "/./_app/chunks/api-5fa53d0a.js", "/./_app/chunks/preload-helper-9f12a5fd.js"], "styles": null}};
async function load_component(file) {
  return {
    module: await module_lookup[file](),
    ...metadata_lookup[file]
  };
}
init$j({paths: {"base": "", "assets": "/."}});
function render(request, {
  prerender
} = {}) {
  const host2 = request.headers["host"];
  return respond({...request, host: host2}, options, {prerender});
}
let appData = writable({});
let domainId = writable("");
let backendId = writable("");
let headlessId = writable("");
let ioId = writable("");
let version = "v1";
let host$i = "http://localhost:1337";
let endpoint$i = "sources";
function init$i(config) {
  if (config.host) {
    host$i = config.host;
  }
  if (config.token) {
    config.token;
  }
}
function publish(eventSource) {
  let url = `${host$i}/${version}/${endpoint$i}/publish/${eventSource.arguements.id}`;
  eventSource.url = url;
  return axios.post(url, {
    params: eventSource
  }).then(function(response) {
    response.data.clientAt = Date.now();
    return response.data;
  }).catch(function(error2) {
    return error2;
  });
}
function consume(eventSource) {
  let url = `${host$i}/${version}/${endpoint$i}/consume/${eventSource.arguements.id}`;
  eventSource.url = url;
  return axios.post(url, {
    params: eventSource
  }).then(function(response) {
    response.data.clientAt = Date.now();
    return response.data;
  }).catch(function(error2) {
    return error2;
  });
}
function check(eventSource) {
  let url = `${host$i}/${version}/${endpoint$i}/check/${eventSource.arguements.id}`;
  eventSource.url = url;
  return axios.post(url, {
    params: eventSource
  }).then(function(response) {
    response.data.clientAt = Date.now();
    return response.data;
  }).catch(function(error2) {
    return error2;
  });
}
var sources = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  init: init$i,
  publish,
  consume,
  check
});
let host$h = "http://localhost:1337";
let endpoint$h = "users";
function init$h(config) {
  if (config.host) {
    host$h = config.host;
  }
  if (config.token) {
    config.token;
  }
}
function register$1(eventSource) {
  let url = `${host$h}/${version}/${endpoint$h}/register`;
  eventSource.url = url;
  return axios.post(url, {
    params: eventSource
  }).then(function(response) {
    response.data.clientAt = Date.now();
    return response.data;
  }).catch(function(error2) {
    return error2;
  });
}
function login$1(eventSource) {
  let url = `${host$h}/${version}/${endpoint$h}/login`;
  eventSource.url = url;
  return axios.post(url, {
    params: eventSource
  }).then(function(response) {
    response.data.clientAt = Date.now();
    return response.data;
  }).catch(function(error2) {
    return error2;
  });
}
function all$h(eventSource) {
  let url = `${host$h}/${version}/${endpoint$h}/all`;
  eventSource.url = url;
  return axios.post(url, {
    params: eventSource
  }).then(function(response) {
    response.data.clientAt = Date.now();
    return response.data;
  }).catch(function(error2) {
    return error2;
  });
}
function get$h(eventSource) {
  let url = `${host$h}/${version}/${endpoint$h}/get`;
  eventSource.url = url;
  return axios.post(url, {
    params: eventSource
  }).then(function(response) {
    response.data.clientAt = Date.now();
    return response.data;
  }).catch(function(error2) {
    return error2;
  });
}
function update$h(eventSource) {
  let url = `${host$h}/${version}/${endpoint$h}/update`;
  eventSource.url = url;
  return axios.post(url, {
    params: eventSource
  }).then(function(response) {
    response.data.clientAt = Date.now();
    return response.data;
  }).catch(function(error2) {
    return error2;
  });
}
function remove$h(eventSource) {
  let url = `${host$h}/${version}/${endpoint$h}/remove`;
  eventSource.url = url;
  return axios.post(url, {
    params: eventSource
  }).then(function(response) {
    response.data.clientAt = Date.now();
    return response.data;
  }).catch(function(error2) {
    return error2;
  });
}
var users = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  init: init$h,
  register: register$1,
  login: login$1,
  all: all$h,
  get: get$h,
  update: update$h,
  remove: remove$h
});
let host$g = "http://localhost:1337";
let endpoint$g = "carts";
let token$f = "";
function init$g(config) {
  if (config.host) {
    host$g = config.host;
  }
  if (config.token) {
    host$g = config.token;
  }
}
function save$f(eventSource) {
  let url = `${host$g}/${version}/${endpoint$g}/save`;
  eventSource.url = url;
  return axios.post(url, {
    params: eventSource
  }).then(function(response) {
    response.data.clientAt = Date.now();
    return response.data;
  }).catch(function(error2) {
    return error2;
  });
}
function all$g(eventSource) {
  let url = `${host$g}/${version}/${endpoint$g}/all`;
  eventSource.url = url;
  return axios.post(url, {
    headers: {"authorization": `Bearer ${token$f}`},
    params: eventSource
  }).then(function(response) {
    response.data.clientAt = Date.now();
    return response.data;
  }).catch(function(error2) {
    return error2;
  });
}
function get$g(eventSource) {
  let url = `${host$g}/${version}/${endpoint$g}/get`;
  eventSource.url = url;
  return axios.post(url, {
    params: eventSource
  }).then(function(response) {
    response.data.clientAt = Date.now();
    return response.data;
  }).catch(function(error2) {
    return error2;
  });
}
function update$g(eventSource) {
  let url = `${host$g}/${version}/${endpoint$g}/update`;
  eventSource.url = url;
  return axios.post(url, {
    params: eventSource
  }).then(function(response) {
    response.data.clientAt = Date.now();
    return response.data;
  }).catch(function(error2) {
    return error2;
  });
}
function remove$g(eventSource) {
  let url = `${host$g}/${version}/${endpoint$g}/remove`;
  eventSource.url = url;
  return axios.post(url, {
    params: eventSource
  }).then(function(response) {
    response.data.clientAt = Date.now();
    return response.data;
  }).catch(function(error2) {
    return error2;
  });
}
function stripeCheckoutSession(eventSource) {
  let url = `${host$g}/${version}/${endpoint$g}/stripeCheckoutSession`;
  eventSource.url = url;
  return axios.post(url, {
    params: eventSource
  }).then(function(response) {
    response.data.clientAt = Date.now();
    return response.data;
  }).catch(function(error2) {
    return error2;
  });
}
var carts = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  init: init$g,
  save: save$f,
  all: all$g,
  get: get$g,
  update: update$g,
  remove: remove$g,
  stripeCheckoutSession
});
let host$f = "http://localhost:1337";
let endpoint$f = "orders";
let token$e = "";
function init$f(config) {
  if (config.host) {
    host$f = config.host;
  }
  if (config.token) {
    host$f = config.token;
  }
}
function save$e(eventSource) {
  let url = `${host$f}/${version}/${endpoint$f}/save`;
  eventSource.url = url;
  return axios.post(url, {
    params: eventSource
  }).then(function(response) {
    response.data.clientAt = Date.now();
    return response.data;
  }).catch(function(error2) {
    return error2;
  });
}
function all$f(eventSource) {
  let url = `${host$f}/${version}/${endpoint$f}/all`;
  eventSource.url = url;
  return axios.post(url, {
    headers: {"authorization": `Bearer ${token$e}`},
    params: eventSource
  }).then(function(response) {
    response.data.clientAt = Date.now();
    return response.data;
  }).catch(function(error2) {
    return error2;
  });
}
function get$f(eventSource) {
  let url = `${host$f}/${version}/${endpoint$f}/get`;
  eventSource.url = url;
  return axios.post(url, {
    params: eventSource
  }).then(function(response) {
    response.data.clientAt = Date.now();
    return response.data;
  }).catch(function(error2) {
    return error2;
  });
}
function update$f(eventSource) {
  let url = `${host$f}/${version}/${endpoint$f}/update`;
  eventSource.url = url;
  return axios.post(url, {
    params: eventSource
  }).then(function(response) {
    response.data.clientAt = Date.now();
    return response.data;
  }).catch(function(error2) {
    return error2;
  });
}
function remove$f(eventSource) {
  let url = `${host$f}/${version}/${endpoint$f}/remove`;
  eventSource.url = url;
  return axios.post(url, {
    params: eventSource
  }).then(function(response) {
    response.data.clientAt = Date.now();
    return response.data;
  }).catch(function(error2) {
    return error2;
  });
}
var orders = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  init: init$f,
  save: save$e,
  all: all$f,
  get: get$f,
  update: update$f,
  remove: remove$f
});
let host$e = "http://localhost:1337";
let endpoint$e = "members";
function init$e(config) {
  if (config.host) {
    host$e = config.host;
  }
  if (config.token) {
    config.token;
  }
}
function register(eventSource) {
  let url = `${host$e}/${version}/${endpoint$e}/register`;
  eventSource.url = url;
  return axios.post(url, {
    params: eventSource
  }).then(function(response) {
    response.data.clientAt = Date.now();
    return response.data;
  }).catch(function(error2) {
    return error2;
  });
}
function login(eventSource) {
  let url = `${host$e}/${version}/${endpoint$e}/login`;
  eventSource.url = url;
  return axios.post(url, {
    params: eventSource
  }).then(function(response) {
    response.data.clientAt = Date.now();
    return response.data;
  }).catch(function(error2) {
    return error2;
  });
}
function all$e(eventSource) {
  let url = `${host$e}/${version}/${endpoint$e}/all`;
  eventSource.url = url;
  return axios.post(url, {
    params: eventSource
  }).then(function(response) {
    response.data.clientAt = Date.now();
    return response.data;
  }).catch(function(error2) {
    return error2;
  });
}
function get$e(eventSource) {
  let url = `${host$e}/${version}/${endpoint$e}/get`;
  eventSource.url = url;
  return axios.post(url, {
    params: eventSource
  }).then(function(response) {
    response.data.clientAt = Date.now();
    return response.data;
  }).catch(function(error2) {
    return error2;
  });
}
function update$e(eventSource) {
  let url = `${host$e}/${version}/${endpoint$e}/update`;
  eventSource.url = url;
  return axios.post(url, {
    params: eventSource
  }).then(function(response) {
    response.data.clientAt = Date.now();
    return response.data;
  }).catch(function(error2) {
    return error2;
  });
}
function remove$e(eventSource) {
  let url = `${host$e}/${version}/${endpoint$e}/remove`;
  eventSource.url = url;
  return axios.post(url, {
    params: eventSource
  }).then(function(response) {
    response.data.clientAt = Date.now();
    return response.data;
  }).catch(function(error2) {
    return error2;
  });
}
var members = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  init: init$e,
  register,
  login,
  all: all$e,
  get: get$e,
  update: update$e,
  remove: remove$e
});
let host$d = "http://localhost:1337";
let component = "apps";
let token$d = "";
function init$d(config) {
  if (config.host) {
    host$d = config.host;
  }
  if (config.token) {
    host$d = config.token;
  }
}
function save$d(eventSource) {
  let url = `${host$d}/${version}/${component}/save`;
  eventSource.url = url;
  return axios.post(url, {
    params: eventSource
  }).then(function(response) {
    response.data.clientAt = Date.now();
    return response.data;
  }).catch(function(error2) {
    return error2;
  });
}
function all$d(eventSource) {
  let url = `${host$d}/${version}/${component}/all`;
  eventSource.url = url;
  return axios.post(url, {
    headers: {"authorization": `Bearer ${token$d}`},
    params: eventSource
  }).then(function(response) {
    response.data.clientAt = Date.now();
    return response.data;
  }).catch(function(error2) {
    return error2;
  });
}
function get$d(eventSource) {
  let url = `${host$d}/${version}/${component}/get`;
  eventSource.url = url;
  return axios.post(url, {
    params: eventSource
  }).then(function(response) {
    response.data.clientAt = Date.now();
    return response.data;
  }).catch(function(error2) {
    return error2;
  });
}
function update$d(eventSource) {
  let url = `${host$d}/${version}/${component}/update`;
  eventSource.url = url;
  return axios.post(url, {
    params: eventSource
  }).then(function(response) {
    response.data.clientAt = Date.now();
    return response.data;
  }).catch(function(error2) {
    return error2;
  });
}
function remove$d(eventSource) {
  let url = `${host$d}/${version}/${component}/remove`;
  eventSource.url = url;
  return axios.post(url, {
    params: eventSource
  }).then(function(response) {
    response.data.clientAt = Date.now();
    return response.data;
  }).catch(function(error2) {
    return error2;
  });
}
function endpoint$d(eventSource) {
  let url = `${host$d}/${version}/${component}/endpoint`;
  eventSource.url = url;
  return axios.post(url, {
    params: eventSource
  }).then(function(response) {
    response.data.clientAt = Date.now();
    return response.data;
  }).catch(function(error2) {
    return error2;
  });
}
function totals(eventSource) {
  let url = `${host$d}/${version}/${component}/totals`;
  eventSource.url = url;
  return axios.post(url, {
    params: eventSource
  }).then(function(response) {
    response.data.clientAt = Date.now();
    return response.data;
  }).catch(function(error2) {
    return error2;
  });
}
var apps = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  init: init$d,
  save: save$d,
  all: all$d,
  get: get$d,
  update: update$d,
  remove: remove$d,
  endpoint: endpoint$d,
  totals
});
let host$c = "http://localhost:1337";
let endpoint$c = "vehicles";
let token$c = "";
function init$c(config) {
  if (config.host) {
    host$c = config.host;
  }
  if (config.token) {
    host$c = config.token;
  }
}
function save$c(eventSource) {
  let url = `${host$c}/${version}/${endpoint$c}/save`;
  eventSource.url = url;
  return axios.post(url, {
    params: eventSource
  }).then(function(response) {
    response.data.clientAt = Date.now();
    return response.data;
  }).catch(function(error2) {
    return error2;
  });
}
function all$c(eventSource) {
  let url = `${host$c}/${version}/${endpoint$c}/all`;
  eventSource.url = url;
  return axios.post(url, {
    headers: {"authorization": `Bearer ${token$c}`},
    params: eventSource
  }).then(function(response) {
    response.data.clientAt = Date.now();
    return response.data;
  }).catch(function(error2) {
    return error2;
  });
}
function get$c(eventSource) {
  let url = `${host$c}/${version}/${endpoint$c}/get/${eventSource.arguements.id}`;
  eventSource.url = url;
  return axios.post(url, {
    params: eventSource
  }).then(function(response) {
    response.data.clientAt = Date.now();
    return response.data;
  }).catch(function(error2) {
    return error2;
  });
}
function update$c(eventSource) {
  let url = `${host$c}/${version}/${endpoint$c}/update/${eventSource.arguements.id}`;
  eventSource.url = url;
  return axios.post(url, {
    params: eventSource
  }).then(function(response) {
    response.data.clientAt = Date.now();
    return response.data;
  }).catch(function(error2) {
    return error2;
  });
}
function remove$c(eventSource) {
  let url = `${host$c}/${version}/${endpoint$c}/remove/${eventSource.arguements.id}`;
  eventSource.url = url;
  return axios.post(url, {
    params: eventSource
  }).then(function(response) {
    response.data.clientAt = Date.now();
    return response.data;
  }).catch(function(error2) {
    return error2;
  });
}
var vehicles = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  init: init$c,
  save: save$c,
  all: all$c,
  get: get$c,
  update: update$c,
  remove: remove$c
});
let host$b = "http://localhost:1337";
let endpoint$b = "collections";
let token$b = "";
function init$b(config) {
  if (config.host) {
    host$b = config.host;
  }
  if (config.token) {
    host$b = config.token;
  }
}
function save$b(eventSource) {
  let url = `${host$b}/${version}/${endpoint$b}/save`;
  eventSource.url = url;
  return axios.post(url, {
    params: eventSource
  }).then(function(response) {
    response.data.clientAt = Date.now();
    return response.data;
  }).catch(function(error2) {
    return error2;
  });
}
function all$b(eventSource) {
  let url = `${host$b}/${version}/${endpoint$b}/all`;
  eventSource.url = url;
  return axios.post(url, {
    headers: {"authorization": `Bearer ${token$b}`},
    params: eventSource
  }).then(function(response) {
    response.data.clientAt = Date.now();
    return response.data;
  }).catch(function(error2) {
    return error2;
  });
}
function get$b(eventSource) {
  let url = `${host$b}/${version}/${endpoint$b}/get`;
  eventSource.url = url;
  return axios.post(url, {
    params: eventSource
  }).then(function(response) {
    response.data.clientAt = Date.now();
    return response.data;
  }).catch(function(error2) {
    return error2;
  });
}
function update$b(eventSource) {
  let url = `${host$b}/${version}/${endpoint$b}/update`;
  eventSource.url = url;
  return axios.post(url, {
    params: eventSource
  }).then(function(response) {
    response.data.clientAt = Date.now();
    return response.data;
  }).catch(function(error2) {
    return error2;
  });
}
function remove$b(eventSource) {
  let url = `${host$b}/${version}/${endpoint$b}/remove`;
  eventSource.url = url;
  return axios.post(url, {
    params: eventSource
  }).then(function(response) {
    response.data.clientAt = Date.now();
    return response.data;
  }).catch(function(error2) {
    return error2;
  });
}
function products$2(eventSource) {
  let url = `${host$b}/${version}/${endpoint$b}/products`;
  eventSource.url = url;
  return axios.post(url, {
    params: eventSource
  }).then(function(response) {
    response.data.clientAt = Date.now();
    return response.data;
  }).catch(function(error2) {
    return error2;
  });
}
var collections = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  init: init$b,
  save: save$b,
  all: all$b,
  get: get$b,
  update: update$b,
  remove: remove$b,
  products: products$2
});
let host$a = "http://localhost:1337";
let endpoint$a = "categories";
let token$a = "";
function init$a(config) {
  if (config.host) {
    host$a = config.host;
  }
  if (config.token) {
    host$a = config.token;
  }
}
function save$a(eventSource) {
  let url = `${host$a}/${version}/${endpoint$a}/save`;
  eventSource.url = url;
  return axios.post(url, {
    params: eventSource
  }).then(function(response) {
    response.data.clientAt = Date.now();
    return response.data;
  }).catch(function(error2) {
    return error2;
  });
}
function all$a(eventSource) {
  let url = `${host$a}/${version}/${endpoint$a}/all`;
  eventSource.url = url;
  return axios.post(url, {
    headers: {"authorization": `Bearer ${token$a}`},
    params: eventSource
  }).then(function(response) {
    response.data.clientAt = Date.now();
    return response.data;
  }).catch(function(error2) {
    return error2;
  });
}
function get$a(eventSource) {
  let url = `${host$a}/${version}/${endpoint$a}/get`;
  eventSource.url = url;
  return axios.post(url, {
    params: eventSource
  }).then(function(response) {
    response.data.clientAt = Date.now();
    return response.data;
  }).catch(function(error2) {
    return error2;
  });
}
function update$a(eventSource) {
  let url = `${host$a}/${version}/${endpoint$a}/update`;
  eventSource.url = url;
  return axios.post(url, {
    params: eventSource
  }).then(function(response) {
    response.data.clientAt = Date.now();
    return response.data;
  }).catch(function(error2) {
    return error2;
  });
}
function remove$a(eventSource) {
  let url = `${host$a}/${version}/${endpoint$a}/remove`;
  eventSource.url = url;
  return axios.post(url, {
    params: eventSource
  }).then(function(response) {
    response.data.clientAt = Date.now();
    return response.data;
  }).catch(function(error2) {
    return error2;
  });
}
function products$1(eventSource) {
  let url = `${host$a}/${version}/${endpoint$a}/products`;
  eventSource.url = url;
  return axios.post(url, {
    params: eventSource
  }).then(function(response) {
    response.data.clientAt = Date.now();
    return response.data;
  }).catch(function(error2) {
    return error2;
  });
}
var categories = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  init: init$a,
  save: save$a,
  all: all$a,
  get: get$a,
  update: update$a,
  remove: remove$a,
  products: products$1
});
let host$9 = "http://localhost:1337";
let endpoint$9 = "products";
let token$9 = "";
function init$9(config) {
  if (config.host) {
    host$9 = config.host;
  }
  if (config.token) {
    host$9 = config.token;
  }
}
function save$9(eventSource) {
  let url = `${host$9}/${version}/${endpoint$9}/save`;
  eventSource.url = url;
  return axios.post(url, {
    params: eventSource
  }).then(function(response) {
    response.data.clientAt = Date.now();
    return response.data;
  }).catch(function(error2) {
    return error2;
  });
}
function all$9(eventSource) {
  let url = `${host$9}/${version}/${endpoint$9}/all`;
  eventSource.url = url;
  return axios.post(url, {
    headers: {"authorization": `Bearer ${token$9}`},
    params: eventSource
  }).then(function(response) {
    response.data.clientAt = Date.now();
    return response.data;
  }).catch(function(error2) {
    return error2;
  });
}
function get$9(eventSource) {
  let url = `${host$9}/${version}/${endpoint$9}/get`;
  eventSource.url = url;
  return axios.post(url, {
    params: eventSource
  }).then(function(response) {
    response.data.clientAt = Date.now();
    return response.data;
  }).catch(function(error2) {
    return error2;
  });
}
function update$9(eventSource) {
  let url = `${host$9}/${version}/${endpoint$9}/update`;
  eventSource.url = url;
  return axios.post(url, {
    params: eventSource
  }).then(function(response) {
    response.data.clientAt = Date.now();
    return response.data;
  }).catch(function(error2) {
    return error2;
  });
}
function remove$9(eventSource) {
  let url = `${host$9}/${version}/${endpoint$9}/remove`;
  eventSource.url = url;
  return axios.post(url, {
    params: eventSource
  }).then(function(response) {
    response.data.clientAt = Date.now();
    return response.data;
  }).catch(function(error2) {
    return error2;
  });
}
var products = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  init: init$9,
  save: save$9,
  all: all$9,
  get: get$9,
  update: update$9,
  remove: remove$9
});
let host$8 = "http://localhost:1337";
let endpoint$8 = "menus";
let token$8 = "";
function init$8(config) {
  if (config.host) {
    host$8 = config.host;
  }
  if (config.token) {
    host$8 = config.token;
  }
}
function save$8(eventSource) {
  let url = `${host$8}/${version}/${endpoint$8}/save`;
  eventSource.url = url;
  return axios.post(url, {
    params: eventSource
  }).then(function(response) {
    response.data.clientAt = Date.now();
    return response.data;
  }).catch(function(error2) {
    return error2;
  });
}
function all$8(eventSource) {
  let url = `${host$8}/${version}/${endpoint$8}/all`;
  eventSource.url = url;
  return axios.post(url, {
    headers: {"authorization": `Bearer ${token$8}`},
    params: eventSource
  }).then(function(response) {
    response.data.clientAt = Date.now();
    return response.data;
  }).catch(function(error2) {
    return error2;
  });
}
function get$8(eventSource) {
  let url = `${host$8}/${version}/${endpoint$8}/get`;
  eventSource.url = url;
  return axios.post(url, {
    params: eventSource
  }).then(function(response) {
    response.data.clientAt = Date.now();
    return response.data;
  }).catch(function(error2) {
    return error2;
  });
}
function update$8(eventSource) {
  let url = `${host$8}/${version}/${endpoint$8}/update`;
  eventSource.url = url;
  return axios.post(url, {
    params: eventSource
  }).then(function(response) {
    response.data.clientAt = Date.now();
    return response.data;
  }).catch(function(error2) {
    return error2;
  });
}
function remove$8(eventSource) {
  let url = `${host$8}/${version}/${endpoint$8}/remove`;
  eventSource.url = url;
  return axios.post(url, {
    params: eventSource
  }).then(function(response) {
    response.data.clientAt = Date.now();
    return response.data;
  }).catch(function(error2) {
    return error2;
  });
}
var menus = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  init: init$8,
  save: save$8,
  all: all$8,
  get: get$8,
  update: update$8,
  remove: remove$8
});
let host$7 = "http://localhost:1337";
let endpoint$7 = "blocks";
let token$7 = "";
function init$7(config) {
  if (config.host) {
    host$7 = config.host;
  }
  if (config.token) {
    host$7 = config.token;
  }
}
function save$7(eventSource) {
  let url = `${host$7}/${version}/${endpoint$7}/save`;
  eventSource.url = url;
  return axios.post(url, {
    params: eventSource
  }).then(function(response) {
    response.data.clientAt = Date.now();
    return response.data;
  }).catch(function(error2) {
    return error2;
  });
}
function all$7(eventSource) {
  let url = `${host$7}/${version}/${endpoint$7}/all`;
  eventSource.url = url;
  return axios.post(url, {
    headers: {"authorization": `Bearer ${token$7}`},
    params: eventSource
  }).then(function(response) {
    response.data.clientAt = Date.now();
    return response.data;
  }).catch(function(error2) {
    return error2;
  });
}
function get$7(eventSource) {
  let url = `${host$7}/${version}/${endpoint$7}/get`;
  eventSource.url = url;
  return axios.post(url, {
    params: eventSource
  }).then(function(response) {
    response.data.clientAt = Date.now();
    return response.data;
  }).catch(function(error2) {
    return error2;
  });
}
function update$7(eventSource) {
  let url = `${host$7}/${version}/${endpoint$7}/update`;
  eventSource.url = url;
  return axios.post(url, {
    params: eventSource
  }).then(function(response) {
    response.data.clientAt = Date.now();
    return response.data;
  }).catch(function(error2) {
    return error2;
  });
}
function remove$7(eventSource) {
  let url = `${host$7}/${version}/${endpoint$7}/remove`;
  eventSource.url = url;
  return axios.post(url, {
    params: eventSource
  }).then(function(response) {
    response.data.clientAt = Date.now();
    return response.data;
  }).catch(function(error2) {
    return error2;
  });
}
var blocks$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  init: init$7,
  save: save$7,
  all: all$7,
  get: get$7,
  update: update$7,
  remove: remove$7
});
let host$6 = "http://localhost:1337";
let endpoint$6 = "pages";
let token$6 = "";
function init$6(config) {
  if (config.host) {
    host$6 = config.host;
  }
  if (config.token) {
    host$6 = config.token;
  }
}
function save$6(eventSource) {
  let url = `${host$6}/${version}/${endpoint$6}/save`;
  eventSource.url = url;
  return axios.post(url, {
    params: eventSource
  }).then(function(response) {
    response.data.clientAt = Date.now();
    return response.data;
  }).catch(function(error2) {
    return error2;
  });
}
function all$6(eventSource) {
  let url = `${host$6}/${version}/${endpoint$6}/all`;
  eventSource.url = url;
  return axios.post(url, {
    headers: {"authorization": `Bearer ${token$6}`},
    params: eventSource
  }).then(function(response) {
    response.data.clientAt = Date.now();
    return response.data;
  }).catch(function(error2) {
    return error2;
  });
}
function get$6(eventSource) {
  let url = `${host$6}/${version}/${endpoint$6}/get`;
  eventSource.url = url;
  return axios.post(url, {
    params: eventSource
  }).then(function(response) {
    response.data.clientAt = Date.now();
    return response.data;
  }).catch(function(error2) {
    return error2;
  });
}
function update$6(eventSource) {
  let url = `${host$6}/${version}/${endpoint$6}/update`;
  eventSource.url = url;
  return axios.post(url, {
    params: eventSource
  }).then(function(response) {
    response.data.clientAt = Date.now();
    return response.data;
  }).catch(function(error2) {
    return error2;
  });
}
function remove$6(eventSource) {
  let url = `${host$6}/${version}/${endpoint$6}/remove`;
  eventSource.url = url;
  return axios.post(url, {
    params: eventSource
  }).then(function(response) {
    response.data.clientAt = Date.now();
    return response.data;
  }).catch(function(error2) {
    return error2;
  });
}
function blocks(eventSource) {
  let url = `${host$6}/${version}/${endpoint$6}/blocks`;
  eventSource.url = url;
  return axios.post(url, {
    params: eventSource
  }).then(function(response) {
    response.data.clientAt = Date.now();
    return response.data;
  }).catch(function(error2) {
    return error2;
  });
}
var pages = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  init: init$6,
  save: save$6,
  all: all$6,
  get: get$6,
  update: update$6,
  remove: remove$6,
  blocks
});
let host$5 = "http://localhost:1337";
let endpoint$5 = "faq";
let token$5 = "";
function init$5(config) {
  if (config.host) {
    host$5 = config.host;
  }
  if (config.token) {
    host$5 = config.token;
  }
}
function save$5(eventSource) {
  let url = `${host$5}/${version}/${endpoint$5}/save`;
  eventSource.url = url;
  return axios.post(url, {
    params: eventSource
  }).then(function(response) {
    response.data.clientAt = Date.now();
    return response.data;
  }).catch(function(error2) {
    return error2;
  });
}
function all$5(eventSource) {
  let url = `${host$5}/${version}/${endpoint$5}/all`;
  eventSource.url = url;
  return axios.post(url, {
    headers: {"authorization": `Bearer ${token$5}`},
    params: eventSource
  }).then(function(response) {
    response.data.clientAt = Date.now();
    return response.data;
  }).catch(function(error2) {
    return error2;
  });
}
function get$5(eventSource) {
  let url = `${host$5}/${version}/${endpoint$5}/get`;
  eventSource.url = url;
  return axios.post(url, {
    params: eventSource
  }).then(function(response) {
    response.data.clientAt = Date.now();
    return response.data;
  }).catch(function(error2) {
    return error2;
  });
}
function update$5(eventSource) {
  let url = `${host$5}/${version}/${endpoint$5}/update`;
  eventSource.url = url;
  return axios.post(url, {
    params: eventSource
  }).then(function(response) {
    response.data.clientAt = Date.now();
    return response.data;
  }).catch(function(error2) {
    return error2;
  });
}
function remove$5(eventSource) {
  let url = `${host$5}/${version}/${endpoint$5}/remove`;
  eventSource.url = url;
  return axios.post(url, {
    params: eventSource
  }).then(function(response) {
    response.data.clientAt = Date.now();
    return response.data;
  }).catch(function(error2) {
    return error2;
  });
}
var faq = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  init: init$5,
  save: save$5,
  all: all$5,
  get: get$5,
  update: update$5,
  remove: remove$5
});
let host$4 = "http://localhost:1337";
let endpoint$4 = "licenses";
let token$4 = "";
function init$4(config) {
  if (config.host) {
    host$4 = config.host;
  }
  if (config.token) {
    host$4 = config.token;
  }
}
function save$4(eventSource) {
  let url = `${host$4}/${version}/${endpoint$4}/save`;
  eventSource.url = url;
  return axios.post(url, {
    params: eventSource
  }).then(function(response) {
    response.data.clientAt = Date.now();
    return response.data;
  }).catch(function(error2) {
    return error2;
  });
}
function all$4(eventSource) {
  let url = `${host$4}/${version}/${endpoint$4}/all`;
  eventSource.url = url;
  return axios.post(url, {
    headers: {"authorization": `Bearer ${token$4}`},
    params: eventSource
  }).then(function(response) {
    response.data.clientAt = Date.now();
    return response.data;
  }).catch(function(error2) {
    return error2;
  });
}
function get$4(eventSource) {
  let url = `${host$4}/${version}/${endpoint$4}/get`;
  eventSource.url = url;
  return axios.post(url, {
    params: eventSource
  }).then(function(response) {
    response.data.clientAt = Date.now();
    return response.data;
  }).catch(function(error2) {
    return error2;
  });
}
function update$4(eventSource) {
  let url = `${host$4}/${version}/${endpoint$4}/update`;
  eventSource.url = url;
  return axios.post(url, {
    params: eventSource
  }).then(function(response) {
    response.data.clientAt = Date.now();
    return response.data;
  }).catch(function(error2) {
    return error2;
  });
}
function remove$4(eventSource) {
  let url = `${host$4}/${version}/${endpoint$4}/remove`;
  eventSource.url = url;
  return axios.post(url, {
    params: eventSource
  }).then(function(response) {
    response.data.clientAt = Date.now();
    return response.data;
  }).catch(function(error2) {
    return error2;
  });
}
var licenses = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  init: init$4,
  save: save$4,
  all: all$4,
  get: get$4,
  update: update$4,
  remove: remove$4
});
let host$3 = "http://localhost:1337";
let endpoint$3 = "plans";
let token$3 = "";
function init$3(config) {
  if (config.host) {
    host$3 = config.host;
  }
  if (config.token) {
    host$3 = config.token;
  }
}
function save$3(eventSource) {
  let url = `${host$3}/${version}/${endpoint$3}/save`;
  eventSource.url = url;
  return axios.post(url, {
    params: eventSource
  }).then(function(response) {
    response.data.clientAt = Date.now();
    return response.data;
  }).catch(function(error2) {
    return error2;
  });
}
function all$3(eventSource) {
  let url = `${host$3}/${version}/${endpoint$3}/all`;
  eventSource.url = url;
  return axios.post(url, {
    headers: {"authorization": `Bearer ${token$3}`},
    params: eventSource
  }).then(function(response) {
    response.data.clientAt = Date.now();
    return response.data;
  }).catch(function(error2) {
    return error2;
  });
}
function get$3(eventSource) {
  let url = `${host$3}/${version}/${endpoint$3}/get`;
  eventSource.url = url;
  return axios.post(url, {
    params: eventSource
  }).then(function(response) {
    response.data.clientAt = Date.now();
    return response.data;
  }).catch(function(error2) {
    return error2;
  });
}
function update$3(eventSource) {
  let url = `${host$3}/${version}/${endpoint$3}/update`;
  eventSource.url = url;
  return axios.post(url, {
    params: eventSource
  }).then(function(response) {
    response.data.clientAt = Date.now();
    return response.data;
  }).catch(function(error2) {
    return error2;
  });
}
function remove$3(eventSource) {
  let url = `${host$3}/${version}/${endpoint$3}/remove`;
  eventSource.url = url;
  return axios.post(url, {
    params: eventSource
  }).then(function(response) {
    response.data.clientAt = Date.now();
    return response.data;
  }).catch(function(error2) {
    return error2;
  });
}
var plans = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  init: init$3,
  save: save$3,
  all: all$3,
  get: get$3,
  update: update$3,
  remove: remove$3
});
let host$2 = "http://localhost:1337";
let endpoint$2 = "videos";
let token$2 = "";
function init$2(config) {
  if (config.host) {
    host$2 = config.host;
  }
  if (config.token) {
    host$2 = config.token;
  }
}
function save$2(eventSource) {
  let url = `${host$2}/${version}/${endpoint$2}/save`;
  eventSource.url = url;
  return axios.post(url, {
    params: eventSource
  }).then(function(response) {
    response.data.clientAt = Date.now();
    return response.data;
  }).catch(function(error2) {
    return error2;
  });
}
function all$2(eventSource) {
  let url = `${host$2}/${version}/${endpoint$2}/all`;
  eventSource.url = url;
  return axios.post(url, {
    headers: {"authorization": `Bearer ${token$2}`},
    params: eventSource
  }).then(function(response) {
    response.data.clientAt = Date.now();
    return response.data;
  }).catch(function(error2) {
    return error2;
  });
}
function get$2(eventSource) {
  let url = `${host$2}/${version}/${endpoint$2}/get`;
  eventSource.url = url;
  return axios.post(url, {
    params: eventSource
  }).then(function(response) {
    response.data.clientAt = Date.now();
    return response.data;
  }).catch(function(error2) {
    return error2;
  });
}
function update$2(eventSource) {
  let url = `${host$2}/${version}/${endpoint$2}/update`;
  eventSource.url = url;
  return axios.post(url, {
    params: eventSource
  }).then(function(response) {
    response.data.clientAt = Date.now();
    return response.data;
  }).catch(function(error2) {
    return error2;
  });
}
function remove$2(eventSource) {
  let url = `${host$2}/${version}/${endpoint$2}/remove`;
  eventSource.url = url;
  return axios.post(url, {
    params: eventSource
  }).then(function(response) {
    response.data.clientAt = Date.now();
    return response.data;
  }).catch(function(error2) {
    return error2;
  });
}
var videos$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  init: init$2,
  save: save$2,
  all: all$2,
  get: get$2,
  update: update$2,
  remove: remove$2
});
let host$1 = "http://localhost:1337";
let endpoint$1 = "guides";
let token$1 = "";
function init$1(config) {
  if (config.host) {
    host$1 = config.host;
  }
  if (config.token) {
    host$1 = config.token;
  }
}
function save$1(eventSource) {
  let url = `${host$1}/${version}/${endpoint$1}/save`;
  eventSource.url = url;
  return axios.post(url, {
    params: eventSource
  }).then(function(response) {
    response.data.clientAt = Date.now();
    return response.data;
  }).catch(function(error2) {
    return error2;
  });
}
function all$1(eventSource) {
  let url = `${host$1}/${version}/${endpoint$1}/all`;
  eventSource.url = url;
  return axios.post(url, {
    headers: {"authorization": `Bearer ${token$1}`},
    params: eventSource
  }).then(function(response) {
    response.data.clientAt = Date.now();
    return response.data;
  }).catch(function(error2) {
    return error2;
  });
}
function get$1(eventSource) {
  let url = `${host$1}/${version}/${endpoint$1}/get`;
  eventSource.url = url;
  return axios.post(url, {
    params: eventSource
  }).then(function(response) {
    response.data.clientAt = Date.now();
    return response.data;
  }).catch(function(error2) {
    return error2;
  });
}
function update$1(eventSource) {
  let url = `${host$1}/${version}/${endpoint$1}/update`;
  eventSource.url = url;
  return axios.post(url, {
    params: eventSource
  }).then(function(response) {
    response.data.clientAt = Date.now();
    return response.data;
  }).catch(function(error2) {
    return error2;
  });
}
function remove$1(eventSource) {
  let url = `${host$1}/${version}/${endpoint$1}/remove`;
  eventSource.url = url;
  return axios.post(url, {
    params: eventSource
  }).then(function(response) {
    response.data.clientAt = Date.now();
    return response.data;
  }).catch(function(error2) {
    return error2;
  });
}
function videos(eventSource) {
  let url = `${host$1}/${version}/${endpoint$1}/videos`;
  eventSource.url = url;
  return axios.post(url, {
    params: eventSource
  }).then(function(response) {
    response.data.clientAt = Date.now();
    return response.data;
  }).catch(function(error2) {
    return error2;
  });
}
var guides$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  init: init$1,
  save: save$1,
  all: all$1,
  get: get$1,
  update: update$1,
  remove: remove$1,
  videos
});
let host = "http://localhost:1337";
let endpoint = "playlists";
let token = "";
function init(config) {
  if (config.host) {
    host = config.host;
  }
  if (config.token) {
    host = config.token;
  }
}
function save(eventSource) {
  let url = `${host}/${version}/${endpoint}/save`;
  eventSource.url = url;
  return axios.post(url, {
    params: eventSource
  }).then(function(response) {
    response.data.clientAt = Date.now();
    return response.data;
  }).catch(function(error2) {
    return error2;
  });
}
function all(eventSource) {
  let url = `${host}/${version}/${endpoint}/all`;
  eventSource.url = url;
  return axios.post(url, {
    headers: {"authorization": `Bearer ${token}`},
    params: eventSource
  }).then(function(response) {
    response.data.clientAt = Date.now();
    return response.data;
  }).catch(function(error2) {
    return error2;
  });
}
function get(eventSource) {
  let url = `${host}/${version}/${endpoint}/get`;
  eventSource.url = url;
  return axios.post(url, {
    params: eventSource
  }).then(function(response) {
    response.data.clientAt = Date.now();
    return response.data;
  }).catch(function(error2) {
    return error2;
  });
}
function update(eventSource) {
  let url = `${host}/${version}/${endpoint}/update`;
  eventSource.url = url;
  return axios.post(url, {
    params: eventSource
  }).then(function(response) {
    response.data.clientAt = Date.now();
    return response.data;
  }).catch(function(error2) {
    return error2;
  });
}
function remove(eventSource) {
  let url = `${host}/${version}/${endpoint}/remove`;
  eventSource.url = url;
  return axios.post(url, {
    params: eventSource
  }).then(function(response) {
    response.data.clientAt = Date.now();
    return response.data;
  }).catch(function(error2) {
    return error2;
  });
}
function guides(eventSource) {
  let url = `${host}/${version}/${endpoint}/guides`;
  eventSource.url = url;
  return axios.post(url, {
    params: eventSource
  }).then(function(response) {
    response.data.clientAt = Date.now();
    return response.data;
  }).catch(function(error2) {
    return error2;
  });
}
var playlists = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  init,
  save,
  all,
  get,
  update,
  remove,
  guides
});
let istrav$1 = {
  event: {
    sources
  },
  tenant: {
    members,
    apps
  },
  app: {
    menus,
    blocks: blocks$1,
    pages,
    faq
  },
  account: {
    users,
    carts,
    orders
  },
  fleet: {
    vehicles
  },
  store: {
    collections,
    categories,
    products
  },
  subscription: {
    licenses,
    plans
  },
  channel: {
    videos: videos$1,
    guides: guides$1,
    playlists
  }
};
async function doEventSource(scriptId, folderId, roomId) {
  function id(length) {
    var result = "";
    var characters = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
    var charactersLength = characters.length;
    for (var i2 = 0; i2 < length; i2++) {
      result += characters.charAt(Math.floor(Math.random() * charactersLength));
    }
    return result;
  }
  return {
    id: id(32),
    timeAt: Date.now(),
    serverAt: null,
    clientAt: null,
    folder: folderId || "event.sources",
    script: scriptId || "doEventSource",
    payload: void 0,
    io: roomId || "my-room",
    arguements: {}
  };
}
var eventSources = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  doEventSource
});
async function getAll$g(appId) {
  let es = await doEventSource("getAll", "account.users", null);
  es.arguements = {
    appId: appId || "my-app"
  };
  let eventSource = await istrav$1.account.users.all(es);
  return eventSource;
}
async function getRegister$1(appId, email, username, password, firstName, lastName) {
  let es = await doEventSource("getRegister", "account.users", null);
  es.arguements = {
    appId: appId || "my-app",
    email: email || "travis.burandt@gmail.com",
    username: username || "cool-user",
    password: password || "my-password",
    firstName: firstName || "john",
    lastName: lastName || "doe"
  };
  let eventSource = await istrav$1.account.users.register(es);
  return eventSource;
}
async function getLogin$1(appId, email, password) {
  let es = await doEventSource("getLogin", "account.users", null);
  es.arguements = {
    appId: appId || "my-app",
    email: email || "travis.burandt@gmail.com",
    password: password || "my-password"
  };
  let eventSource = await istrav$1.account.users.login(es);
  return eventSource;
}
async function getOne$g(appId, token2, username) {
  let es = await doEventSource("getOne", "account.users", null);
  es.arguements = {
    appId: appId || "my-app",
    token: token2 || "",
    username: username || "istrav"
  };
  let eventSource = await istrav$1.account.users.get(es);
  return eventSource;
}
async function getUpdate$g(appId, token2, username, change) {
  let es = await doEventSource("getUpdate", "account.users", null);
  es.arguements = {
    appId: appId || "my-app",
    token: token2 || "",
    username: username || "istrav",
    change: change || {
      firstName: "tim",
      lastName: "smith"
    }
  };
  let eventSource = await istrav$1.account.users.update(es);
  return eventSource;
}
async function getRemove$g(appId, token2, username) {
  let es = await doEventSource("getRemove", "account.users", null);
  es.arguements = {
    appId: appId || "my-app",
    token: token2 || "",
    username: username || "istrav"
  };
  let eventSource = await istrav$1.account.users.remove(es);
  return eventSource;
}
var accountUsers = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  getAll: getAll$g,
  getRegister: getRegister$1,
  getLogin: getLogin$1,
  getOne: getOne$g,
  getUpdate: getUpdate$g,
  getRemove: getRemove$g
});
async function getSave$e(appId, token2, change) {
  let es = await doEventSource("getSave", "account.carts", null);
  es.arguements = {
    appId: appId || "my-app",
    token: token2 || "",
    change: change || {
      products: []
    }
  };
  let eventSource = await istrav$1.account.carts.save(es);
  return eventSource;
}
async function getAll$f(appId, token2) {
  let es = await doEventSource("getAll", "account.carts", null);
  es.arguements = {
    appId: appId || "my-app",
    token: token2 || ""
  };
  let eventSource = await istrav$1.account.carts.all(es);
  return eventSource;
}
async function getOne$f(appId, token2, id) {
  let es = await doEventSource("getOne", "account.carts", null);
  es.arguements = {
    appId: appId || "my-app",
    token: token2 || "",
    id: id || "fpuh348f38f..."
  };
  let eventSource = await istrav$1.account.carts.get(es);
  return eventSource;
}
async function getUpdate$f(appId, token2, id, change) {
  let es = await doEventSource("getUpdate", "account.carts", null);
  es.arguements = {
    appId: appId || "my-app",
    token: token2 || "",
    id: id || "fpuh348f38f...",
    change: change || {
      products: ["uhd408dhf082..."]
    }
  };
  let eventSource = await istrav$1.account.carts.update(es);
  return eventSource;
}
async function getRemove$f(appId, token2, id) {
  let es = await doEventSource("getRemove", "account.carts", null);
  es.arguements = {
    appId: appId || "my-app",
    token: token2 || "",
    id: id || "fpuh348f38f..."
  };
  let eventSource = await istrav$1.account.carts.remove(es);
  return eventSource;
}
async function getStripeCheckoutSession(appId, token2, id) {
  let es = await doEventSource("getStripeCheckoutSession", "account.carts", null);
  es.arguements = {
    appId: appId || "my-app",
    token: token2 || "",
    id: id || "fpuh348f38f..."
  };
  let eventSource = await istrav$1.account.carts.stripeCheckoutSession(es);
  return eventSource;
}
var accountCarts = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  getSave: getSave$e,
  getAll: getAll$f,
  getOne: getOne$f,
  getUpdate: getUpdate$f,
  getRemove: getRemove$f,
  getStripeCheckoutSession
});
async function getSave$d(appId, token2, change) {
  let es = await doEventSource("getSave", "account.orders", null);
  es.arguements = {
    appId: appId || "my-app",
    token: token2 || "",
    change: change || {
      products: []
    }
  };
  let eventSource = await istrav$1.account.orders.save(es);
  return eventSource;
}
async function getAll$e(appId, token2) {
  let es = await doEventSource("getAll", "account.orders", null);
  es.arguements = {
    appId: appId || "my-app",
    token: token2 || ""
  };
  let eventSource = await istrav$1.account.orders.all(es);
  return eventSource;
}
async function getOne$e(appId, token2, id) {
  let es = await doEventSource("getOne", "account.orders", null);
  es.arguements = {
    appId: appId || "my-app",
    token: token2 || "",
    id: id || "fpuh348f38f..."
  };
  let eventSource = await istrav$1.account.orders.get(es);
  return eventSource;
}
async function getUpdate$e(appId, token2, id, change) {
  let es = await doEventSource("getUpdate", "account.orders", null);
  es.arguements = {
    appId: appId || "my-app",
    token: token2 || "",
    id: id || "fpuh348f38f...",
    change: change || {
      products: ["u43h8bubv93fb..."]
    }
  };
  let eventSource = await istrav$1.account.orders.update(es);
  return eventSource;
}
async function getRemove$e(appId, token2, id) {
  let es = await doEventSource("getRemove", "account.orders", null);
  es.arguements = {
    appId: appId || "my-app",
    token: token2 || "",
    id: id || "fpuh348f38f..."
  };
  let eventSource = await istrav$1.account.orders.remove(es);
  return eventSource;
}
var accountOrders = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  getSave: getSave$d,
  getAll: getAll$e,
  getOne: getOne$e,
  getUpdate: getUpdate$e,
  getRemove: getRemove$e
});
async function getAll$d(token2) {
  let es = await doEventSource("getAll", "tenent.apps", null);
  es.arguements = {
    token: token2 || null
  };
  let eventSource = await istrav$1.tenant.apps.all(es);
  return eventSource;
}
async function getSave$c(token2, change) {
  let es = await doEventSource("getSave", "tenent.apps", null);
  es.arguements = {
    token: token2 || null,
    change: change || {
      domain: "istrav.com",
      state: "production"
    }
  };
  let eventSource = await istrav$1.tenant.apps.save(es);
  return eventSource;
}
async function getOne$d(token2, domain, state2) {
  let es = await doEventSource("getOne", "tenent.apps", null);
  es.arguements = {
    token: token2 || null,
    domain: domain || "istrav.com",
    state: state2 || "production"
  };
  let eventSource = await istrav$1.tenant.apps.get(es);
  return eventSource;
}
async function getUpdate$d(token2, domain, state2, change) {
  let es = await doEventSource("getUpdate", "tenent.apps", null);
  es.arguements = {
    token: token2 || null,
    domain: domain || "istrav.com",
    state: state2 || "production",
    change: change || {
      state: "development"
    }
  };
  let eventSource = await istrav$1.tenant.apps.update(es);
  return eventSource;
}
async function getRemove$d(token2, domain, state2) {
  let es = await doEventSource("getRemove", "tenent.apps", null);
  es.arguements = {
    token: token2 || null,
    domain: domain || "istrav.com",
    state: state2 || "production"
  };
  let eventSource = await istrav$1.tenant.apps.remove(es);
  return eventSource;
}
async function getEndpoint(token2, endpoint2) {
  let es = await doEventSource("getEndpoint", "tenent.apps", null);
  es.arguements = {
    token: token2 || null,
    endpoint: endpoint2 || "istrav"
  };
  let eventSource = await istrav$1.tenant.apps.endpoint(es);
  return eventSource;
}
async function getTotals(domain, state2) {
  let es = await doEventSource("getTotals", "tenent.apps", null);
  es.arguements = {
    domain: domain || "istrav.com",
    state: state2 || "production"
  };
  let eventSource = await istrav$1.tenant.apps.totals(es);
  return eventSource;
}
var tenantApps = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  getAll: getAll$d,
  getSave: getSave$c,
  getOne: getOne$d,
  getUpdate: getUpdate$d,
  getRemove: getRemove$d,
  getEndpoint,
  getTotals
});
async function getAll$c() {
  let es = await doEventSource("getAll", "tenant.members", null);
  es.arguements = {};
  let eventSource = await istrav$1.tenant.members.all(es);
  return eventSource;
}
async function getRegister(email, username, password, firstName, lastName) {
  let es = await doEventSource("getRegister", "tenent.members", null);
  es.arguements = {
    email: email || "travis.burandt@gmail.com",
    username: username || "cool-user",
    password: password || "my-password",
    firstName: firstName || "john",
    lastName: lastName || "doe"
  };
  let eventSource = await istrav$1.tenant.members.register(es);
  return eventSource;
}
async function getLogin(email, password) {
  let es = await doEventSource("getLogin", "tenent.members", null);
  es.arguements = {
    email: email || "travis.burandt@gmail.com",
    password: password || "my-password"
  };
  let eventSource = await istrav$1.tenant.members.login(es);
  return eventSource;
}
async function getOne$c(email) {
  let es = await doEventSource("getOne", "tenant.members", null);
  es.arguements = {
    email: email || "travis.burandt@gmail.com"
  };
  let eventSource = await istrav$1.tenant.members.get(es);
  return eventSource;
}
async function getUpdate$c(token2, email, change) {
  let es = await doEventSource("getUpdate", "tenant.members", null);
  es.arguements = {
    token: token2 || "",
    email: email || "travis.burandt@gmail.com",
    change: change || {
      firstName: "john",
      lastName: "doe"
    }
  };
  let eventSource = await istrav$1.tenant.members.update(es);
  return eventSource;
}
async function getRemove$c(token2, email) {
  let es = await doEventSource("getRemove", "tenant.members", null);
  es.arguements = {
    token: token2 || "",
    email: email || "travis.burandt@gmail.com"
  };
  let eventSource = await istrav$1.tenant.members.remove(es);
  return eventSource;
}
var tenantMembers = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  getAll: getAll$c,
  getRegister,
  getLogin,
  getOne: getOne$c,
  getUpdate: getUpdate$c,
  getRemove: getRemove$c
});
async function getSave$b(appId, token2, change) {
  let es = await doEventSource("getSave", "store.categories", null);
  es.arguements = {
    appId: appId || "my-app",
    token: token2 || "",
    change: change || {
      name: "istrav.com",
      slug: "istrav.com",
      image: "IMG-0695.jpg"
    }
  };
  let eventSource = await istrav$1.store.categories.save(es);
  return eventSource;
}
async function getAll$b(appId) {
  let es = await doEventSource("getAll", "store.categories", null);
  es.arguements = {
    appId: appId || "my-app"
  };
  let eventSource = await istrav$1.store.categories.all(es);
  return eventSource;
}
async function getUpdate$b(appId, token2, slug, change) {
  let es = await doEventSource("getUpdate", "store.categories", null);
  es.arguements = {
    appId: appId || "my-app",
    token: token2 || "",
    slug: slug || "fpuh348f38f...",
    change: change || {
      image: "hello.jpg"
    }
  };
  let eventSource = await istrav$1.store.categories.update(es);
  return eventSource;
}
async function getOne$b(appId, slug) {
  let es = await doEventSource("getOne", "store.categories", null);
  es.arguements = {
    appId: appId || "my-app",
    slug: slug || "fpuh348f38f..."
  };
  let eventSource = await istrav$1.store.categories.get(es);
  return eventSource;
}
async function getRemove$b(appId, token2, slug) {
  let es = await doEventSource("getRemove", "store.categories", null);
  es.arguements = {
    appId: appId || "my-app",
    token: token2 || "",
    slug: slug || "fpuh348f38f..."
  };
  let eventSource = await istrav$1.store.categories.remove(es);
  return eventSource;
}
async function getProducts$1(appId, slug) {
  let es = await doEventSource("getProducts", "store.categories", null);
  es.arguements = {
    appId: appId || "my-app",
    slug: slug || "slug-here"
  };
  let eventSource = await istrav$1.store.categories.products(es);
  return eventSource;
}
var storeCategories = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  getSave: getSave$b,
  getAll: getAll$b,
  getUpdate: getUpdate$b,
  getOne: getOne$b,
  getRemove: getRemove$b,
  getProducts: getProducts$1
});
async function getSave$a(appId, token2, change) {
  let es = await doEventSource("getSave", "store.collections", null);
  es.arguements = {
    appId: appId || "my-app",
    token: token2 || "",
    change: change || {
      name: "test",
      slug: "test"
    }
  };
  let eventSource = await istrav$1.store.collections.save(es);
  return eventSource;
}
async function getAll$a(appId) {
  let es = await doEventSource("getAll", "store.collections", null);
  es.arguements = {
    appId: appId || "my-app"
  };
  let eventSource = await istrav$1.store.collections.all(es);
  return eventSource;
}
async function getUpdate$a(appId, token2, slug, change) {
  let es = await doEventSource("getUpdate", "store.collections", null);
  es.arguements = {
    appId: appId || "my-app",
    token: token2 || "",
    slug: slug || "fpuh348f38f...",
    change: change || {
      name: "test"
    }
  };
  let eventSource = await istrav$1.store.collections.update(es);
  return eventSource;
}
async function getOne$a(appId, slug) {
  let es = await doEventSource("getOne", "store.collections", null);
  es.arguements = {
    appId: appId || "my-app",
    slug: slug || "this-slug"
  };
  let eventSource = await istrav$1.store.collections.get(es);
  return eventSource;
}
async function getRemove$a(appId, token2, slug) {
  let es = await doEventSource("getRemove", "store.collections", null);
  es.arguements = {
    appId: appId || "my-app",
    token: token2 || "",
    slug: slug || "slug-here"
  };
  let eventSource = await istrav$1.store.collections.remove(es);
  return eventSource;
}
async function getProducts(appId, slug) {
  let es = await doEventSource("getProducts", "store.collections", null);
  es.arguements = {
    appId: appId || "my-app",
    slug: slug || "slug-here"
  };
  let eventSource = await istrav$1.store.collections.products(es);
  return eventSource;
}
var storeCollections = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  getSave: getSave$a,
  getAll: getAll$a,
  getUpdate: getUpdate$a,
  getOne: getOne$a,
  getRemove: getRemove$a,
  getProducts
});
async function getAll$9(appId) {
  let es = await doEventSource("getAll", "store.products", null);
  es.arguements = {
    appId: appId || "my-app"
  };
  let eventSource = await istrav$1.store.products.all(es);
  return eventSource;
}
async function getSave$9(appId, token2, change) {
  let es = await doEventSource("getSave", "store.products", null);
  es.arguements = {
    appId: appId || "my-app",
    token: token2 || "",
    change: change || {
      name: "istrav.com",
      slug: "istrav.com",
      categoryId: "plain",
      image: "IMG-0695.jpg",
      price: 23,
      details: "",
      description: ""
    }
  };
  let eventSource = await istrav$1.store.products.save(es);
  return eventSource;
}
async function getOne$9(appId, slug) {
  let es = await doEventSource("getOne", "store.products", null);
  es.arguements = {
    appId: appId || "my-app",
    slug: slug || "fpuh348f38f..."
  };
  let eventSource = await istrav$1.store.products.get(es);
  return eventSource;
}
async function getUpdate$9(appId, token2, slug, change) {
  let es = await doEventSource("getUpdate", "store.products", null);
  es.arguements = {
    appId: appId || "my-app",
    token: token2 || "",
    slug: slug || "fpuh348f38f...",
    change: change || {
      price: 25
    }
  };
  let eventSource = await istrav$1.store.products.update(es);
  return eventSource;
}
async function getRemove$9(appId, token2, slug) {
  let es = await doEventSource("getRemove", "store.products", null);
  es.arguements = {
    appId: appId || "my-app",
    token: token2 || "",
    slug: slug || "fpuh348f38f..."
  };
  let eventSource = await istrav$1.store.products.remove(es);
  return eventSource;
}
var storeProducts = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  getAll: getAll$9,
  getSave: getSave$9,
  getOne: getOne$9,
  getUpdate: getUpdate$9,
  getRemove: getRemove$9
});
async function getAll$8(appId) {
  let es = await doEventSource("getAll", "app.menus", null);
  es.arguements = {
    appId: appId || "my-app"
  };
  let eventSource = await istrav$1.app.menus.all(es);
  return eventSource;
}
async function getSave$8(appId, token2, change) {
  let es = await doEventSource("getSave", "app.menus", null);
  es.arguements = {
    appId: appId || "my-app",
    token: token2 || "",
    change: change || {
      name: "istrav.com",
      slug: "istrav.com",
      raw: {
        "name": "things",
        "url": "/categories/plain",
        "children": [
          {"name": "plain", "url": "/categories/plain"},
          {"name": "simple", "url": "/categories/simple"},
          {"name": "generic", "url": "/categories/generic"}
        ]
      }
    }
  };
  let eventSource = await istrav$1.app.menus.save(es);
  return eventSource;
}
async function getOne$8(appId, slug) {
  let es = await doEventSource("getOne", "app.menus", null);
  es.arguements = {
    appId: appId || "my-app",
    slug: slug || "fpuh348f38f..."
  };
  let eventSource = await istrav$1.app.menus.get(es);
  return eventSource;
}
async function getUpdate$8(appId, token2, slug, change) {
  let es = await doEventSource("getUpdate", "app.menus", null);
  es.arguements = {
    appId: appId || "my-app",
    token: token2 || "",
    slug: slug || "fpuh348f38f...",
    change: change || {
      name: "our-app"
    }
  };
  let eventSource = await istrav$1.app.menus.update(es);
  return eventSource;
}
async function getRemove$8(appId, token2, slug) {
  let es = await doEventSource("getRemove", "app.menus", null);
  es.arguements = {
    appId: appId || "my-app",
    token: token2 || "",
    slug: slug || "fpuh348f38f..."
  };
  let eventSource = await istrav$1.app.menus.remove(es);
  return eventSource;
}
var appMenus = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  getAll: getAll$8,
  getSave: getSave$8,
  getOne: getOne$8,
  getUpdate: getUpdate$8,
  getRemove: getRemove$8
});
async function getAll$7(appId) {
  let es = await doEventSource("getAll", "app.blocks", null);
  es.arguements = {
    appId: appId || "my-app"
  };
  let eventSource = await istrav$1.app.blocks.all(es);
  return eventSource;
}
async function getSave$7(appId, token2, change) {
  let es = await doEventSource("getSave", "app.blocks", null);
  es.arguements = {
    appId: appId || "my-app",
    token: token2 || "",
    change: change || {
      name: "our block",
      slug: "our-block"
    }
  };
  let eventSource = await istrav$1.app.blocks.save(es);
  return eventSource;
}
async function getOne$7(appId, slug) {
  let es = await doEventSource("getOne", "app.blocks", null);
  es.arguements = {
    appId: appId || "my-app",
    slug: slug || "fpuh348f38f..."
  };
  let eventSource = await istrav$1.app.blocks.get(es);
  return eventSource;
}
async function getUpdate$7(appId, token2, slug, change) {
  let es = await doEventSource("getUpdate", "app.blocks", null);
  es.arguements = {
    appId: appId || "my-app",
    token: token2 || "",
    slug: slug || "fpuh348f38f...",
    change: change || {
      name: "our-block"
    }
  };
  let eventSource = await istrav$1.app.blocks.update(es);
  return eventSource;
}
async function getRemove$7(appId, token2, slug) {
  let es = await doEventSource("getRemove", "app.blocks", null);
  es.arguements = {
    appId: appId || "my-app",
    token: token2 || "",
    slug: slug || "fpuh348f38f..."
  };
  let eventSource = await istrav$1.app.blocks.remove(es);
  return eventSource;
}
var appBlocks = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  getAll: getAll$7,
  getSave: getSave$7,
  getOne: getOne$7,
  getUpdate: getUpdate$7,
  getRemove: getRemove$7
});
async function getAll$6(appId) {
  let es = await doEventSource("getAll", "app.pages", null);
  es.arguements = {
    appId: appId || "my-app"
  };
  let eventSource = await istrav$1.app.pages.all(es);
  return eventSource;
}
async function getSave$6(appId, token2, change) {
  let es = await doEventSource("getSave", "app.pages", null);
  es.arguements = {
    appId: appId || "my-app",
    token: token2 || "",
    change: change || {
      name: "my-article",
      slug: "my-article",
      content: "### hello world"
    }
  };
  let eventSource = await istrav$1.app.pages.save(es);
  return eventSource;
}
async function getOne$6(appId, slug) {
  let es = await doEventSource("getOne", "app.pages", null);
  es.arguements = {
    appId: appId || "my-app",
    slug: slug || "fpuh348f38f..."
  };
  let eventSource = await istrav$1.app.pages.get(es);
  return eventSource;
}
async function getUpdate$6(appId, token2, slug, change) {
  let es = await doEventSource("getUpdate", "app.pages", null);
  es.arguements = {
    appId: appId || "my-app",
    token: token2 || "",
    slug: slug || "fpuh348f38f...",
    change: change || {
      name: "our-app"
    }
  };
  let eventSource = await istrav$1.app.pages.update(es);
  return eventSource;
}
async function getRemove$6(appId, token2, slug) {
  let es = await doEventSource("getRemove", "app.pages", null);
  es.arguements = {
    appId: appId || "my-app",
    token: token2 || "",
    slug: slug || "fpuh348f38f..."
  };
  let eventSource = await istrav$1.app.pages.remove(es);
  return eventSource;
}
async function getBlocks(appId, slug) {
  let es = await doEventSource("getBlocks", "app.pages", null);
  es.arguements = {
    appId: appId || "my-app",
    slug: slug || "slug-here"
  };
  let eventSource = await istrav$1.app.pages.blocks(es);
  return eventSource;
}
var appPages = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  getAll: getAll$6,
  getSave: getSave$6,
  getOne: getOne$6,
  getUpdate: getUpdate$6,
  getRemove: getRemove$6,
  getBlocks
});
async function getAll$5(appId) {
  let es = await doEventSource("getAll", "app.faq", null);
  es.arguements = {
    appId: appId || "my-app"
  };
  let eventSource = await istrav$1.app.faq.all(es);
  return eventSource;
}
async function getSave$5(appId, token2, change) {
  let es = await doEventSource("getSave", "app.faq", null);
  es.arguements = {
    appId: appId || "my-app",
    token: token2 || "",
    change: change || {
      name: "how-do-you...",
      slug: "how-do-you",
      content: "### hello world"
    }
  };
  let eventSource = await istrav$1.app.faq.save(es);
  return eventSource;
}
async function getOne$5(appId, slug) {
  let es = await doEventSource("getOne", "app.faq", null);
  es.arguements = {
    appId: appId || "my-app",
    slug: slug || "fpuh348f38f..."
  };
  let eventSource = await istrav$1.app.faq.get(es);
  return eventSource;
}
async function getUpdate$5(appId, token2, slug, change) {
  let es = await doEventSource("getUpdate", "app.faq", null);
  es.arguements = {
    appId: appId || "my-app",
    token: token2 || "",
    slug: slug || "fpuh348f38f...",
    change: change || {
      name: "our-app"
    }
  };
  let eventSource = await istrav$1.app.faq.update(es);
  return eventSource;
}
async function getRemove$5(appId, token2, slug) {
  let es = await doEventSource("getRemove", "app.faq", null);
  es.arguements = {
    appId: appId || "my-app",
    token: token2 || "",
    slug: slug || "fpuh348f38f..."
  };
  let eventSource = await istrav$1.app.faq.remove(es);
  return eventSource;
}
var appFAQ = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  getAll: getAll$5,
  getSave: getSave$5,
  getOne: getOne$5,
  getUpdate: getUpdate$5,
  getRemove: getRemove$5
});
async function getAll$4(appId) {
  let es = await doEventSource("getAll", "subscription.licenses", null);
  es.arguements = {
    appId: appId || "my-app"
  };
  let eventSource = await istrav$1.subscription.licenses.all(es);
  return eventSource;
}
async function getSave$4(appId, token2, change) {
  let es = await doEventSource("getSave", "subscription.licenses", null);
  es.arguements = {
    appId: appId || "my-app",
    token: token2 || "",
    change: change || {
      key: "2o473874g348gf348yg...",
      raw: ""
    }
  };
  let eventSource = await istrav$1.subscription.licenses.save(es);
  return eventSource;
}
async function getOne$4(key) {
  let es = await doEventSource("getOne", "subscription.licenses", null);
  es.arguements = {
    key: key || "fpuh348f38f..."
  };
  let eventSource = await istrav$1.subscription.licenses.get(es);
  return eventSource;
}
async function getUpdate$4(appId, token2, key, change) {
  let es = await doEventSource("getUpdate", "subscription.licenses", null);
  es.arguements = {
    appId: appId || "my-app",
    token: token2 || "",
    key: key || "fpuh348f38f...",
    change: change || {
      key: "r438gf348h34fu834gf8..."
    }
  };
  let eventSource = await istrav$1.subscription.licenses.update(es);
  return eventSource;
}
async function getRemove$4(appId, token2, key) {
  let es = await doEventSource("getRemove", "subscription.licenses", null);
  es.arguements = {
    appId: appId || "my-app",
    token: token2 || "",
    key: key || "fpuh348f38f..."
  };
  let eventSource = await istrav$1.subscription.licenses.remove(es);
  return eventSource;
}
var subscriptionLicenses = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  getAll: getAll$4,
  getSave: getSave$4,
  getOne: getOne$4,
  getUpdate: getUpdate$4,
  getRemove: getRemove$4
});
async function getAll$3(appId) {
  let es = await doEventSource("getAll", "subscription.plans", null);
  es.arguements = {
    appId: appId || "my-app"
  };
  let eventSource = await istrav$1.subscription.plans.all(es);
  return eventSource;
}
async function getSave$3(appId, token2, change) {
  let es = await doEventSource("getSave", "subscription.plans", null);
  es.arguements = {
    appId: appId || "my-app",
    token: token2 || "",
    change: change || {
      name: "istrav.com",
      slug: "istrav.com",
      categoryId: "plain",
      image: "IMG-0695.jpg",
      price: 23,
      details: "",
      description: ""
    }
  };
  let eventSource = await istrav$1.subscription.plans.save(es);
  return eventSource;
}
async function getOne$3(appId, slug) {
  let es = await doEventSource("getOne", "subscription.plans", null);
  es.arguements = {
    appId: appId || "my-app",
    slug: slug || "fpuh348f38f..."
  };
  let eventSource = await istrav$1.subscription.plans.get(es);
  return eventSource;
}
async function getUpdate$3(appId, token2, slug, change) {
  let es = await doEventSource("getUpdate", "subscription.plans", null);
  es.arguements = {
    appId: appId || "my-app",
    token: token2 || "",
    slug: slug || "fpuh348f38f...",
    change: change || {
      price: 25
    }
  };
  let eventSource = await istrav$1.subscription.plans.update(es);
  return eventSource;
}
async function getRemove$3(appId, token2, slug) {
  let es = await doEventSource("getRemove", "subscription.plans", null);
  es.arguements = {
    appId: appId || "my-app",
    token: token2 || "",
    slug: slug || "fpuh348f38f..."
  };
  let eventSource = await istrav$1.subscription.plans.remove(es);
  return eventSource;
}
var subscriptionPlans = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  getAll: getAll$3,
  getSave: getSave$3,
  getOne: getOne$3,
  getUpdate: getUpdate$3,
  getRemove: getRemove$3
});
async function getAll$2(appId) {
  let es = await doEventSource("getAll", "channel.videos", null);
  es.arguements = {
    appId: appId || "my-app"
  };
  let eventSource = await istrav$1.channel.videos.all(es);
  return eventSource;
}
async function getSave$2(appId, token2, change) {
  let es = await doEventSource("getSave", "channel.videos", null);
  es.arguements = {
    appId: appId || "my-app",
    token: token2 || "",
    change: change || {
      name: "istrav.com",
      slug: "istrav.com",
      image: "IMG-0695.jpg",
      video: "sdkjhsdhj.mp4",
      description: ""
    }
  };
  let eventSource = await istrav$1.channel.videos.save(es);
  return eventSource;
}
async function getOne$2(appId, slug) {
  let es = await doEventSource("getOne", "channel.videos", null);
  es.arguements = {
    appId: appId || "my-app",
    slug: slug || "fpuh348f38f..."
  };
  let eventSource = await istrav$1.channel.videos.get(es);
  return eventSource;
}
async function getUpdate$2(appId, token2, slug, change) {
  let es = await doEventSource("getUpdate", "channel.videos", null);
  es.arguements = {
    appId: appId || "my-app",
    token: token2 || "",
    slug: slug || "fpuh348f38f...",
    change: change || {
      video: "sdgsgrdfg.mp4"
    }
  };
  let eventSource = await istrav$1.channel.videos.update(es);
  return eventSource;
}
async function getRemove$2(appId, token2, slug) {
  let es = await doEventSource("getRemove", "channel.videos", null);
  es.arguements = {
    appId: appId || "my-app",
    token: token2 || "",
    slug: slug || "fpuh348f38f..."
  };
  let eventSource = await istrav$1.channel.videos.remove(es);
  return eventSource;
}
var channelVideos = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  getAll: getAll$2,
  getSave: getSave$2,
  getOne: getOne$2,
  getUpdate: getUpdate$2,
  getRemove: getRemove$2
});
async function getSave$1(appId, token2, change) {
  let es = await doEventSource("getSave", "channel.guides", null);
  es.arguements = {
    appId: appId || "my-app",
    token: token2 || "",
    change: change || {
      name: "test",
      slug: "test"
    }
  };
  let eventSource = await istrav$1.channel.guides.save(es);
  return eventSource;
}
async function getAll$1(appId) {
  let es = await doEventSource("getAll", "channel.guides", null);
  es.arguements = {
    appId: appId || "my-app"
  };
  let eventSource = await istrav$1.channel.guides.all(es);
  return eventSource;
}
async function getUpdate$1(appId, token2, slug, change) {
  let es = await doEventSource("getUpdate", "channel.guides", null);
  es.arguements = {
    appId: appId || "my-app",
    token: token2 || "",
    slug: slug || "fpuh348f38f...",
    change: change || {
      name: "test"
    }
  };
  let eventSource = await istrav$1.channel.guides.update(es);
  return eventSource;
}
async function getOne$1(appId, slug) {
  let es = await doEventSource("getOne", "channel.guides", null);
  es.arguements = {
    appId: appId || "my-app",
    slug: slug || "this-slug"
  };
  let eventSource = await istrav$1.channel.guides.get(es);
  return eventSource;
}
async function getRemove$1(appId, token2, slug) {
  let es = await doEventSource("getRemove", "channel.guides", null);
  es.arguements = {
    appId: appId || "my-app",
    token: token2 || "",
    slug: slug || "slug-here"
  };
  let eventSource = await istrav$1.channel.guides.remove(es);
  return eventSource;
}
async function getVideos(appId, slug) {
  let es = await doEventSource("getVideos", "channel.guides", null);
  es.arguements = {
    appId: appId || "my-app",
    slug: slug || "slug-here"
  };
  let eventSource = await istrav$1.channel.guides.videos(es);
  return eventSource;
}
var channelGuides = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  getSave: getSave$1,
  getAll: getAll$1,
  getUpdate: getUpdate$1,
  getOne: getOne$1,
  getRemove: getRemove$1,
  getVideos
});
async function getSave(appId, token2, change) {
  let es = await doEventSource("getSave", "channel.playlists", null);
  es.arguements = {
    appId: appId || "my-app",
    token: token2 || "",
    change: change || {
      name: "test",
      slug: "test"
    }
  };
  let eventSource = await istrav$1.channel.playlists.save(es);
  return eventSource;
}
async function getAll(appId) {
  let es = await doEventSource("getAll", "channel.playlists", null);
  es.arguements = {
    appId: appId || "my-app"
  };
  let eventSource = await istrav$1.channel.playlists.all(es);
  return eventSource;
}
async function getUpdate(appId, token2, slug, change) {
  let es = await doEventSource("getUpdate", "channel.playlists", null);
  es.arguements = {
    appId: appId || "my-app",
    token: token2 || "",
    slug: slug || "fpuh348f38f...",
    change: change || {
      name: "test"
    }
  };
  let eventSource = await istrav$1.channel.playlists.update(es);
  return eventSource;
}
async function getOne(appId, slug) {
  let es = await doEventSource("getOne", "channel.playlists", null);
  es.arguements = {
    appId: appId || "my-app",
    slug: slug || "this-slug"
  };
  let eventSource = await istrav$1.channel.playlists.get(es);
  return eventSource;
}
async function getRemove(appId, token2, slug) {
  let es = await doEventSource("getRemove", "channel.playlists", null);
  es.arguements = {
    appId: appId || "my-app",
    token: token2 || "",
    slug: slug || "slug-here"
  };
  let eventSource = await istrav$1.channel.playlists.remove(es);
  return eventSource;
}
async function getGuides(appId, slug) {
  let es = await doEventSource("getGuides", "channel.playlists", null);
  es.arguements = {
    appId: appId || "my-app",
    slug: slug || "slug-here"
  };
  let eventSource = await istrav$1.channel.playlists.guides(es);
  return eventSource;
}
var channelPlaylists = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  getSave,
  getAll,
  getUpdate,
  getOne,
  getRemove,
  getGuides
});
let scripts$1 = {
  headless: {
    doHelloWorld,
    doRun
  },
  event: {
    sources: eventSources
  },
  tenant: {
    members: tenantMembers,
    apps: tenantApps
  },
  app: {
    menus: appMenus,
    blocks: appBlocks,
    pages: appPages,
    faq: appFAQ
  },
  account: {
    users: accountUsers,
    carts: accountCarts,
    orders: accountOrders
  },
  store: {
    collections: storeCollections,
    categories: storeCategories,
    products: storeProducts
  },
  subscription: {
    licenses: subscriptionLicenses,
    plans: subscriptionPlans
  },
  channel: {
    videos: channelVideos,
    guides: channelGuides,
    playlists: channelPlaylists
  }
};
async function doHelloWorld() {
  console.log(`hello scripts: ${JSON.stringify(scripts$1, null, 2)}`);
}
async function doRun(scriptId) {
  scriptId = scriptId || "doHelloWorld";
  let script = window[`${scriptId}Code`].getValue();
  let call = new Function("return " + script)();
  let called = await call();
  console.log(`SCRIPT ::: ${JSON.stringify(called, null, 2)}`);
}
let istrav = istrav$1;
let scripts = scripts$1;
async function load$1({session}) {
  return {
    apiUri: {}.VITE_API_URI,
    ioUri: {}.VITE_IO_URI,
    headlessUri: {}.VITE_HEADLESS_URI
  };
}
let state = "production";
const _layout = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let {apiUri} = $$props;
  let {ioUri} = $$props;
  let {headlessUri} = $$props;
  let app;
  appData.subscribe((value) => {
    app = value;
  });
  let domain;
  domainId.subscribe((value) => {
    domain = value;
  });
  let backend;
  backendId.subscribe((value) => {
    backend = value;
  });
  let headless;
  headlessId.subscribe((value) => {
    headless = value;
  });
  let io2;
  ioId.subscribe((value) => {
    io2 = value;
  });
  let loading = true;
  onMount(async () => {
    if (window.location.host === "localhost:5000") {
      console.log("using localhost settings:");
      domainId.set("istrav.com");
      headlessId.set("http://localhost:9999");
      backendId.set("http://localhost:1337");
      ioId.set("http://localhost:3333");
    } else {
      console.log("using production settings:");
      domainId.set(window.location.host);
      headlessId.set(headlessUri || "https://farmerless.com");
      backendId.set(apiUri || "https://api.hacktracks.org");
      ioId.set(ioUri || "https://io.hacktracks.org");
    }
    console.log(domain, backend, headless, io2);
    istrav.account.carts.init({host: backend});
    istrav.account.orders.init({host: backend});
    istrav.account.users.init({host: backend});
    istrav.app.blocks.init({host: backend});
    istrav.app.faq.init({host: backend});
    istrav.app.menus.init({host: backend});
    istrav.app.pages.init({host: backend});
    istrav.channel.guides.init({host: backend});
    istrav.channel.playlists.init({host: backend});
    istrav.channel.videos.init({host: backend});
    istrav.store.categories.init({host: backend});
    istrav.store.collections.init({host: backend});
    istrav.store.products.init({host: backend});
    istrav.subscription.licenses.init({host: backend});
    istrav.subscription.plans.init({host: backend});
    istrav.tenant.apps.init({host: backend});
    istrav.tenant.members.init({host: backend});
    if (domain.includes("localhost:5000")) {
      domain = "istrav.com";
    }
    if (domain.includes("aaghc.com")) {
      let endpoint2 = domain.split(".")[0];
      let esEndpoint = await scripts.tenant.apps.getEndpoint(null, endpoint2);
      if (esEndpoint.payload.success === true) {
        appData.set(esEndpoint.payload.data);
      } else {
        alert(esEndpoint.payload.reason);
      }
    } else {
      domain = domain.split(".").slice(-2).join(".");
      let esOne = await scripts.tenant.apps.getOne(null, domain, state);
      if (esOne.payload.success === true) {
        appData.set(esOne.payload.data);
      } else {
        alert(esOne.payload.reason);
      }
    }
    console.log("appData", app);
    loading = false;
  });
  if ($$props.apiUri === void 0 && $$bindings.apiUri && apiUri !== void 0)
    $$bindings.apiUri(apiUri);
  if ($$props.ioUri === void 0 && $$bindings.ioUri && ioUri !== void 0)
    $$bindings.ioUri(ioUri);
  if ($$props.headlessUri === void 0 && $$bindings.headlessUri && headlessUri !== void 0)
    $$bindings.headlessUri(headlessUri);
  return `${loading ? `` : `${slots.default ? slots.default({}) : ``}`}

<div id="${"code"}"></div>`;
});
var __layout = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": _layout,
  load: load$1
});
function load({error: error2, status}) {
  return {props: {error: error2, status}};
}
const Error$1 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let {status} = $$props;
  let {error: error2} = $$props;
  if ($$props.status === void 0 && $$bindings.status && status !== void 0)
    $$bindings.status(status);
  if ($$props.error === void 0 && $$bindings.error && error2 !== void 0)
    $$bindings.error(error2);
  return `<h1>${escape(status)}</h1>

<p>${escape(error2.message)}</p>


${error2.stack ? `<pre>${escape(error2.stack)}</pre>` : ``}`;
});
var error = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Error$1,
  load
});
const particles = {
  number: {
    value: 30,
    density: {
      enable: true,
      value_area: 800
    }
  },
  color: {
    value: "#ffffff"
  },
  shape: {
    type: "circle",
    stroke: {
      width: 0,
      color: "#000000"
    },
    polygon: {
      nb_sides: 5
    },
    image: {
      src: "img/github.svg",
      width: 100,
      height: 100
    }
  },
  opacity: {
    value: 0.5,
    random: false,
    anim: {
      enable: false,
      speed: 1,
      opacity_min: 0.1,
      sync: false
    }
  },
  size: {
    value: 5,
    random: true,
    anim: {
      enable: false,
      speed: 80,
      size_min: 0.1,
      sync: false
    }
  },
  line_linked: {
    enable: true,
    distance: 300,
    color: "#ffffff",
    opacity: 0.4,
    width: 2
  },
  move: {
    enable: true,
    speed: 5,
    direction: "none",
    random: false,
    straight: false,
    out_mode: "out",
    bounce: false,
    attract: {
      enable: false,
      rotateX: 600,
      rotateY: 1200
    }
  }
};
const interactivity = {
  detect_on: "canvas",
  events: {
    onhover: {
      enable: false,
      mode: "repulse"
    },
    onclick: {
      enable: true,
      mode: "push"
    },
    resize: true
  },
  modes: {
    grab: {
      distance: 800,
      line_linked: {
        opacity: 1
      }
    },
    bubble: {
      distance: 800,
      size: 80,
      duration: 2,
      opacity: 0.8,
      speed: 3
    },
    repulse: {
      distance: 400,
      duration: 0.4
    },
    push: {
      particles_nb: 4
    },
    remove: {
      particles_nb: 2
    }
  }
};
const retina_detect = true;
var particlesConfig = {
  particles,
  interactivity,
  retina_detect
};
var Generic1_svelte_svelte_type_style_lang = "";
const css$4 = {
  code: "body{overflow:hidden;padding:0 !important}.wire.svelte-19ta0uf{border:1px dashed #000;padding:0.2em;margin:0.2em;min-height:5em;position:relative}.wrapper.svelte-19ta0uf{margin:0;padding:0;border-bottom:0;align-items:inherit}.name.svelte-19ta0uf{position:absolute;top:0;left:0;color:#000;border:1px dashed #000;border-left:0;border-top:0;padding:0.2em;text-transform:uppercase;font-weight:500}.slogan.svelte-19ta0uf{text-align:center}header.wire.svelte-19ta0uf,.controls.wire.svelte-19ta0uf,.logo.wire.svelte-19ta0uf,.slogan.wire.svelte-19ta0uf,article.wire.svelte-19ta0uf,main.wire.svelte-19ta0uf,footer.wire.svelte-19ta0uf,.navigation.wire.svelte-19ta0uf{padding-top:2.2em !important}header.svelte-19ta0uf{overflow:hidden;height:10em;position:relative}#tsparticles{background-color:#ee6e73;overflow:hidden;position:absolute;top:0;right:0;bottom:0;left:0}header.wire.svelte-19ta0uf{min-height:20em}.middle.svelte-19ta0uf{position:absolute;right:0;left:0;width:100%;position:absolute;top:50%;-ms-transform:translateY(-50%);transform:translateY(-50%)}.logo.svelte-19ta0uf,.slogan.svelte-19ta0uf,.controls.svelte-19ta0uf,article.svelte-19ta0uf{width:100%}",
  map: `{"version":3,"file":"Generic1.svelte","sources":["Generic1.svelte"],"sourcesContent":["<script>\\n  import { onMount } from \\"svelte\\";\\n\\n  // export let app\\n  // export let page\\n  export let showWiring\\n\\n\\t// onMount(() => {\\n\\t// \\t/* particlesJS.load(@dom-id, @path-json, @callback (optional)); */\\n\\t// \\twindow['particlesJS'].load('particles-js', './particles.json', function() {\\n\\t// \\t\\tconsole.log('callback - particles.js config loaded');\\n\\t// \\t});\\n\\t// })\\n\\n  import particlesConfig from '../particles.json'\\n  let ParticlesComponent;\\n\\n  console.log('particlesConfig', particlesConfig)\\n\\n  onMount(async () => {\\n    const module = await import(\\"svelte-particles\\")\\n\\n    ParticlesComponent = module.default\\n  })\\n\\n  let onParticlesLoaded = (event) => {\\n    const particlesContainer = event.detail.particles\\n\\n    // you can use particlesContainer to call all the Container class\\n    // (from the core library) methods like play, pause, refresh, start, stop\\n  }\\n\\n  let onParticlesInit = (main) => {\\n    // you can use main to customize the tsParticles instance adding presets or custom shapes\\n  }\\n</script>\\n\\n<header class={showWiring ? 'wire' : ''}>\\n  <svelte:component\\n    this=\\"{ParticlesComponent}\\"\\n    id=\\"tsparticles\\"\\n    options=\\"{particlesConfig}\\"\\n    on:particlesLoaded=\\"{onParticlesLoaded}\\"\\n    on:particlesInit=\\"{onParticlesInit}\\"\\n  />\\n  <div class=\\"row wrapper middle\\">\\n    <div class=\\"col wrapper s12 m6\\" style=\\"flex-direction: column;\\">\\n      <div class={showWiring ? 'logo wire' : 'logo'}>\\n        {#if showWiring}\\n          <div class=\\"name\\">logo</div>\\n        {/if}\\n        <slot name=\\"logo\\"></slot>\\n      </div>\\n      <div class={showWiring ? 'slogan wire' : 'slogan'}>\\n        {#if showWiring}\\n          <div class=\\"name\\">slogan</div>\\n        {/if}\\n        <slot name=\\"slogan\\"></slot>\\n      </div>\\n    </div>\\n    <div class=\\"col wrapper s12 m6\\">\\n      <div class={showWiring ? 'controls wire' : 'controls'}>\\n        {#if showWiring}\\n          <div class=\\"name\\">controls</div>\\n        {/if}\\n        <slot name=\\"controls\\"></slot>\\n      </div>\\n    </div>\\n  </div>\\n</header>\\n<div class={showWiring ? 'navigation wire' : 'navigation'}>\\n  {#if showWiring}\\n    <div class=\\"name\\">navigation</div>\\n  {/if}\\n  <slot name=\\"navigation\\"></slot>\\n</div>\\n<div class=\\"row wrapper\\" style=\\"min-height: 100vh;\\">\\n  <div class=\\"col s12 m1\\"></div>\\n  <div class=\\"col s12 m10\\">\\n    <br />\\n    <br />\\n    <br />\\n    <article class={showWiring ? 'wire' : ''}>\\n      {#if showWiring}\\n        <div class=\\"name\\">article</div>\\n      {/if}\\n      <slot name=\\"article\\"></slot>\\n    </article>\\n    <br />\\n    <br />\\n    <br />\\n  </div>\\n  <div class=\\"col s12 m1\\"></div>\\n</div>\\n<main class={showWiring ? 'wire' : ''}>\\n  {#if showWiring}\\n    <div class=\\"name\\">main</div>\\n  {/if}\\n  <slot name=\\"main\\"></slot>\\n</main>\\n<footer class={showWiring ? 'wire' : ''}>\\n  {#if showWiring}\\n    <div class=\\"name\\">footer</div>\\n  {/if}\\n  <slot name=\\"footer\\"></slot>\\n</footer>\\n\\n<style>\\n  :global(body) {\\n    overflow: hidden;\\n    padding: 0 !important;\\n  }\\n  \\n  .wire {\\n    border: 1px dashed #000;\\n    padding: 0.2em;\\n    margin: 0.2em;\\n    min-height: 5em;\\n    position: relative;\\n  }\\n\\n  .wrapper {\\n    margin: 0;\\n    padding: 0;\\n    border-bottom: 0;\\n    align-items: inherit;\\n  }\\n\\n  .name {\\n    position: absolute;\\n    top: 0;\\n    left: 0;\\n    color: #000;\\n    border: 1px dashed #000;\\n    border-left: 0;\\n    border-top: 0;\\n    padding: 0.2em;\\n    text-transform: uppercase;\\n    font-weight: 500;\\n  }\\n\\n  .slogan {\\n    text-align: center;\\n  }\\n\\n  header.wire,\\n  .controls.wire,\\n  .logo.wire,\\n  .slogan.wire,\\n  article.wire,\\n  main.wire,\\n  footer.wire,\\n  .navigation.wire {\\n    padding-top: 2.2em !important;\\n  }\\n\\n  header {\\n    overflow: hidden;\\n    height: 10em;\\n    position: relative;\\n  }\\n\\n  :global(#tsparticles) {\\n\\t\\tbackground-color: #ee6e73;\\n\\t\\toverflow: hidden;\\n\\t\\tposition: absolute;\\n\\t\\ttop: 0;\\n\\t\\tright: 0;\\n\\t\\tbottom: 0;\\n\\t\\tleft: 0;\\n\\t}\\n\\n  header.wire {\\n    min-height: 20em;\\n  }\\n\\n  .middle {\\n    position: absolute;\\n    right: 0; \\n    left: 0;\\n    width: 100%;\\n    position: absolute;\\n    top: 50%;\\n    -ms-transform: translateY(-50%);\\n    transform: translateY(-50%);\\n  }\\n\\n  .logo,\\n  .slogan,\\n  .controls,\\n  article {\\n    width: 100%;\\n  }\\n</style>"],"names":[],"mappings":"AA4GU,IAAI,AAAE,CAAC,AACb,QAAQ,CAAE,MAAM,CAChB,OAAO,CAAE,CAAC,CAAC,UAAU,AACvB,CAAC,AAED,KAAK,eAAC,CAAC,AACL,MAAM,CAAE,GAAG,CAAC,MAAM,CAAC,IAAI,CACvB,OAAO,CAAE,KAAK,CACd,MAAM,CAAE,KAAK,CACb,UAAU,CAAE,GAAG,CACf,QAAQ,CAAE,QAAQ,AACpB,CAAC,AAED,QAAQ,eAAC,CAAC,AACR,MAAM,CAAE,CAAC,CACT,OAAO,CAAE,CAAC,CACV,aAAa,CAAE,CAAC,CAChB,WAAW,CAAE,OAAO,AACtB,CAAC,AAED,KAAK,eAAC,CAAC,AACL,QAAQ,CAAE,QAAQ,CAClB,GAAG,CAAE,CAAC,CACN,IAAI,CAAE,CAAC,CACP,KAAK,CAAE,IAAI,CACX,MAAM,CAAE,GAAG,CAAC,MAAM,CAAC,IAAI,CACvB,WAAW,CAAE,CAAC,CACd,UAAU,CAAE,CAAC,CACb,OAAO,CAAE,KAAK,CACd,cAAc,CAAE,SAAS,CACzB,WAAW,CAAE,GAAG,AAClB,CAAC,AAED,OAAO,eAAC,CAAC,AACP,UAAU,CAAE,MAAM,AACpB,CAAC,AAED,MAAM,oBAAK,CACX,SAAS,oBAAK,CACd,KAAK,oBAAK,CACV,OAAO,oBAAK,CACZ,OAAO,oBAAK,CACZ,IAAI,oBAAK,CACT,MAAM,oBAAK,CACX,WAAW,KAAK,eAAC,CAAC,AAChB,WAAW,CAAE,KAAK,CAAC,UAAU,AAC/B,CAAC,AAED,MAAM,eAAC,CAAC,AACN,QAAQ,CAAE,MAAM,CAChB,MAAM,CAAE,IAAI,CACZ,QAAQ,CAAE,QAAQ,AACpB,CAAC,AAEO,YAAY,AAAE,CAAC,AACvB,gBAAgB,CAAE,OAAO,CACzB,QAAQ,CAAE,MAAM,CAChB,QAAQ,CAAE,QAAQ,CAClB,GAAG,CAAE,CAAC,CACN,KAAK,CAAE,CAAC,CACR,MAAM,CAAE,CAAC,CACT,IAAI,CAAE,CAAC,AACR,CAAC,AAEA,MAAM,KAAK,eAAC,CAAC,AACX,UAAU,CAAE,IAAI,AAClB,CAAC,AAED,OAAO,eAAC,CAAC,AACP,QAAQ,CAAE,QAAQ,CAClB,KAAK,CAAE,CAAC,CACR,IAAI,CAAE,CAAC,CACP,KAAK,CAAE,IAAI,CACX,QAAQ,CAAE,QAAQ,CAClB,GAAG,CAAE,GAAG,CACR,aAAa,CAAE,WAAW,IAAI,CAAC,CAC/B,SAAS,CAAE,WAAW,IAAI,CAAC,AAC7B,CAAC,AAED,oBAAK,CACL,sBAAO,CACP,wBAAS,CACT,OAAO,eAAC,CAAC,AACP,KAAK,CAAE,IAAI,AACb,CAAC"}`
};
const Generic1 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let {showWiring} = $$props;
  let ParticlesComponent;
  console.log("particlesConfig", particlesConfig);
  onMount(async () => {
    const module = await Promise.resolve().then(function() {
      return svelteParticles$1;
    });
    ParticlesComponent = module.default;
  });
  if ($$props.showWiring === void 0 && $$bindings.showWiring && showWiring !== void 0)
    $$bindings.showWiring(showWiring);
  $$result.css.add(css$4);
  return `<header class="${escape(null_to_empty(showWiring ? "wire" : "")) + " svelte-19ta0uf"}">${validate_component(ParticlesComponent || missing_component, "svelte:component").$$render($$result, {
    id: "tsparticles",
    options: particlesConfig
  }, {}, {})}
  <div class="${"row wrapper middle svelte-19ta0uf"}"><div class="${"col wrapper s12 m6 svelte-19ta0uf"}" style="${"flex-direction: column;"}"><div class="${escape(null_to_empty(showWiring ? "logo wire" : "logo")) + " svelte-19ta0uf"}">${showWiring ? `<div class="${"name svelte-19ta0uf"}">logo</div>` : ``}
        ${slots.logo ? slots.logo({}) : ``}</div>
      <div class="${escape(null_to_empty(showWiring ? "slogan wire" : "slogan")) + " svelte-19ta0uf"}">${showWiring ? `<div class="${"name svelte-19ta0uf"}">slogan</div>` : ``}
        ${slots.slogan ? slots.slogan({}) : ``}</div></div>
    <div class="${"col wrapper s12 m6 svelte-19ta0uf"}"><div class="${escape(null_to_empty(showWiring ? "controls wire" : "controls")) + " svelte-19ta0uf"}">${showWiring ? `<div class="${"name svelte-19ta0uf"}">controls</div>` : ``}
        ${slots.controls ? slots.controls({}) : ``}</div></div></div></header>
<div class="${escape(null_to_empty(showWiring ? "navigation wire" : "navigation")) + " svelte-19ta0uf"}">${showWiring ? `<div class="${"name svelte-19ta0uf"}">navigation</div>` : ``}
  ${slots.navigation ? slots.navigation({}) : ``}</div>
<div class="${"row wrapper svelte-19ta0uf"}" style="${"min-height: 100vh;"}"><div class="${"col s12 m1"}"></div>
  <div class="${"col s12 m10"}"><br>
    <br>
    <br>
    <article class="${escape(null_to_empty(showWiring ? "wire" : "")) + " svelte-19ta0uf"}">${showWiring ? `<div class="${"name svelte-19ta0uf"}">article</div>` : ``}
      ${slots.article ? slots.article({}) : ``}</article>
    <br>
    <br>
    <br></div>
  <div class="${"col s12 m1"}"></div></div>
<main class="${escape(null_to_empty(showWiring ? "wire" : "")) + " svelte-19ta0uf"}">${showWiring ? `<div class="${"name svelte-19ta0uf"}">main</div>` : ``}
  ${slots.main ? slots.main({}) : ``}</main>
<footer class="${escape(null_to_empty(showWiring ? "wire" : "")) + " svelte-19ta0uf"}">${showWiring ? `<div class="${"name svelte-19ta0uf"}">footer</div>` : ``}
  ${slots.footer ? slots.footer({}) : ``}
</footer>`;
});
const TawkToChatWidget = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let {propertyId = ""} = $$props;
  let {chatId = "default"} = $$props;
  onMount(() => {
    (function() {
      var s1 = document.createElement("script"), s0 = document.getElementsByTagName("script")[0];
      s1.async = true;
      s1.src = `https://embed.tawk.to/${propertyId}/${chatId}`;
      s1.charset = "UTF-8";
      s1.setAttribute("crossorigin", "*");
      s0.parentNode.insertBefore(s1, s0);
    })();
  });
  if ($$props.propertyId === void 0 && $$bindings.propertyId && propertyId !== void 0)
    $$bindings.propertyId(propertyId);
  if ($$props.chatId === void 0 && $$bindings.chatId && chatId !== void 0)
    $$bindings.chatId(chatId);
  return ``;
});
const GoogleAnalytics = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let {measurementId} = $$props;
  onMount(() => {
    (function() {
      var s1 = document.createElement("script"), s0 = document.getElementsByTagName("script")[0];
      s1.async = true;
      s1.src = `https://www.googletagmanager.com/gtag/js?id=${measurementId}`;
      s0.parentNode.insertBefore(s1, s0);
    })();
    window["dataLayer"] = window["dataLayer"] || [];
    function gtag() {
      window["dataLayer"].push(arguments);
    }
    gtag("js", new Date());
    gtag("config", measurementId);
  });
  if ($$props.measurementId === void 0 && $$bindings.measurementId && measurementId !== void 0)
    $$bindings.measurementId(measurementId);
  return ``;
});
var MainFooter_svelte_svelte_type_style_lang = "";
const css$3 = {
  code: "footer.svelte-1tjgpbh{text-align:left}.footer-copyright.svelte-1tjgpbh{background-color:rgba(0,0,0,0.1)}",
  map: `{"version":3,"file":"MainFooter.svelte","sources":["MainFooter.svelte"],"sourcesContent":["<script>\\n  import { onMount } from 'svelte';\\n\\n  import { istrav, scripts } from '../../api'\\n\\n  import TawkToChatWidget from './footer/TawkToChatWidget.svelte'\\n  import GoogleAnalytics from './footer/GoogleAnalytics.svelte'\\n\\n  export let app = {}\\n  export let page\\n  export let block\\n\\texport let data\\n  export let menuId\\n  export let selected\\n  \\n  let propertyId = app.tawkToPropertyId // || '6051205af7ce18270930caec'\\n  let chatId = app.tawkToChatId // || '1f0ueco46'\\n  let measurementId = app.googleAnalyticsMeasurementId // || 'G-M6CKY68372'\\n  let items = []\\n\\n\\tonMount(async () => {\\n    console.log('block', page)\\n    console.log('block', block)\\n    console.log('selected', selected)\\n\\n    if (data) {\\n      // we already have the menus\\n      menuId = data.menuId\\n      items = JSON.parse(data.menu.raw)\\n    } else if (menuId) {\\n      // get the menus\\n      let esNavigation = await scripts.app.menus.getOne(app.id, menuId)\\n      if (esNavigation.payload.success === true) {\\n        items = JSON.parse(esNavigation.payload.data.raw)\\n      } else {\\n        console.log(esNavigation.payload.reason)\\n      }\\n    }\\n    console.log('main menu', items)\\n  })\\n</script>\\n\\n{#if propertyId && chatId}\\n  <TawkToChatWidget propertyId={propertyId} chatId={chatId} />\\n{/if}\\n{#if measurementId}\\n  <GoogleAnalytics measurementId={measurementId} />\\n{/if}\\n\\n<footer class=\\"page-footer\\" style={\`background-color: \${app.coverBackColor}; color: \${app.coverTextColor}\`}>\\n  <div class=\\"container\\">\\n    <div class=\\"row\\">\\n      <div class=\\"col l6 s12\\">\\n        <h5 class=\\"white-text\\">{app.labelName || ''}</h5>\\n        <p class=\\"grey-text text-lighten-4\\">{app.labelAbout || ''}</p>\\n      </div>\\n      <div class=\\"col l4 offset-l2 s12\\">\\n        <h5 class=\\"white-text\\">{app.labelPrimaryOffering || ''}</h5>\\n        {#if items.length > 0}\\n          <ul>\\n            {#each items as nav}\\n              <li><a class=\\"grey-text text-lighten-3\\" href={nav.url}>{nav.name}</a></li>\\n            {/each}\\n          </ul>\\n        {/if}\\n      </div>\\n    </div>\\n  </div>\\n  <div class=\\"footer-copyright\\">\\n    <div class=\\"container\\">\\n      Copyright @{new Date().getFullYear()} <a href={\`https://\${app.domain}\`}>{app.domain}</a>. All Rights Reserved. Powered by <a href=\\"https://istrav.com\\" target=\\"_blank\\">ISTRAV</a>.\\n    </div>\\n  </div>\\n</footer>\\n\\n<style>\\n  footer {\\n    text-align: left;\\n  }\\n\\n  .footer-copyright {\\n    background-color: rgba(0,0,0,0.1);\\n  }\\n</style>"],"names":[],"mappings":"AA4EE,MAAM,eAAC,CAAC,AACN,UAAU,CAAE,IAAI,AAClB,CAAC,AAED,iBAAiB,eAAC,CAAC,AACjB,gBAAgB,CAAE,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,AACnC,CAAC"}`
};
const MainFooter = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let {app = {}} = $$props;
  let {page} = $$props;
  let {block} = $$props;
  let {data} = $$props;
  let {menuId} = $$props;
  let {selected} = $$props;
  let propertyId = app.tawkToPropertyId;
  let chatId = app.tawkToChatId;
  let measurementId = app.googleAnalyticsMeasurementId;
  let items = [];
  onMount(async () => {
    console.log("block", page);
    console.log("block", block);
    console.log("selected", selected);
    if (data) {
      menuId = data.menuId;
      items = JSON.parse(data.menu.raw);
    } else if (menuId) {
      let esNavigation = await scripts.app.menus.getOne(app.id, menuId);
      if (esNavigation.payload.success === true) {
        items = JSON.parse(esNavigation.payload.data.raw);
      } else {
        console.log(esNavigation.payload.reason);
      }
    }
    console.log("main menu", items);
  });
  if ($$props.app === void 0 && $$bindings.app && app !== void 0)
    $$bindings.app(app);
  if ($$props.page === void 0 && $$bindings.page && page !== void 0)
    $$bindings.page(page);
  if ($$props.block === void 0 && $$bindings.block && block !== void 0)
    $$bindings.block(block);
  if ($$props.data === void 0 && $$bindings.data && data !== void 0)
    $$bindings.data(data);
  if ($$props.menuId === void 0 && $$bindings.menuId && menuId !== void 0)
    $$bindings.menuId(menuId);
  if ($$props.selected === void 0 && $$bindings.selected && selected !== void 0)
    $$bindings.selected(selected);
  $$result.css.add(css$3);
  return `${propertyId && chatId ? `${validate_component(TawkToChatWidget, "TawkToChatWidget").$$render($$result, {propertyId, chatId}, {}, {})}` : ``}
${measurementId ? `${validate_component(GoogleAnalytics, "GoogleAnalytics").$$render($$result, {measurementId}, {}, {})}` : ``}

<footer class="${"page-footer svelte-1tjgpbh"}"${add_attribute("style", `background-color: ${app.coverBackColor}; color: ${app.coverTextColor}`, 0)}><div class="${"container"}"><div class="${"row"}"><div class="${"col l6 s12"}"><h5 class="${"white-text"}">${escape(app.labelName || "")}</h5>
        <p class="${"grey-text text-lighten-4"}">${escape(app.labelAbout || "")}</p></div>
      <div class="${"col l4 offset-l2 s12"}"><h5 class="${"white-text"}">${escape(app.labelPrimaryOffering || "")}</h5>
        ${items.length > 0 ? `<ul>${each(items, (nav) => `<li><a class="${"grey-text text-lighten-3"}"${add_attribute("href", nav.url, 0)}>${escape(nav.name)}</a></li>`)}</ul>` : ``}</div></div></div>
  <div class="${"footer-copyright svelte-1tjgpbh"}"><div class="${"container"}">Copyright @${escape(new Date().getFullYear())} <a${add_attribute("href", `https://${app.domain}`, 0)}>${escape(app.domain)}</a>. All Rights Reserved. Powered by <a href="${"https://istrav.com"}" target="${"_blank"}">ISTRAV</a>.
    </div></div>
</footer>`;
});
var Navigation_svelte_svelte_type_style_lang = "";
const css$2 = {
  code: ".nav.svelte-1tdh9r9.svelte-1tdh9r9{padding:1em;text-align:center;background-color:#111}.nav.svelte-1tdh9r9 a.svelte-1tdh9r9{margin:0.5em}",
  map: '{"version":3,"file":"Navigation.svelte","sources":["Navigation.svelte"],"sourcesContent":["<script>\\n  import { onMount } from \'svelte\';\\n\\n  import { istrav, scripts } from \'../../api\'\\n  \\n  export let app\\n  export let page\\n  export let selected\\n  export let menuId\\n  export let block\\n  export let data\\n  \\n  let items = []\\n  \\n\\tonMount(async () => {    \\n    console.log(\'block\', block)\\n    if (data) {\\n      // we already have the menus\\n      menuId = data.menuId\\n      items = JSON.parse(data.menu.raw)\\n    } else if (menuId) {\\n      // get the menus from server\\n      let esNavigation = await scripts.app.menus.getOne(app.id, menuId)\\n      if (esNavigation.payload.success === true) {\\n        items = JSON.parse(esNavigation.payload.data.raw)\\n      } else {\\n        console.log(esNavigation.payload.reason)\\n      }\\n    } else {\\n      console.log(\'no menus to load\')\\n    }\\n\\n    console.log(\'menu\', menuId, items)\\n  })\\n</script>\\n\\n{#if items.length > 0}\\n\\t<div class=\\"nav\\">\\n\\t\\t{#each items as nav}\\n\\t\\t\\t{#if nav.id === `pages.${page.slug}` || nav.id === selected}\\n\\t\\t\\t\\t<a href={nav.url} class={`btn-large waves-effect waves-light ${app.primaryBtnBackColor} ${app.primaryBtnTextColor}`}>\\n\\t\\t\\t\\t\\t{nav.name}\\n\\t\\t\\t\\t</a>\\n\\t\\t\\t{:else}\\n\\t\\t\\t\\t<a href={nav.url} class={`btn-large waves-effect waves-light ${app.secondaryBtnBackColor} ${app.secondaryBtnTextColor}`}>\\n\\t\\t\\t\\t\\t{nav.name}\\n\\t\\t\\t\\t</a>\\n\\t\\t\\t{/if}\\n\\t\\t{/each}\\n\\t</div>\\n{/if}\\n\\n<style>\\n  .nav {\\n    padding: 1em;\\n    text-align: center;\\n    background-color: #111;\\n  }\\n\\n  .nav a {\\n    margin: 0.5em;\\n  }\\n</style>\\n\\n"],"names":[],"mappings":"AAqDE,IAAI,8BAAC,CAAC,AACJ,OAAO,CAAE,GAAG,CACZ,UAAU,CAAE,MAAM,CAClB,gBAAgB,CAAE,IAAI,AACxB,CAAC,AAED,mBAAI,CAAC,CAAC,eAAC,CAAC,AACN,MAAM,CAAE,KAAK,AACf,CAAC"}'
};
const Navigation = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let {app} = $$props;
  let {page} = $$props;
  let {selected} = $$props;
  let {menuId} = $$props;
  let {block} = $$props;
  let {data} = $$props;
  let items = [];
  onMount(async () => {
    console.log("block", block);
    if (data) {
      menuId = data.menuId;
      items = JSON.parse(data.menu.raw);
    } else if (menuId) {
      let esNavigation = await scripts.app.menus.getOne(app.id, menuId);
      if (esNavigation.payload.success === true) {
        items = JSON.parse(esNavigation.payload.data.raw);
      } else {
        console.log(esNavigation.payload.reason);
      }
    } else {
      console.log("no menus to load");
    }
    console.log("menu", menuId, items);
  });
  if ($$props.app === void 0 && $$bindings.app && app !== void 0)
    $$bindings.app(app);
  if ($$props.page === void 0 && $$bindings.page && page !== void 0)
    $$bindings.page(page);
  if ($$props.selected === void 0 && $$bindings.selected && selected !== void 0)
    $$bindings.selected(selected);
  if ($$props.menuId === void 0 && $$bindings.menuId && menuId !== void 0)
    $$bindings.menuId(menuId);
  if ($$props.block === void 0 && $$bindings.block && block !== void 0)
    $$bindings.block(block);
  if ($$props.data === void 0 && $$bindings.data && data !== void 0)
    $$bindings.data(data);
  $$result.css.add(css$2);
  return `${items.length > 0 ? `<div class="${"nav svelte-1tdh9r9"}">${each(items, (nav) => `${nav.id === `pages.${page.slug}` || nav.id === selected ? `<a${add_attribute("href", nav.url, 0)} class="${escape(null_to_empty(`btn-large waves-effect waves-light ${app.primaryBtnBackColor} ${app.primaryBtnTextColor}`)) + " svelte-1tdh9r9"}">${escape(nav.name)}
				</a>` : `<a${add_attribute("href", nav.url, 0)} class="${escape(null_to_empty(`btn-large waves-effect waves-light ${app.secondaryBtnBackColor} ${app.secondaryBtnTextColor}`)) + " svelte-1tdh9r9"}">${escape(nav.name)}
				</a>`}`)}</div>` : ``}`;
});
var Logo_svelte_svelte_type_style_lang = "";
const css$1 = {
  code: ".logo.svelte-1nk0mbu.svelte-1nk0mbu{margin:-1em 0 0 0;font-size:1.5em;font-weight:800;text-align:center;color:#333}.aaghc.svelte-1nk0mbu.svelte-1nk0mbu{margin:0 auto;font-size:4em;font-weight:800;text-align:center;font-family:sans-serif;color:#333;cursor:pointer;display:table}.aaghc.svelte-1nk0mbu .first-a.svelte-1nk0mbu{float:left}.aaghc.svelte-1nk0mbu .second-a.svelte-1nk0mbu{margin-left:-0.2em;float:left}.aaghc.svelte-1nk0mbu .third-g.svelte-1nk0mbu{margin-right:0.1em;float:left}.aaghc.svelte-1nk0mbu .rotate-letter.svelte-1nk0mbu{transform:rotate(-90deg);float:left}.aaghc.svelte-1nk0mbu .space-letter.svelte-1nk0mbu{float:left}",
  map: '{"version":3,"file":"Logo.svelte","sources":["Logo.svelte"],"sourcesContent":["<script>\\n  import { onMount } from \\"svelte\\";\\n\\t\\n  export let app\\n  // export let page\\n  // export let block\\n\\t// export let data\\n\\texport let fontSize\\n\\texport let height\\n\\n\\tonMount(() => {\\n\\t\\tconsole.log(\'app\', app)\\n\\t})\\n\\n\\tlet show = false\\n\\n\\tfunction showMagic () {\\n\\t\\tshow = true\\n\\t}\\n\\tfunction hideMagic () {\\n\\t\\tshow = false\\n\\t}\\n</script>\\n\\n{#if app}\\n\\t<div style={`font-size: ${fontSize};`}>\\n\\t\\t{#if app.domain === \'istrav.com\'}\\n\\t\\t\\t<div class=\\"logo\\">\\n\\t\\t\\t\\t<span style=\\"font-style: italic; font-size: 3em; margin: 0 -0.1em;\\">IS</span>\\n\\t\\t\\t\\t<span style=\\"font-style: italic; vertical-align: top; font-size: 1.5em; line-height: 2.3em;\\">TRAV</span>\\n\\t\\t\\t</div>\\n\\t\\t{:else if app.domain === \'aaghc.com\'}\\n\\t\\t\\t<div class=\\"aaghc\\" on:mouseenter={showMagic} on:mouseleave={hideMagic}>\\n\\t\\t\\t\\t{#if show}\\n\\t\\t\\t\\t\\tAAGHC\\n\\t\\t\\t\\t{:else}\\n\\t\\t\\t\\t\\t<div class=\\"first-a\\">A</div><div class=\\"second-a\\">A</div><div class=\\"third-g\\">G</div><div class=\\"rotate-letter\\">H</div><div class=\\"space-letter\\">C</div>\\n\\t\\t\\t\\t{/if}\\n\\t\\t\\t</div>\\n\\t\\t{:else}\\n\\t\\t\\t{#if app.logo}\\n\\t\\t\\t\\t<div class=\\"logo\\">\\n\\t\\t\\t\\t\\t<img src={`${app.uploads}/${app.logo}`} style={`height: ${height}; margin: 0.5em;`} alt={app.name} />\\n\\t\\t\\t\\t</div>\\n\\t\\t\\t{:else}\\n\\t\\t\\t\\t<div class=\\"logo\\">\\n\\t\\t\\t\\t\\t<span style=\\"font-size: 1.5em; line-height: 2em;\\">{app.labelName || \'\'}</span>\\n\\t\\t\\t\\t</div>\\n\\t\\t\\t{/if}\\n\\t\\t{/if}\\n\\t</div>\\n{/if}\\n\\n<style>\\n\\t.logo {\\n\\t\\tmargin: -1em 0 0 0;\\n\\t\\tfont-size: 1.5em;\\n\\t\\tfont-weight: 800;\\n\\t\\ttext-align: center;\\n\\t\\tcolor: #333;\\n\\t}\\n\\n\\t.aaghc {\\n\\t\\tmargin: 0 auto;\\n\\t\\tfont-size: 4em;\\n\\t\\tfont-weight: 800;\\n\\t\\ttext-align: center;\\n\\t\\tfont-family: sans-serif;\\n\\t\\tcolor: #333;\\n\\t\\tcursor: pointer;\\n\\t\\tdisplay: table;\\n\\t}\\n\\n\\t.aaghc .first-a {\\n\\t\\tfloat: left;\\n\\t}\\n\\n\\t.aaghc .second-a {\\n\\t\\tmargin-left: -0.2em;\\n\\t\\tfloat: left;\\n\\t}\\n\\n\\t.aaghc .third-g {\\n\\t\\tmargin-right: 0.1em;\\n\\t\\tfloat: left;\\n\\t}\\n\\n\\t.aaghc .rotate-letter {\\n\\t\\ttransform: rotate(-90deg);\\n\\t\\tfloat: left;\\n\\t}\\n\\n\\t.aaghc .space-letter {\\n\\t\\tfloat: left;\\n\\t}\\n</style>"],"names":[],"mappings":"AAsDC,KAAK,8BAAC,CAAC,AACN,MAAM,CAAE,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAClB,SAAS,CAAE,KAAK,CAChB,WAAW,CAAE,GAAG,CAChB,UAAU,CAAE,MAAM,CAClB,KAAK,CAAE,IAAI,AACZ,CAAC,AAED,MAAM,8BAAC,CAAC,AACP,MAAM,CAAE,CAAC,CAAC,IAAI,CACd,SAAS,CAAE,GAAG,CACd,WAAW,CAAE,GAAG,CAChB,UAAU,CAAE,MAAM,CAClB,WAAW,CAAE,UAAU,CACvB,KAAK,CAAE,IAAI,CACX,MAAM,CAAE,OAAO,CACf,OAAO,CAAE,KAAK,AACf,CAAC,AAED,qBAAM,CAAC,QAAQ,eAAC,CAAC,AAChB,KAAK,CAAE,IAAI,AACZ,CAAC,AAED,qBAAM,CAAC,SAAS,eAAC,CAAC,AACjB,WAAW,CAAE,MAAM,CACnB,KAAK,CAAE,IAAI,AACZ,CAAC,AAED,qBAAM,CAAC,QAAQ,eAAC,CAAC,AAChB,YAAY,CAAE,KAAK,CACnB,KAAK,CAAE,IAAI,AACZ,CAAC,AAED,qBAAM,CAAC,cAAc,eAAC,CAAC,AACtB,SAAS,CAAE,OAAO,MAAM,CAAC,CACzB,KAAK,CAAE,IAAI,AACZ,CAAC,AAED,qBAAM,CAAC,aAAa,eAAC,CAAC,AACrB,KAAK,CAAE,IAAI,AACZ,CAAC"}'
};
const Logo = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let {app} = $$props;
  let {fontSize} = $$props;
  let {height} = $$props;
  onMount(() => {
    console.log("app", app);
  });
  if ($$props.app === void 0 && $$bindings.app && app !== void 0)
    $$bindings.app(app);
  if ($$props.fontSize === void 0 && $$bindings.fontSize && fontSize !== void 0)
    $$bindings.fontSize(fontSize);
  if ($$props.height === void 0 && $$bindings.height && height !== void 0)
    $$bindings.height(height);
  $$result.css.add(css$1);
  return `${app ? `<div${add_attribute("style", `font-size: ${fontSize};`, 0)}>${app.domain === "istrav.com" ? `<div class="${"logo svelte-1nk0mbu"}"><span style="${"font-style: italic; font-size: 3em; margin: 0 -0.1em;"}">IS</span>
				<span style="${"font-style: italic; vertical-align: top; font-size: 1.5em; line-height: 2.3em;"}">TRAV</span></div>` : `${app.domain === "aaghc.com" ? `<div class="${"aaghc svelte-1nk0mbu"}">${`<div class="${"first-a svelte-1nk0mbu"}">A</div><div class="${"second-a svelte-1nk0mbu"}">A</div><div class="${"third-g svelte-1nk0mbu"}">G</div><div class="${"rotate-letter svelte-1nk0mbu"}">H</div><div class="${"space-letter svelte-1nk0mbu"}">C</div>`}</div>` : `${app.logo ? `<div class="${"logo svelte-1nk0mbu"}"><img${add_attribute("src", `${app.uploads}/${app.logo}`, 0)}${add_attribute("style", `height: ${height}; margin: 0.5em;`, 0)}${add_attribute("alt", app.name, 0)}></div>` : `<div class="${"logo svelte-1nk0mbu"}"><span style="${"font-size: 1.5em; line-height: 2em;"}">${escape(app.labelName || "")}</span></div>`}`}`}</div>` : ``}`;
});
var Slogan_svelte_svelte_type_style_lang = "";
const css = {
  code: ".slogan.svelte-1eqsnln{font-weight:600;text-align:center;margin-top:-1em;font-size:1em;color:#333}",
  map: '{"version":3,"file":"Slogan.svelte","sources":["Slogan.svelte"],"sourcesContent":["<script>\\n  import { onMount } from \\"svelte\\";\\n\\n  export let app\\n  // export let page\\n  // export let block\\n\\t// export let data\\n\\texport let fontSize\\n</script>\\n\\n{#if app.labelSloganLine1}\\n\\t<h1 class=\\"slogan\\" style={`font-size: ${fontSize}`}>{app.labelSloganLine1 || \'\'}<br />{app.labelSloganLine2 || \'\'}</h1>\\n{:else}\\n\\t<h1 class=\\"slogan\\" style={`font-size: ${fontSize}`}>Community messaging<br />and bulletin board.</h1>\\n{/if}\\n\\n<style>\\n\\t.slogan {\\n\\t\\tfont-weight: 600;\\n\\t\\ttext-align: center;\\n\\t\\tmargin-top: -1em;\\n    font-size: 1em;\\n\\t\\tcolor: #333;\\n\\t}\\n</style>"],"names":[],"mappings":"AAiBC,OAAO,eAAC,CAAC,AACR,WAAW,CAAE,GAAG,CAChB,UAAU,CAAE,MAAM,CAClB,UAAU,CAAE,IAAI,CACd,SAAS,CAAE,GAAG,CAChB,KAAK,CAAE,IAAI,AACZ,CAAC"}'
};
const Slogan = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let {app} = $$props;
  let {fontSize} = $$props;
  if ($$props.app === void 0 && $$bindings.app && app !== void 0)
    $$bindings.app(app);
  if ($$props.fontSize === void 0 && $$bindings.fontSize && fontSize !== void 0)
    $$bindings.fontSize(fontSize);
  $$result.css.add(css);
  return `${app.labelSloganLine1 ? `<h1 class="${"slogan svelte-1eqsnln"}"${add_attribute("style", `font-size: ${fontSize}`, 0)}>${escape(app.labelSloganLine1 || "")}<br>${escape(app.labelSloganLine2 || "")}</h1>` : `<h1 class="${"slogan svelte-1eqsnln"}"${add_attribute("style", `font-size: ${fontSize}`, 0)}>Community messaging<br>and bulletin board.</h1>`}`;
});
const Routes = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let app;
  appData.subscribe((value) => {
    app = value;
    console.log(app);
  });
  return `${$$result.head += `${app.id ? `${$$result.title = `<title>Message Bulletin Board - ${escape(app.labelName)}</title>`, ""}` : ``}`, ""}

${app.id ? `${validate_component(Generic1, "Generic1").$$render($$result, {showWiring: false}, {}, {
    footer: () => `<section slot="${"footer"}" class="${"slot"}">${validate_component(MainFooter, "MainFooter").$$render($$result, {
      app,
      page: {},
      selected: "forum",
      menuId: "marketing"
    }, {}, {})}</section>`,
    main: () => `<section slot="${"main"}" class="${"slot"}"></section>`,
    article: () => `<section slot="${"article"}" class="${"slot"}">hello messages :)
    </section>`,
    navigation: () => `<section slot="${"navigation"}" class="${"slot"}">${validate_component(Navigation, "Navigation").$$render($$result, {
      app,
      page: {},
      selected: "forum",
      menuId: "main"
    }, {}, {})}</section>`,
    controls: () => `<section slot="${"controls"}" class="${"slot"}">CONTROLS
    </section>`,
    slogan: () => `<section slot="${"slogan"}" class="${"slot"}">${validate_component(Slogan, "Slogan").$$render($$result, {app, fontSize: "1em"}, {}, {})}</section>`,
    logo: () => `<section slot="${"logo"}" class="${"slot"}">${validate_component(Logo, "Logo").$$render($$result, {app, fontSize: "", height: ""}, {}, {})}</section>`
  })}` : ``}`;
});
var index = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Routes
});
function t() {
}
function e(t2) {
  return t2();
}
function i() {
  return Object.create(null);
}
function o(t2) {
  t2.forEach(e);
}
function s(t2) {
  return typeof t2 == "function";
}
function n(t2, e2) {
  return t2 != t2 ? e2 == e2 : t2 !== e2 || t2 && typeof t2 == "object" || typeof t2 == "function";
}
function a(t2) {
  t2.parentNode.removeChild(t2);
}
function r(t2, e2, i2) {
  i2 == null ? t2.removeAttribute(e2) : t2.getAttribute(e2) !== i2 && t2.setAttribute(e2, i2);
}
let l;
function c(t2) {
  l = t2;
}
function d() {
  if (!l)
    throw new Error("Function called outside component initialization");
  return l;
}
function h() {
  const t2 = d();
  return (e2, i2) => {
    const o2 = t2.$$.callbacks[e2];
    if (o2) {
      const s2 = function(t3, e3) {
        const i3 = document.createEvent("CustomEvent");
        return i3.initCustomEvent(t3, false, false, e3), i3;
      }(e2, i2);
      o2.slice().forEach((e3) => {
        e3.call(t2, s2);
      });
    }
  };
}
const u = [], v = [], p = [], y = [], f = Promise.resolve();
let m = false;
function g(t2) {
  p.push(t2);
}
let b = false;
const w = new Set();
function x() {
  if (!b) {
    b = true;
    do {
      for (let t2 = 0; t2 < u.length; t2 += 1) {
        const e2 = u[t2];
        c(e2), k(e2.$$);
      }
      for (c(null), u.length = 0; v.length; )
        v.pop()();
      for (let t2 = 0; t2 < p.length; t2 += 1) {
        const e2 = p[t2];
        w.has(e2) || (w.add(e2), e2());
      }
      p.length = 0;
    } while (u.length);
    for (; y.length; )
      y.pop()();
    m = false, b = false, w.clear();
  }
}
function k(t2) {
  if (t2.fragment !== null) {
    t2.update(), o(t2.before_update);
    const e2 = t2.dirty;
    t2.dirty = [-1], t2.fragment && t2.fragment.p(t2.ctx, e2), t2.after_update.forEach(g);
  }
}
const P = new Set();
function M(t2, e2) {
  t2.$$.dirty[0] === -1 && (u.push(t2), m || (m = true, f.then(x)), t2.$$.dirty.fill(0)), t2.$$.dirty[e2 / 31 | 0] |= 1 << e2 % 31;
}
function R(n2, r2, d2, h2, u2, v2, p2 = [-1]) {
  const y2 = l;
  c(n2);
  const f2 = n2.$$ = {fragment: null, ctx: null, props: v2, update: t, not_equal: u2, bound: i(), on_mount: [], on_destroy: [], on_disconnect: [], before_update: [], after_update: [], context: new Map(y2 ? y2.$$.context : []), callbacks: i(), dirty: p2, skip_bound: false};
  let m2 = false;
  if (f2.ctx = d2 ? d2(n2, r2.props || {}, (t2, e2, ...i2) => {
    const o2 = i2.length ? i2[0] : e2;
    return f2.ctx && u2(f2.ctx[t2], f2.ctx[t2] = o2) && (!f2.skip_bound && f2.bound[t2] && f2.bound[t2](o2), m2 && M(n2, t2)), e2;
  }) : [], f2.update(), m2 = true, o(f2.before_update), f2.fragment = !!h2 && h2(f2.ctx), r2.target) {
    if (r2.hydrate) {
      const t2 = function(t3) {
        return Array.from(t3.childNodes);
      }(r2.target);
      f2.fragment && f2.fragment.l(t2), t2.forEach(a);
    } else
      f2.fragment && f2.fragment.c();
    r2.intro && ((b2 = n2.$$.fragment) && b2.i && (P.delete(b2), b2.i(w2))), function(t2, i2, n3, a2) {
      const {fragment: r3, on_mount: l2, on_destroy: c2, after_update: d3} = t2.$$;
      r3 && r3.m(i2, n3), a2 || g(() => {
        const i3 = l2.map(e).filter(s);
        c2 ? c2.push(...i3) : o(i3), t2.$$.on_mount = [];
      }), d3.forEach(g);
    }(n2, r2.target, r2.anchor, r2.customElement), x();
  }
  var b2, w2;
  c(y2);
}
class S {
  getSidesCount() {
    return 4;
  }
  draw(t2, e2, i2) {
    t2.rect(-i2, -i2, 2 * i2, 2 * i2);
  }
}
var C, z, A;
!function(t2) {
  t2.bottom = "bottom", t2.left = "left", t2.right = "right", t2.top = "top";
}(C || (C = {})), function(t2) {
  t2.bottom = "bottom", t2.bottomLeft = "bottom-left", t2.bottomRight = "bottom-right", t2.left = "left", t2.none = "none", t2.right = "right", t2.top = "top", t2.topLeft = "top-left", t2.topRight = "top-right";
}(z || (z = {})), function(t2) {
  t2.clockwise = "clockwise", t2.counterClockwise = "counter-clockwise", t2.random = "random";
}(A || (A = {}));
class T {
  constructor(t2, e2) {
    let i2, o2;
    if (e2 === void 0) {
      if (typeof t2 == "number")
        throw new Error("tsParticles - Vector not initialized correctly");
      const e3 = t2;
      [i2, o2] = [e3.x, e3.y];
    } else
      [i2, o2] = [t2, e2];
    this.x = i2, this.y = o2;
  }
  static clone(t2) {
    return T.create(t2.x, t2.y);
  }
  static create(t2, e2) {
    return new T(t2, e2);
  }
  get angle() {
    return Math.atan2(this.y, this.x);
  }
  set angle(t2) {
    this.updateFromAngle(t2, this.length);
  }
  get length() {
    return Math.sqrt(Math.pow(this.x, 2) + Math.pow(this.y, 2));
  }
  set length(t2) {
    this.updateFromAngle(this.angle, t2);
  }
  add(t2) {
    return T.create(this.x + t2.x, this.y + t2.y);
  }
  addTo(t2) {
    this.x += t2.x, this.y += t2.y;
  }
  sub(t2) {
    return T.create(this.x - t2.x, this.y - t2.y);
  }
  subFrom(t2) {
    this.x -= t2.x, this.y -= t2.y;
  }
  mult(t2) {
    return T.create(this.x * t2, this.y * t2);
  }
  multTo(t2) {
    this.x *= t2, this.y *= t2;
  }
  div(t2) {
    return T.create(this.x / t2, this.y / t2);
  }
  divTo(t2) {
    this.x /= t2, this.y /= t2;
  }
  distanceTo(t2) {
    return this.sub(t2).length;
  }
  getLengthSq() {
    return Math.pow(this.x, 2) + Math.pow(this.y, 2);
  }
  distanceToSq(t2) {
    return this.sub(t2).getLengthSq();
  }
  manhattanDistanceTo(t2) {
    return Math.abs(t2.x - this.x) + Math.abs(t2.y - this.y);
  }
  copy() {
    return T.clone(this);
  }
  setTo(t2) {
    this.x = t2.x, this.y = t2.y;
  }
  rotate(t2) {
    return T.create(this.x * Math.cos(t2) - this.y * Math.sin(t2), this.x * Math.sin(t2) + this.y * Math.cos(t2));
  }
  updateFromAngle(t2, e2) {
    this.x = Math.cos(t2) * e2, this.y = Math.sin(t2) * e2;
  }
}
T.origin = T.create(0, 0);
class E {
  static clamp(t2, e2, i2) {
    return Math.min(Math.max(t2, e2), i2);
  }
  static mix(t2, e2, i2, o2) {
    return Math.floor((t2 * i2 + e2 * o2) / (i2 + o2));
  }
  static randomInRange(t2) {
    const e2 = E.getRangeMax(t2);
    let i2 = E.getRangeMin(t2);
    return e2 === i2 && (i2 = 0), Math.random() * (e2 - i2) + i2;
  }
  static getRangeValue(t2) {
    return typeof t2 == "number" ? t2 : E.randomInRange(t2);
  }
  static getRangeMin(t2) {
    return typeof t2 == "number" ? t2 : t2.min;
  }
  static getRangeMax(t2) {
    return typeof t2 == "number" ? t2 : t2.max;
  }
  static setRangeValue(t2, e2) {
    if (t2 === e2 || e2 === void 0 && typeof t2 == "number")
      return t2;
    const i2 = E.getRangeMin(t2), o2 = E.getRangeMax(t2);
    return e2 !== void 0 ? {min: Math.min(i2, e2), max: Math.max(o2, e2)} : E.setRangeValue(i2, o2);
  }
  static getValue(t2) {
    const e2 = t2.random, {enable: i2, minimumValue: o2} = typeof e2 == "boolean" ? {enable: e2, minimumValue: 0} : e2;
    return i2 ? E.getRangeValue(E.setRangeValue(t2.value, o2)) : E.getRangeValue(t2.value);
  }
  static getDistances(t2, e2) {
    const i2 = t2.x - e2.x, o2 = t2.y - e2.y;
    return {dx: i2, dy: o2, distance: Math.sqrt(i2 * i2 + o2 * o2)};
  }
  static getDistance(t2, e2) {
    return E.getDistances(t2, e2).distance;
  }
  static getParticleBaseVelocity(t2) {
    const e2 = T.origin;
    switch (e2.length = 1, t2) {
      case z.top:
        e2.angle = -Math.PI / 2;
        break;
      case z.topRight:
        e2.angle = -Math.PI / 4;
        break;
      case z.right:
        e2.angle = 0;
        break;
      case z.bottomRight:
        e2.angle = Math.PI / 4;
        break;
      case z.bottom:
        e2.angle = Math.PI / 2;
        break;
      case z.bottomLeft:
        e2.angle = 3 * Math.PI / 4;
        break;
      case z.left:
        e2.angle = Math.PI;
        break;
      case z.topLeft:
        e2.angle = -3 * Math.PI / 4;
        break;
      case z.none:
      default:
        e2.angle = Math.random() * Math.PI * 2;
    }
    return e2;
  }
  static rotateVelocity(t2, e2) {
    return {horizontal: t2.horizontal * Math.cos(e2) - t2.vertical * Math.sin(e2), vertical: t2.horizontal * Math.sin(e2) + t2.vertical * Math.cos(e2)};
  }
  static collisionVelocity(t2, e2, i2, o2) {
    return T.create(t2.x * (i2 - o2) / (i2 + o2) + 2 * e2.x * o2 / (i2 + o2), t2.y);
  }
}
var D, O, I, F, L, V, H, _, q, B, $, W, G, N, U, j = function(t2, e2, i2, o2) {
  return new (i2 || (i2 = Promise))(function(s2, n2) {
    function a2(t3) {
      try {
        l2(o2.next(t3));
      } catch (t4) {
        n2(t4);
      }
    }
    function r2(t3) {
      try {
        l2(o2.throw(t3));
      } catch (t4) {
        n2(t4);
      }
    }
    function l2(t3) {
      var e3;
      t3.done ? s2(t3.value) : (e3 = t3.value, e3 instanceof i2 ? e3 : new i2(function(t4) {
        t4(e3);
      })).then(a2, r2);
    }
    l2((o2 = o2.apply(t2, e2 || [])).next());
  });
};
function Y(t2, e2, i2, o2, s2, n2) {
  const a2 = {bounced: false};
  return e2.min >= o2.min && e2.min <= o2.max && e2.max >= o2.min && e2.max <= o2.max && (t2.max >= i2.min && t2.max <= (i2.max + i2.min) / 2 && s2 > 0 || t2.min <= i2.max && t2.min > (i2.max + i2.min) / 2 && s2 < 0) && (a2.velocity = s2 * -n2, a2.bounced = true), a2;
}
function X(t2, e2) {
  if (e2 instanceof Array) {
    for (const i2 of e2)
      if (t2.matches(i2))
        return true;
    return false;
  }
  return t2.matches(e2);
}
class J {
  static isSsr() {
    return typeof window == "undefined" || !window;
  }
  static get animate() {
    return J.isSsr() ? (t2) => setTimeout(t2) : (t2) => (window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || window.setTimeout)(t2);
  }
  static get cancelAnimation() {
    return J.isSsr() ? (t2) => clearTimeout(t2) : (t2) => (window.cancelAnimationFrame || window.webkitCancelRequestAnimationFrame || window.mozCancelRequestAnimationFrame || window.oCancelRequestAnimationFrame || window.msCancelRequestAnimationFrame || window.clearTimeout)(t2);
  }
  static isInArray(t2, e2) {
    return t2 === e2 || e2 instanceof Array && e2.indexOf(t2) > -1;
  }
  static loadFont(t2) {
    return j(this, void 0, void 0, function* () {
      try {
        yield document.fonts.load(`${t2.weight} 36px '${t2.font}'`);
      } catch (t3) {
      }
    });
  }
  static arrayRandomIndex(t2) {
    return Math.floor(Math.random() * t2.length);
  }
  static itemFromArray(t2, e2, i2 = true) {
    return t2[e2 !== void 0 && i2 ? e2 % t2.length : J.arrayRandomIndex(t2)];
  }
  static isPointInside(t2, e2, i2, o2) {
    return J.areBoundsInside(J.calculateBounds(t2, i2 != null ? i2 : 0), e2, o2);
  }
  static areBoundsInside(t2, e2, i2) {
    let o2 = true;
    return i2 && i2 !== C.bottom || (o2 = t2.top < e2.height), !o2 || i2 && i2 !== C.left || (o2 = t2.right > 0), !o2 || i2 && i2 !== C.right || (o2 = t2.left < e2.width), !o2 || i2 && i2 !== C.top || (o2 = t2.bottom > 0), o2;
  }
  static calculateBounds(t2, e2) {
    return {bottom: t2.y + e2, left: t2.x - e2, right: t2.x + e2, top: t2.y - e2};
  }
  static loadImage(t2) {
    return new Promise((e2, i2) => {
      if (!t2)
        return void i2("Error tsParticles - No image.src");
      const o2 = {source: t2, type: t2.substr(t2.length - 3)}, s2 = new Image();
      s2.addEventListener("load", () => {
        o2.element = s2, e2(o2);
      }), s2.addEventListener("error", () => {
        i2(`Error tsParticles - loading image: ${t2}`);
      }), s2.src = t2;
    });
  }
  static downloadSvgImage(t2) {
    return j(this, void 0, void 0, function* () {
      if (!t2)
        throw new Error("Error tsParticles - No image.src");
      const e2 = {source: t2, type: t2.substr(t2.length - 3)};
      if (e2.type !== "svg")
        return J.loadImage(t2);
      const i2 = yield fetch(e2.source);
      if (!i2.ok)
        throw new Error("Error tsParticles - Image not found");
      return e2.svgData = yield i2.text(), e2;
    });
  }
  static deepExtend(t2, ...e2) {
    for (const i2 of e2) {
      if (i2 == null)
        continue;
      if (typeof i2 != "object") {
        t2 = i2;
        continue;
      }
      const e3 = Array.isArray(i2);
      !e3 || typeof t2 == "object" && t2 && Array.isArray(t2) ? e3 || typeof t2 == "object" && t2 && !Array.isArray(t2) || (t2 = {}) : t2 = [];
      for (const e4 in i2) {
        if (e4 === "__proto__")
          continue;
        const o2 = i2[e4], s2 = typeof o2 == "object", n2 = t2;
        n2[e4] = s2 && Array.isArray(o2) ? o2.map((t3) => J.deepExtend(n2[e4], t3)) : J.deepExtend(n2[e4], o2);
      }
    }
    return t2;
  }
  static isDivModeEnabled(t2, e2) {
    return e2 instanceof Array ? !!e2.find((e3) => e3.enable && J.isInArray(t2, e3.mode)) : J.isInArray(t2, e2.mode);
  }
  static divModeExecute(t2, e2, i2) {
    if (e2 instanceof Array)
      for (const o2 of e2) {
        const e3 = o2.mode;
        o2.enable && J.isInArray(t2, e3) && J.singleDivModeExecute(o2, i2);
      }
    else {
      const o2 = e2.mode;
      e2.enable && J.isInArray(t2, o2) && J.singleDivModeExecute(e2, i2);
    }
  }
  static singleDivModeExecute(t2, e2) {
    const i2 = t2.selectors;
    if (i2 instanceof Array)
      for (const o2 of i2)
        e2(o2, t2);
    else
      e2(i2, t2);
  }
  static divMode(t2, e2) {
    if (e2 && t2)
      return t2 instanceof Array ? t2.find((t3) => X(e2, t3.selectors)) : X(e2, t2.selectors) ? t2 : void 0;
  }
  static circleBounceDataFromParticle(t2) {
    return {position: t2.getPosition(), radius: t2.getRadius(), mass: t2.getMass(), velocity: t2.velocity, factor: {horizontal: E.getValue(t2.options.bounce.horizontal), vertical: E.getValue(t2.options.bounce.vertical)}};
  }
  static circleBounce(t2, e2) {
    const i2 = t2.velocity.x, o2 = t2.velocity.y, s2 = t2.position, n2 = e2.position;
    if (i2 * (n2.x - s2.x) + o2 * (n2.y - s2.y) >= 0) {
      const i3 = -Math.atan2(n2.y - s2.y, n2.x - s2.x), o3 = t2.mass, a2 = e2.mass, r2 = t2.velocity.rotate(i3), l2 = e2.velocity.rotate(i3), c2 = E.collisionVelocity(r2, l2, o3, a2), d2 = E.collisionVelocity(l2, r2, o3, a2), h2 = c2.rotate(-i3), u2 = d2.rotate(-i3);
      t2.velocity.x = h2.x * t2.factor.horizontal, t2.velocity.y = h2.y * t2.factor.vertical, e2.velocity.x = u2.x * e2.factor.horizontal, e2.velocity.y = u2.y * e2.factor.vertical;
    }
  }
  static rectBounce(t2, e2) {
    const i2 = t2.getPosition(), o2 = t2.getRadius(), s2 = J.calculateBounds(i2, o2), n2 = Y({min: s2.left, max: s2.right}, {min: s2.top, max: s2.bottom}, {min: e2.left, max: e2.right}, {min: e2.top, max: e2.bottom}, t2.velocity.x, E.getValue(t2.options.bounce.horizontal));
    n2.bounced && n2.velocity !== void 0 && (t2.velocity.x = n2.velocity);
    const a2 = Y({min: s2.top, max: s2.bottom}, {min: s2.left, max: s2.right}, {min: e2.top, max: e2.bottom}, {min: e2.left, max: e2.right}, t2.velocity.y, E.getValue(t2.options.bounce.vertical));
    a2.bounced && a2.velocity !== void 0 && (t2.velocity.y = a2.velocity);
  }
}
class Q {
}
function Z(t2, e2, i2) {
  let o2 = i2;
  return o2 < 0 && (o2 += 1), o2 > 1 && (o2 -= 1), o2 < 1 / 6 ? t2 + 6 * (e2 - t2) * o2 : o2 < 0.5 ? e2 : o2 < 2 / 3 ? t2 + (e2 - t2) * (2 / 3 - o2) * 6 : t2;
}
function K(t2) {
  if (t2.startsWith("rgb")) {
    const e2 = /rgba?\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([\d.]+)\s*)?\)/i.exec(t2);
    return e2 ? {a: e2.length > 4 ? parseFloat(e2[5]) : 1, b: parseInt(e2[3], 10), g: parseInt(e2[2], 10), r: parseInt(e2[1], 10)} : void 0;
  }
  if (t2.startsWith("hsl")) {
    const e2 = /hsla?\(\s*(\d+)\s*,\s*(\d+)%\s*,\s*(\d+)%\s*(,\s*([\d.]+)\s*)?\)/i.exec(t2);
    return e2 ? tt.hslaToRgba({a: e2.length > 4 ? parseFloat(e2[5]) : 1, h: parseInt(e2[1], 10), l: parseInt(e2[3], 10), s: parseInt(e2[2], 10)}) : void 0;
  }
  if (t2.startsWith("hsv")) {
    const e2 = /hsva?\(\s*(\d+)\s*,\s*(\d+)%\s*,\s*(\d+)%\s*(,\s*([\d.]+)\s*)?\)/i.exec(t2);
    return e2 ? tt.hsvaToRgba({a: e2.length > 4 ? parseFloat(e2[5]) : 1, h: parseInt(e2[1], 10), s: parseInt(e2[2], 10), v: parseInt(e2[3], 10)}) : void 0;
  }
  {
    const e2 = /^#?([a-f\d])([a-f\d])([a-f\d])([a-f\d])?$/i, i2 = t2.replace(e2, (t3, e3, i3, o3, s2) => e3 + e3 + i3 + i3 + o3 + o3 + (s2 !== void 0 ? s2 + s2 : "")), o2 = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})?$/i.exec(i2);
    return o2 ? {a: o2[4] !== void 0 ? parseInt(o2[4], 16) / 255 : 1, b: parseInt(o2[3], 16), g: parseInt(o2[2], 16), r: parseInt(o2[1], 16)} : void 0;
  }
}
Q.canvasClass = "tsparticles-canvas-el", Q.randomColorValue = "random", Q.midColorValue = "mid", Q.touchEndEvent = "touchend", Q.mouseDownEvent = "mousedown", Q.mouseUpEvent = "mouseup", Q.mouseMoveEvent = "mousemove", Q.touchStartEvent = "touchstart", Q.touchMoveEvent = "touchmove", Q.mouseLeaveEvent = "mouseleave", Q.mouseOutEvent = "mouseout", Q.touchCancelEvent = "touchcancel", Q.resizeEvent = "resize", Q.visibilityChangeEvent = "visibilitychange", Q.noPolygonDataLoaded = "No polygon data loaded.", Q.noPolygonFound = "No polygon found, you need to specify SVG url in config.";
class tt {
  static colorToRgb(t2, e2, i2 = true) {
    var o2, s2, n2;
    if (t2 === void 0)
      return;
    const a2 = typeof t2 == "string" ? {value: t2} : t2;
    let r2;
    if (typeof a2.value == "string")
      r2 = a2.value === Q.randomColorValue ? tt.getRandomRgbColor() : tt.stringToRgb(a2.value);
    else if (a2.value instanceof Array) {
      const t3 = J.itemFromArray(a2.value, e2, i2);
      r2 = tt.colorToRgb({value: t3});
    } else {
      const t3 = a2.value, e3 = (o2 = t3.rgb) !== null && o2 !== void 0 ? o2 : a2.value;
      if (e3.r !== void 0)
        r2 = e3;
      else {
        const e4 = (s2 = t3.hsl) !== null && s2 !== void 0 ? s2 : a2.value;
        if (e4.h !== void 0 && e4.l !== void 0)
          r2 = tt.hslToRgb(e4);
        else {
          const e5 = (n2 = t3.hsv) !== null && n2 !== void 0 ? n2 : a2.value;
          e5.h !== void 0 && e5.v !== void 0 && (r2 = tt.hsvToRgb(e5));
        }
      }
    }
    return r2;
  }
  static colorToHsl(t2, e2, i2 = true) {
    const o2 = tt.colorToRgb(t2, e2, i2);
    return o2 !== void 0 ? tt.rgbToHsl(o2) : void 0;
  }
  static rgbToHsl(t2) {
    const e2 = t2.r / 255, i2 = t2.g / 255, o2 = t2.b / 255, s2 = Math.max(e2, i2, o2), n2 = Math.min(e2, i2, o2), a2 = {h: 0, l: (s2 + n2) / 2, s: 0};
    return s2 != n2 && (a2.s = a2.l < 0.5 ? (s2 - n2) / (s2 + n2) : (s2 - n2) / (2 - s2 - n2), a2.h = e2 === s2 ? (i2 - o2) / (s2 - n2) : a2.h = i2 === s2 ? 2 + (o2 - e2) / (s2 - n2) : 4 + (e2 - i2) / (s2 - n2)), a2.l *= 100, a2.s *= 100, a2.h *= 60, a2.h < 0 && (a2.h += 360), a2;
  }
  static stringToAlpha(t2) {
    var e2;
    return (e2 = K(t2)) === null || e2 === void 0 ? void 0 : e2.a;
  }
  static stringToRgb(t2) {
    return K(t2);
  }
  static hslToRgb(t2) {
    const e2 = {b: 0, g: 0, r: 0}, i2 = {h: t2.h / 360, l: t2.l / 100, s: t2.s / 100};
    if (i2.s === 0)
      e2.b = i2.l, e2.g = i2.l, e2.r = i2.l;
    else {
      const t3 = i2.l < 0.5 ? i2.l * (1 + i2.s) : i2.l + i2.s - i2.l * i2.s, o2 = 2 * i2.l - t3;
      e2.r = Z(o2, t3, i2.h + 1 / 3), e2.g = Z(o2, t3, i2.h), e2.b = Z(o2, t3, i2.h - 1 / 3);
    }
    return e2.r = Math.floor(255 * e2.r), e2.g = Math.floor(255 * e2.g), e2.b = Math.floor(255 * e2.b), e2;
  }
  static hslaToRgba(t2) {
    const e2 = tt.hslToRgb(t2);
    return {a: t2.a, b: e2.b, g: e2.g, r: e2.r};
  }
  static hslToHsv(t2) {
    const e2 = t2.l / 100, i2 = e2 + t2.s / 100 * Math.min(e2, 1 - e2), o2 = i2 ? 2 * (1 - e2 / i2) : 0;
    return {h: t2.h, s: 100 * o2, v: 100 * i2};
  }
  static hslaToHsva(t2) {
    const e2 = tt.hslToHsv(t2);
    return {a: t2.a, h: e2.h, s: e2.s, v: e2.v};
  }
  static hsvToHsl(t2) {
    const e2 = t2.v / 100, i2 = e2 * (1 - t2.s / 100 / 2), o2 = i2 === 0 || i2 === 1 ? 0 : (e2 - i2) / Math.min(i2, 1 - i2);
    return {h: t2.h, l: 100 * i2, s: 100 * o2};
  }
  static hsvaToHsla(t2) {
    const e2 = tt.hsvToHsl(t2);
    return {a: t2.a, h: e2.h, l: e2.l, s: e2.s};
  }
  static hsvToRgb(t2) {
    const e2 = {b: 0, g: 0, r: 0}, i2 = t2.h / 60, o2 = t2.s / 100, s2 = t2.v / 100, n2 = s2 * o2, a2 = n2 * (1 - Math.abs(i2 % 2 - 1));
    let r2;
    if (i2 >= 0 && i2 <= 1 ? r2 = {r: n2, g: a2, b: 0} : i2 > 1 && i2 <= 2 ? r2 = {r: a2, g: n2, b: 0} : i2 > 2 && i2 <= 3 ? r2 = {r: 0, g: n2, b: a2} : i2 > 3 && i2 <= 4 ? r2 = {r: 0, g: a2, b: n2} : i2 > 4 && i2 <= 5 ? r2 = {r: a2, g: 0, b: n2} : i2 > 5 && i2 <= 6 && (r2 = {r: n2, g: 0, b: a2}), r2) {
      const t3 = s2 - n2;
      e2.r = Math.floor(255 * (r2.r + t3)), e2.g = Math.floor(255 * (r2.g + t3)), e2.b = Math.floor(255 * (r2.b + t3));
    }
    return e2;
  }
  static hsvaToRgba(t2) {
    const e2 = tt.hsvToRgb(t2);
    return {a: t2.a, b: e2.b, g: e2.g, r: e2.r};
  }
  static rgbToHsv(t2) {
    const e2 = {r: t2.r / 255, g: t2.g / 255, b: t2.b / 255}, i2 = Math.max(e2.r, e2.g, e2.b), o2 = i2 - Math.min(e2.r, e2.g, e2.b);
    let s2 = 0;
    i2 === e2.r ? s2 = (e2.g - e2.b) / o2 * 60 : i2 === e2.g ? s2 = 60 * (2 + (e2.b - e2.r) / o2) : i2 === e2.b && (s2 = 60 * (4 + (e2.r - e2.g) / o2));
    return {h: s2, s: 100 * (i2 ? o2 / i2 : 0), v: 100 * i2};
  }
  static rgbaToHsva(t2) {
    const e2 = tt.rgbToHsv(t2);
    return {a: t2.a, h: e2.h, s: e2.s, v: e2.v};
  }
  static getRandomRgbColor(t2) {
    const e2 = t2 != null ? t2 : 0;
    return {b: Math.floor(E.randomInRange(E.setRangeValue(e2, 256))), g: Math.floor(E.randomInRange(E.setRangeValue(e2, 256))), r: Math.floor(E.randomInRange(E.setRangeValue(e2, 256)))};
  }
  static getStyleFromRgb(t2, e2) {
    return `rgba(${t2.r}, ${t2.g}, ${t2.b}, ${e2 != null ? e2 : 1})`;
  }
  static getStyleFromHsl(t2, e2) {
    return `hsla(${t2.h}, ${t2.s}%, ${t2.l}%, ${e2 != null ? e2 : 1})`;
  }
  static getStyleFromHsv(t2, e2) {
    return tt.getStyleFromHsl(tt.hsvToHsl(t2), e2);
  }
  static mix(t2, e2, i2, o2) {
    let s2 = t2, n2 = e2;
    return s2.r === void 0 && (s2 = tt.hslToRgb(t2)), n2.r === void 0 && (n2 = tt.hslToRgb(e2)), {b: E.mix(s2.b, n2.b, i2, o2), g: E.mix(s2.g, n2.g, i2, o2), r: E.mix(s2.r, n2.r, i2, o2)};
  }
  static replaceColorSvg(t2, e2, i2) {
    if (!t2.svgData)
      return "";
    return t2.svgData.replace(/#([0-9A-F]{3,6})/gi, () => tt.getStyleFromHsl(e2, i2));
  }
  static getLinkColor(t2, e2, i2) {
    var o2, s2;
    if (i2 === Q.randomColorValue)
      return tt.getRandomRgbColor();
    if (i2 !== "mid")
      return i2;
    {
      const i3 = (o2 = t2.getFillColor()) !== null && o2 !== void 0 ? o2 : t2.getStrokeColor(), n2 = (s2 = e2 == null ? void 0 : e2.getFillColor()) !== null && s2 !== void 0 ? s2 : e2 == null ? void 0 : e2.getStrokeColor();
      if (i3 && n2 && e2)
        return tt.mix(i3, n2, t2.getRadius(), e2.getRadius());
      {
        const t3 = i3 != null ? i3 : n2;
        if (t3)
          return tt.hslToRgb(t3);
      }
    }
  }
  static getLinkRandomColor(t2, e2, i2) {
    const o2 = typeof t2 == "string" ? t2 : t2.value;
    return o2 === Q.randomColorValue ? i2 ? tt.colorToRgb({value: o2}) : e2 ? Q.randomColorValue : Q.midColorValue : tt.colorToRgb({value: o2});
  }
  static getHslFromAnimation(t2) {
    return t2 !== void 0 ? {h: t2.h.value, s: t2.s.value, l: t2.l.value} : void 0;
  }
}
function et(t2, e2, i2) {
  t2.beginPath(), t2.moveTo(e2.x, e2.y), t2.lineTo(i2.x, i2.y), t2.closePath();
}
class it {
  static paintBase(t2, e2, i2) {
    t2.save(), t2.fillStyle = i2 != null ? i2 : "rgba(0,0,0,0)", t2.fillRect(0, 0, e2.width, e2.height), t2.restore();
  }
  static clear(t2, e2) {
    t2.clearRect(0, 0, e2.width, e2.height);
  }
  static drawLinkLine(t2, e2, i2, o2, s2, n2, a2, r2, l2, c2, d2, h2) {
    let u2 = false;
    if (E.getDistance(i2, o2) <= s2)
      et(t2, i2, o2), u2 = true;
    else if (a2) {
      let e3, a3;
      const r3 = {x: o2.x - n2.width, y: o2.y}, l3 = E.getDistances(i2, r3);
      if (l3.distance <= s2) {
        const t3 = i2.y - l3.dy / l3.dx * i2.x;
        e3 = {x: 0, y: t3}, a3 = {x: n2.width, y: t3};
      } else {
        const t3 = {x: o2.x, y: o2.y - n2.height}, r4 = E.getDistances(i2, t3);
        if (r4.distance <= s2) {
          const t4 = -(i2.y - r4.dy / r4.dx * i2.x) / (r4.dy / r4.dx);
          e3 = {x: t4, y: 0}, a3 = {x: t4, y: n2.height};
        } else {
          const t4 = {x: o2.x - n2.width, y: o2.y - n2.height}, r5 = E.getDistances(i2, t4);
          if (r5.distance <= s2) {
            const t5 = i2.y - r5.dy / r5.dx * i2.x;
            e3 = {x: -t5 / (r5.dy / r5.dx), y: t5}, a3 = {x: e3.x + n2.width, y: e3.y + n2.height};
          }
        }
      }
      e3 && a3 && (et(t2, i2, e3), et(t2, o2, a3), u2 = true);
    }
    if (u2) {
      if (t2.lineWidth = e2, r2 && (t2.globalCompositeOperation = l2), t2.strokeStyle = tt.getStyleFromRgb(c2, d2), h2.enable) {
        const e3 = tt.colorToRgb(h2.color);
        e3 && (t2.shadowBlur = h2.blur, t2.shadowColor = tt.getStyleFromRgb(e3));
      }
      t2.stroke();
    }
  }
  static drawLinkTriangle(t2, e2, i2, o2, s2, n2, a2, r2) {
    !function(t3, e3, i3, o3) {
      t3.beginPath(), t3.moveTo(e3.x, e3.y), t3.lineTo(i3.x, i3.y), t3.lineTo(o3.x, o3.y), t3.closePath();
    }(t2, e2, i2, o2), s2 && (t2.globalCompositeOperation = n2), t2.fillStyle = tt.getStyleFromRgb(a2, r2), t2.fill();
  }
  static drawConnectLine(t2, e2, i2, o2, s2) {
    t2.save(), et(t2, o2, s2), t2.lineWidth = e2, t2.strokeStyle = i2, t2.stroke(), t2.restore();
  }
  static gradient(t2, e2, i2, o2) {
    const s2 = Math.floor(i2.getRadius() / e2.getRadius()), n2 = e2.getFillColor(), a2 = i2.getFillColor();
    if (!n2 || !a2)
      return;
    const r2 = e2.getPosition(), l2 = i2.getPosition(), c2 = tt.mix(n2, a2, e2.getRadius(), i2.getRadius()), d2 = t2.createLinearGradient(r2.x, r2.y, l2.x, l2.y);
    return d2.addColorStop(0, tt.getStyleFromHsl(n2, o2)), d2.addColorStop(s2 > 1 ? 1 : s2, tt.getStyleFromRgb(c2, o2)), d2.addColorStop(1, tt.getStyleFromHsl(a2, o2)), d2;
  }
  static drawGrabLine(t2, e2, i2, o2, s2, n2) {
    t2.save(), et(t2, i2, o2), t2.strokeStyle = tt.getStyleFromRgb(s2, n2), t2.lineWidth = e2, t2.stroke(), t2.restore();
  }
  static drawLight(t2, e2, i2) {
    const o2 = t2.actualOptions.interactivity.modes.light.area;
    e2.beginPath(), e2.arc(i2.x, i2.y, o2.radius, 0, 2 * Math.PI);
    const s2 = e2.createRadialGradient(i2.x, i2.y, 0, i2.x, i2.y, o2.radius), n2 = o2.gradient, a2 = {start: tt.colorToRgb(n2.start), stop: tt.colorToRgb(n2.stop)};
    a2.start && a2.stop && (s2.addColorStop(0, tt.getStyleFromRgb(a2.start)), s2.addColorStop(1, tt.getStyleFromRgb(a2.stop)), e2.fillStyle = s2, e2.fill());
  }
  static drawParticleShadow(t2, e2, i2, o2) {
    const s2 = i2.getPosition(), n2 = t2.actualOptions.interactivity.modes.light.shadow;
    e2.save();
    const a2 = i2.getRadius(), r2 = i2.sides, l2 = 2 * Math.PI / r2, c2 = -i2.rotate.value + Math.PI / 4, d2 = [];
    for (let t3 = 0; t3 < r2; t3++)
      d2.push({x: s2.x + a2 * Math.sin(c2 + l2 * t3) * 1, y: s2.y + a2 * Math.cos(c2 + l2 * t3) * 1});
    const h2 = [], u2 = n2.length;
    for (const t3 of d2) {
      const e3 = Math.atan2(o2.y - t3.y, o2.x - t3.x), i3 = t3.x + u2 * Math.sin(-e3 - Math.PI / 2), s3 = t3.y + u2 * Math.cos(-e3 - Math.PI / 2);
      h2.push({endX: i3, endY: s3, startX: t3.x, startY: t3.y});
    }
    const v2 = tt.colorToRgb(n2.color);
    if (!v2)
      return;
    const p2 = tt.getStyleFromRgb(v2);
    for (let t3 = h2.length - 1; t3 >= 0; t3--) {
      const i3 = t3 == h2.length - 1 ? 0 : t3 + 1;
      e2.beginPath(), e2.moveTo(h2[t3].startX, h2[t3].startY), e2.lineTo(h2[i3].startX, h2[i3].startY), e2.lineTo(h2[i3].endX, h2[i3].endY), e2.lineTo(h2[t3].endX, h2[t3].endY), e2.fillStyle = p2, e2.fill();
    }
    e2.restore();
  }
  static drawParticle(t2, e2, i2, o2, s2, n2, a2, r2, l2, c2, d2) {
    const h2 = i2.getPosition();
    e2.save(), e2.translate(h2.x, h2.y), e2.beginPath();
    const u2 = i2.rotate.value + (i2.options.rotate.path ? i2.velocity.angle : 0);
    u2 !== 0 && e2.rotate(u2), a2 && (e2.globalCompositeOperation = r2);
    const v2 = i2.shadowColor;
    d2.enable && v2 && (e2.shadowBlur = d2.blur, e2.shadowColor = tt.getStyleFromRgb(v2), e2.shadowOffsetX = d2.offset.x, e2.shadowOffsetY = d2.offset.y), s2 && (e2.fillStyle = s2);
    const p2 = i2.stroke;
    e2.lineWidth = i2.strokeWidth, n2 && (e2.strokeStyle = n2), it.drawShape(t2, e2, i2, l2, c2, o2), p2.width > 0 && e2.stroke(), i2.close && e2.closePath(), i2.fill && e2.fill(), e2.restore(), e2.save(), e2.translate(h2.x, h2.y), u2 !== 0 && e2.rotate(u2), a2 && (e2.globalCompositeOperation = r2), it.drawShapeAfterEffect(t2, e2, i2, l2, c2, o2), e2.restore();
  }
  static drawShape(t2, e2, i2, o2, s2, n2) {
    if (!i2.shape)
      return;
    const a2 = t2.drawers.get(i2.shape);
    a2 && a2.draw(e2, i2, o2, s2, n2, t2.retina.pixelRatio);
  }
  static drawShapeAfterEffect(t2, e2, i2, o2, s2, n2) {
    if (!i2.shape)
      return;
    const a2 = t2.drawers.get(i2.shape);
    (a2 == null ? void 0 : a2.afterEffect) && a2.afterEffect(e2, i2, o2, s2, n2, t2.retina.pixelRatio);
  }
  static drawPlugin(t2, e2, i2) {
    e2.draw !== void 0 && (t2.save(), e2.draw(t2, i2), t2.restore());
  }
}
class ot {
  constructor(t2, e2) {
    this.position = {x: t2, y: e2};
  }
}
class st extends ot {
  constructor(t2, e2, i2) {
    super(t2, e2), this.radius = i2;
  }
  contains(t2) {
    return Math.pow(t2.x - this.position.x, 2) + Math.pow(t2.y - this.position.y, 2) <= this.radius * this.radius;
  }
  intersects(t2) {
    const e2 = t2, i2 = t2, o2 = this.position, s2 = t2.position, n2 = Math.abs(s2.x - o2.x), a2 = Math.abs(s2.y - o2.y), r2 = this.radius;
    if (i2.radius !== void 0) {
      return r2 + i2.radius > Math.sqrt(n2 * n2 + a2 + a2);
    }
    if (e2.size !== void 0) {
      const t3 = e2.size.width, i3 = e2.size.height, o3 = Math.pow(n2 - t3, 2) + Math.pow(a2 - i3, 2);
      return !(n2 > r2 + t3 || a2 > r2 + i3) && (n2 <= t3 || a2 <= i3 || o3 <= r2 * r2);
    }
    return false;
  }
}
class nt extends ot {
  constructor(t2, e2, i2, o2) {
    super(t2, e2), this.size = {height: o2, width: i2};
  }
  contains(t2) {
    const e2 = this.size.width, i2 = this.size.height, o2 = this.position;
    return t2.x >= o2.x && t2.x <= o2.x + e2 && t2.y >= o2.y && t2.y <= o2.y + i2;
  }
  intersects(t2) {
    const e2 = t2, i2 = t2, o2 = this.size.width, s2 = this.size.height, n2 = this.position, a2 = t2.position;
    if (i2.radius !== void 0)
      return i2.intersects(this);
    if (e2.size !== void 0) {
      const t3 = e2.size, i3 = t3.width, r2 = t3.height;
      return a2.x < n2.x + o2 && a2.x + i3 > n2.x && a2.y < n2.y + s2 && a2.y + r2 > n2.y;
    }
    return false;
  }
}
class at extends st {
  constructor(t2, e2, i2, o2) {
    super(t2, e2, i2), this.canvasSize = o2, this.canvasSize = {height: o2.height, width: o2.width};
  }
  contains(t2) {
    if (super.contains(t2))
      return true;
    const e2 = {x: t2.x - this.canvasSize.width, y: t2.y};
    if (super.contains(e2))
      return true;
    const i2 = {x: t2.x - this.canvasSize.width, y: t2.y - this.canvasSize.height};
    if (super.contains(i2))
      return true;
    const o2 = {x: t2.x, y: t2.y - this.canvasSize.height};
    return super.contains(o2);
  }
  intersects(t2) {
    if (super.intersects(t2))
      return true;
    const e2 = t2, i2 = t2, o2 = {x: t2.position.x - this.canvasSize.width, y: t2.position.y - this.canvasSize.height};
    if (i2.radius !== void 0) {
      const t3 = new st(o2.x, o2.y, 2 * i2.radius);
      return super.intersects(t3);
    }
    if (e2.size !== void 0) {
      const t3 = new nt(o2.x, o2.y, 2 * e2.size.width, 2 * e2.size.height);
      return super.intersects(t3);
    }
    return false;
  }
}
function rt(t2, e2, i2, o2, s2) {
  if (o2) {
    let o3 = {passive: true};
    typeof s2 == "boolean" ? o3.capture = s2 : s2 !== void 0 && (o3 = s2), t2.addEventListener(e2, i2, o3);
  } else {
    const o3 = s2;
    t2.removeEventListener(e2, i2, o3);
  }
}
!function(t2) {
  t2.attract = "attract", t2.bubble = "bubble", t2.push = "push", t2.remove = "remove", t2.repulse = "repulse", t2.pause = "pause", t2.trail = "trail";
}(D || (D = {})), function(t2) {
  t2.none = "none", t2.split = "split";
}(O || (O = {})), function(t2) {
  t2.bounce = "bounce", t2.bubble = "bubble", t2.repulse = "repulse";
}(I || (I = {})), function(t2) {
  t2.attract = "attract", t2.bounce = "bounce", t2.bubble = "bubble", t2.connect = "connect", t2.grab = "grab", t2.light = "light", t2.repulse = "repulse", t2.slow = "slow", t2.trail = "trail";
}(F || (F = {})), function(t2) {
  t2.absorb = "absorb", t2.bounce = "bounce", t2.destroy = "destroy";
}(L || (L = {})), function(t2) {
  t2.bounce = "bounce", t2.bounceHorizontal = "bounce-horizontal", t2.bounceVertical = "bounce-vertical", t2.none = "none", t2.out = "out", t2.destroy = "destroy", t2.split = "split";
}(V || (V = {})), function(t2) {
  t2.precise = "precise", t2.percent = "percent";
}(H || (H = {})), function(t2) {
  t2.any = "any", t2.dark = "dark", t2.light = "light";
}(_ || (_ = {})), function(t2) {
  t2[t2.increasing = 0] = "increasing", t2[t2.decreasing = 1] = "decreasing";
}(q || (q = {})), function(t2) {
  t2.none = "none", t2.max = "max", t2.min = "min";
}(B || (B = {})), function(t2) {
  t2.color = "color", t2.opacity = "opacity", t2.size = "size";
}($ || ($ = {})), function(t2) {
  t2.char = "char", t2.character = "character", t2.circle = "circle", t2.edge = "edge", t2.image = "image", t2.images = "images", t2.line = "line", t2.polygon = "polygon", t2.square = "square", t2.star = "star", t2.triangle = "triangle";
}(W || (W = {})), function(t2) {
  t2.max = "max", t2.min = "min", t2.random = "random";
}(G || (G = {})), function(t2) {
  t2.circle = "circle", t2.rectangle = "rectangle";
}(N || (N = {})), function(t2) {
  t2.canvas = "canvas", t2.parent = "parent", t2.window = "window";
}(U || (U = {}));
class lt {
  constructor(t2) {
    this.container = t2, this.canPush = true, this.mouseMoveHandler = (t3) => this.mouseTouchMove(t3), this.touchStartHandler = (t3) => this.mouseTouchMove(t3), this.touchMoveHandler = (t3) => this.mouseTouchMove(t3), this.touchEndHandler = () => this.mouseTouchFinish(), this.mouseLeaveHandler = () => this.mouseTouchFinish(), this.touchCancelHandler = () => this.mouseTouchFinish(), this.touchEndClickHandler = (t3) => this.mouseTouchClick(t3), this.mouseUpHandler = (t3) => this.mouseTouchClick(t3), this.mouseDownHandler = () => this.mouseDown(), this.visibilityChangeHandler = () => this.handleVisibilityChange(), this.resizeHandler = () => this.handleWindowResize();
  }
  addListeners() {
    this.manageListeners(true);
  }
  removeListeners() {
    this.manageListeners(false);
  }
  manageListeners(t2) {
    var e2;
    const i2 = this.container, o2 = i2.actualOptions, s2 = o2.interactivity.detectsOn;
    let n2 = Q.mouseLeaveEvent;
    if (s2 === U.window)
      i2.interactivity.element = window, n2 = Q.mouseOutEvent;
    else if (s2 === U.parent && i2.canvas.element) {
      const t3 = i2.canvas.element;
      i2.interactivity.element = (e2 = t3.parentElement) !== null && e2 !== void 0 ? e2 : t3.parentNode;
    } else
      i2.interactivity.element = i2.canvas.element;
    const a2 = i2.interactivity.element;
    if (!a2)
      return;
    const r2 = a2;
    (o2.interactivity.events.onHover.enable || o2.interactivity.events.onClick.enable) && (rt(a2, Q.mouseMoveEvent, this.mouseMoveHandler, t2), rt(a2, Q.touchStartEvent, this.touchStartHandler, t2), rt(a2, Q.touchMoveEvent, this.touchMoveHandler, t2), o2.interactivity.events.onClick.enable ? (rt(a2, Q.touchEndEvent, this.touchEndClickHandler, t2), rt(a2, Q.mouseUpEvent, this.mouseUpHandler, t2), rt(a2, Q.mouseDownEvent, this.mouseDownHandler, t2)) : rt(a2, Q.touchEndEvent, this.touchEndHandler, t2), rt(a2, n2, this.mouseLeaveHandler, t2), rt(a2, Q.touchCancelEvent, this.touchCancelHandler, t2)), i2.canvas.element && (i2.canvas.element.style.pointerEvents = r2 === i2.canvas.element ? "initial" : "none"), o2.interactivity.events.resize && rt(window, Q.resizeEvent, this.resizeHandler, t2), document && rt(document, Q.visibilityChangeEvent, this.visibilityChangeHandler, t2, false);
  }
  handleWindowResize() {
    var t2;
    (t2 = this.container.canvas) === null || t2 === void 0 || t2.windowResize();
  }
  handleVisibilityChange() {
    const t2 = this.container, e2 = t2.actualOptions;
    this.mouseTouchFinish(), e2.pauseOnBlur && ((document === null || document === void 0 ? void 0 : document.hidden) ? (t2.pageHidden = true, t2.pause()) : (t2.pageHidden = false, t2.getAnimationStatus() ? t2.play(true) : t2.draw()));
  }
  mouseDown() {
    const t2 = this.container.interactivity;
    if (t2) {
      const e2 = t2.mouse;
      e2.clicking = true, e2.downPosition = e2.position;
    }
  }
  mouseTouchMove(t2) {
    var e2, i2, o2, s2, n2, a2, r2;
    const l2 = this.container, c2 = l2.actualOptions;
    if (((e2 = l2.interactivity) === null || e2 === void 0 ? void 0 : e2.element) === void 0)
      return;
    let d2;
    l2.interactivity.mouse.inside = true;
    const h2 = l2.canvas.element;
    if (t2.type.startsWith("mouse")) {
      this.canPush = true;
      const e3 = t2;
      if (l2.interactivity.element === window) {
        if (h2) {
          const t3 = h2.getBoundingClientRect();
          d2 = {x: e3.clientX - t3.left, y: e3.clientY - t3.top};
        }
      } else if (c2.interactivity.detectsOn === U.parent) {
        const t3 = e3.target, s3 = e3.currentTarget, n3 = l2.canvas.element;
        if (t3 && s3 && n3) {
          const i3 = t3.getBoundingClientRect(), o3 = s3.getBoundingClientRect(), a3 = n3.getBoundingClientRect();
          d2 = {x: e3.offsetX + 2 * i3.left - (o3.left + a3.left), y: e3.offsetY + 2 * i3.top - (o3.top + a3.top)};
        } else
          d2 = {x: (i2 = e3.offsetX) !== null && i2 !== void 0 ? i2 : e3.clientX, y: (o2 = e3.offsetY) !== null && o2 !== void 0 ? o2 : e3.clientY};
      } else
        e3.target === l2.canvas.element && (d2 = {x: (s2 = e3.offsetX) !== null && s2 !== void 0 ? s2 : e3.clientX, y: (n2 = e3.offsetY) !== null && n2 !== void 0 ? n2 : e3.clientY});
    } else {
      this.canPush = t2.type !== "touchmove";
      const e3 = t2, i3 = e3.touches[e3.touches.length - 1], o3 = h2 == null ? void 0 : h2.getBoundingClientRect();
      d2 = {x: i3.clientX - ((a2 = o3 == null ? void 0 : o3.left) !== null && a2 !== void 0 ? a2 : 0), y: i3.clientY - ((r2 = o3 == null ? void 0 : o3.top) !== null && r2 !== void 0 ? r2 : 0)};
    }
    const u2 = l2.retina.pixelRatio;
    d2 && (d2.x *= u2, d2.y *= u2), l2.interactivity.mouse.position = d2, l2.interactivity.status = Q.mouseMoveEvent;
  }
  mouseTouchFinish() {
    const t2 = this.container.interactivity;
    if (t2 === void 0)
      return;
    const e2 = t2.mouse;
    delete e2.position, delete e2.clickPosition, delete e2.downPosition, t2.status = Q.mouseLeaveEvent, e2.inside = false, e2.clicking = false;
  }
  mouseTouchClick(t2) {
    const e2 = this.container, i2 = e2.actualOptions, o2 = e2.interactivity.mouse;
    o2.inside = true;
    let s2 = false;
    const n2 = o2.position;
    if (n2 !== void 0 && i2.interactivity.events.onClick.enable) {
      for (const [, t3] of e2.plugins)
        if (t3.clickPositionValid !== void 0 && (s2 = t3.clickPositionValid(n2), s2))
          break;
      s2 || this.doMouseTouchClick(t2), o2.clicking = false;
    }
  }
  doMouseTouchClick(t2) {
    const e2 = this.container, i2 = e2.actualOptions;
    if (this.canPush) {
      const t3 = e2.interactivity.mouse.position;
      if (!t3)
        return;
      e2.interactivity.mouse.clickPosition = {x: t3.x, y: t3.y}, e2.interactivity.mouse.clickTime = new Date().getTime();
      const o2 = i2.interactivity.events.onClick;
      if (o2.mode instanceof Array)
        for (const t4 of o2.mode)
          this.handleClickMode(t4);
      else
        this.handleClickMode(o2.mode);
    }
    t2.type === "touchend" && setTimeout(() => this.mouseTouchFinish(), 500);
  }
  handleClickMode(t2) {
    const e2 = this.container, i2 = e2.actualOptions, o2 = i2.interactivity.modes.push.quantity, s2 = i2.interactivity.modes.remove.quantity;
    switch (t2) {
      case D.push:
        o2 > 0 && e2.particles.push(o2, e2.interactivity.mouse);
        break;
      case D.remove:
        e2.particles.removeQuantity(s2);
        break;
      case D.bubble:
        e2.bubble.clicking = true;
        break;
      case D.repulse:
        e2.repulse.clicking = true, e2.repulse.count = 0;
        for (const t3 of e2.repulse.particles)
          t3.velocity.setTo(t3.initialVelocity);
        e2.repulse.particles = [], e2.repulse.finish = false, setTimeout(() => {
          e2.destroyed || (e2.repulse.clicking = false);
        }, 1e3 * i2.interactivity.modes.repulse.duration);
        break;
      case D.attract:
        e2.attract.clicking = true, e2.attract.count = 0;
        for (const t3 of e2.attract.particles)
          t3.velocity.setTo(t3.initialVelocity);
        e2.attract.particles = [], e2.attract.finish = false, setTimeout(() => {
          e2.destroyed || (e2.attract.clicking = false);
        }, 1e3 * i2.interactivity.modes.attract.duration);
        break;
      case D.pause:
        e2.getAnimationStatus() ? e2.pause() : e2.play();
    }
    for (const [, i3] of e2.plugins)
      i3.handleClickMode && i3.handleClickMode(t2);
  }
}
const ct = [], dt = new Map(), ht = new Map(), ut = new Map();
class vt {
  static getPlugin(t2) {
    return ct.find((e2) => e2.id === t2);
  }
  static addPlugin(t2) {
    vt.getPlugin(t2.id) || ct.push(t2);
  }
  static getAvailablePlugins(t2) {
    const e2 = new Map();
    for (const i2 of ct)
      i2.needsPlugin(t2.actualOptions) && e2.set(i2.id, i2.getPlugin(t2));
    return e2;
  }
  static loadOptions(t2, e2) {
    for (const i2 of ct)
      i2.loadOptions(t2, e2);
  }
  static getPreset(t2) {
    return dt.get(t2);
  }
  static addPreset(t2, e2) {
    vt.getPreset(t2) || dt.set(t2, e2);
  }
  static addShapeDrawer(t2, e2) {
    vt.getShapeDrawer(t2) || ht.set(t2, e2);
  }
  static getShapeDrawer(t2) {
    return ht.get(t2);
  }
  static getSupportedShapes() {
    return ht.keys();
  }
  static getPathGenerator(t2) {
    return ut.get(t2);
  }
  static addPathGenerator(t2, e2) {
    vt.getPathGenerator(t2) || ut.set(t2, e2);
  }
}
class pt {
  constructor(t2, e2) {
    this.position = t2, this.particle = e2;
  }
}
class yt {
  constructor(t2, e2) {
    this.rectangle = t2, this.capacity = e2, this.points = [], this.divided = false;
  }
  subdivide() {
    const t2 = this.rectangle.position.x, e2 = this.rectangle.position.y, i2 = this.rectangle.size.width, o2 = this.rectangle.size.height, s2 = this.capacity;
    this.northEast = new yt(new nt(t2, e2, i2 / 2, o2 / 2), s2), this.northWest = new yt(new nt(t2 + i2 / 2, e2, i2 / 2, o2 / 2), s2), this.southEast = new yt(new nt(t2, e2 + o2 / 2, i2 / 2, o2 / 2), s2), this.southWest = new yt(new nt(t2 + i2 / 2, e2 + o2 / 2, i2 / 2, o2 / 2), s2), this.divided = true;
  }
  insert(t2) {
    var e2, i2, o2, s2, n2;
    return !!this.rectangle.contains(t2.position) && (this.points.length < this.capacity ? (this.points.push(t2), true) : (this.divided || this.subdivide(), (n2 = ((e2 = this.northEast) === null || e2 === void 0 ? void 0 : e2.insert(t2)) || ((i2 = this.northWest) === null || i2 === void 0 ? void 0 : i2.insert(t2)) || ((o2 = this.southEast) === null || o2 === void 0 ? void 0 : o2.insert(t2)) || ((s2 = this.southWest) === null || s2 === void 0 ? void 0 : s2.insert(t2))) !== null && n2 !== void 0 && n2));
  }
  queryCircle(t2, e2) {
    return this.query(new st(t2.x, t2.y, e2));
  }
  queryCircleWarp(t2, e2, i2) {
    const o2 = i2, s2 = i2;
    return this.query(new at(t2.x, t2.y, e2, o2.canvas !== void 0 ? o2.canvas.size : s2));
  }
  queryRectangle(t2, e2) {
    return this.query(new nt(t2.x, t2.y, e2.width, e2.height));
  }
  query(t2, e2) {
    var i2, o2, s2, n2;
    const a2 = e2 != null ? e2 : [];
    if (!t2.intersects(this.rectangle))
      return [];
    for (const e3 of this.points)
      t2.contains(e3.position) && a2.push(e3.particle);
    return this.divided && ((i2 = this.northEast) === null || i2 === void 0 || i2.query(t2, a2), (o2 = this.northWest) === null || o2 === void 0 || o2.query(t2, a2), (s2 = this.southEast) === null || s2 === void 0 || s2.query(t2, a2), (n2 = this.southWest) === null || n2 === void 0 || n2.query(t2, a2)), a2;
  }
}
var ft = function(t2, e2, i2, o2) {
  return new (i2 || (i2 = Promise))(function(s2, n2) {
    function a2(t3) {
      try {
        l2(o2.next(t3));
      } catch (t4) {
        n2(t4);
      }
    }
    function r2(t3) {
      try {
        l2(o2.throw(t3));
      } catch (t4) {
        n2(t4);
      }
    }
    function l2(t3) {
      var e3;
      t3.done ? s2(t3.value) : (e3 = t3.value, e3 instanceof i2 ? e3 : new i2(function(t4) {
        t4(e3);
      })).then(a2, r2);
    }
    l2((o2 = o2.apply(t2, e2 || [])).next());
  });
};
class mt {
  getSidesCount() {
    return 12;
  }
  init(t2) {
    var e2;
    return ft(this, void 0, void 0, function* () {
      const i2 = t2.actualOptions;
      if (J.isInArray(W.char, i2.particles.shape.type) || J.isInArray(W.character, i2.particles.shape.type)) {
        const t3 = (e2 = i2.particles.shape.options[W.character]) !== null && e2 !== void 0 ? e2 : i2.particles.shape.options[W.char];
        if (t3 instanceof Array)
          for (const e3 of t3)
            yield J.loadFont(e3);
        else
          t3 !== void 0 && (yield J.loadFont(t3));
      }
    });
  }
  draw(t2, e2, i2) {
    const o2 = e2.shapeData;
    if (o2 === void 0)
      return;
    const s2 = o2.value;
    if (s2 === void 0)
      return;
    const n2 = e2;
    n2.text === void 0 && (n2.text = s2 instanceof Array ? J.itemFromArray(s2, e2.randomIndexData) : s2);
    const a2 = n2.text, r2 = o2.style, l2 = o2.weight, c2 = 2 * Math.round(i2), d2 = o2.font, h2 = e2.fill, u2 = a2.length * i2 / 2;
    t2.font = `${r2} ${l2} ${c2}px "${d2}"`;
    const v2 = {x: -u2, y: i2 / 2};
    h2 ? t2.fillText(a2, v2.x, v2.y) : t2.strokeText(a2, v2.x, v2.y);
  }
}
var gt = function(t2, e2, i2, o2) {
  return new (i2 || (i2 = Promise))(function(s2, n2) {
    function a2(t3) {
      try {
        l2(o2.next(t3));
      } catch (t4) {
        n2(t4);
      }
    }
    function r2(t3) {
      try {
        l2(o2.throw(t3));
      } catch (t4) {
        n2(t4);
      }
    }
    function l2(t3) {
      var e3;
      t3.done ? s2(t3.value) : (e3 = t3.value, e3 instanceof i2 ? e3 : new i2(function(t4) {
        t4(e3);
      })).then(a2, r2);
    }
    l2((o2 = o2.apply(t2, e2 || [])).next());
  });
};
class bt {
  constructor() {
    this.images = [];
  }
  getSidesCount() {
    return 12;
  }
  getImages(t2) {
    const e2 = this.images.filter((e3) => e3.id === t2.id);
    return e2.length ? e2[0] : (this.images.push({id: t2.id, images: []}), this.getImages(t2));
  }
  addImage(t2, e2) {
    const i2 = this.getImages(t2);
    i2 == null || i2.images.push(e2);
  }
  init(t2) {
    var e2;
    return gt(this, void 0, void 0, function* () {
      const i2 = t2.actualOptions.particles.shape;
      if (!J.isInArray(W.image, i2.type) && !J.isInArray(W.images, i2.type))
        return;
      const o2 = (e2 = i2.options[W.images]) !== null && e2 !== void 0 ? e2 : i2.options[W.image];
      if (o2 instanceof Array)
        for (const e3 of o2)
          yield this.loadImageShape(t2, e3);
      else
        yield this.loadImageShape(t2, o2);
    });
  }
  destroy() {
    this.images = [];
  }
  loadImageShape(t2, e2) {
    return gt(this, void 0, void 0, function* () {
      try {
        const i2 = e2.replaceColor ? yield J.downloadSvgImage(e2.src) : yield J.loadImage(e2.src);
        i2 && this.addImage(t2, i2);
      } catch (t3) {
        console.warn(`tsParticles error - ${e2.src} not found`);
      }
    });
  }
  draw(t2, e2, i2, o2) {
    var s2, n2;
    if (!t2)
      return;
    const a2 = e2.image, r2 = (s2 = a2 == null ? void 0 : a2.data) === null || s2 === void 0 ? void 0 : s2.element;
    if (!r2)
      return;
    const l2 = (n2 = a2 == null ? void 0 : a2.ratio) !== null && n2 !== void 0 ? n2 : 1, c2 = {x: -i2, y: -i2};
    (a2 == null ? void 0 : a2.data.svgData) && (a2 == null ? void 0 : a2.replaceColor) || (t2.globalAlpha = o2), t2.drawImage(r2, c2.x, c2.y, 2 * i2, 2 * i2 / l2), (a2 == null ? void 0 : a2.data.svgData) && (a2 == null ? void 0 : a2.replaceColor) || (t2.globalAlpha = 1);
  }
}
class wt {
  getSidesCount() {
    return 1;
  }
  draw(t2, e2, i2) {
    t2.moveTo(0, -i2 / 2), t2.lineTo(0, i2 / 2);
  }
}
class xt {
  getSidesCount() {
    return 12;
  }
  draw(t2, e2, i2) {
    t2.arc(0, 0, i2, 0, 2 * Math.PI, false);
  }
}
class kt {
  getSidesCount(t2) {
    var e2, i2;
    const o2 = t2.shapeData;
    return (i2 = (e2 = o2 == null ? void 0 : o2.sides) !== null && e2 !== void 0 ? e2 : o2 == null ? void 0 : o2.nb_sides) !== null && i2 !== void 0 ? i2 : 5;
  }
  draw(t2, e2, i2) {
    const o2 = this.getCenter(e2, i2), s2 = this.getSidesData(e2, i2), n2 = s2.count.numerator * s2.count.denominator, a2 = s2.count.numerator / s2.count.denominator, r2 = 180 * (a2 - 2) / a2, l2 = Math.PI - Math.PI * r2 / 180;
    if (t2) {
      t2.beginPath(), t2.translate(o2.x, o2.y), t2.moveTo(0, 0);
      for (let e3 = 0; e3 < n2; e3++)
        t2.lineTo(s2.length, 0), t2.translate(s2.length, 0), t2.rotate(l2);
    }
  }
}
class Pt extends kt {
  getSidesCount() {
    return 3;
  }
  getSidesData(t2, e2) {
    return {count: {denominator: 2, numerator: 3}, length: 2 * e2};
  }
  getCenter(t2, e2) {
    return {x: -e2, y: e2 / 1.66};
  }
}
class Mt {
  getSidesCount(t2) {
    var e2, i2;
    const o2 = t2.shapeData;
    return (i2 = (e2 = o2 == null ? void 0 : o2.sides) !== null && e2 !== void 0 ? e2 : o2 == null ? void 0 : o2.nb_sides) !== null && i2 !== void 0 ? i2 : 5;
  }
  draw(t2, e2, i2) {
    var o2;
    const s2 = e2.shapeData, n2 = this.getSidesCount(e2), a2 = (o2 = s2 == null ? void 0 : s2.inset) !== null && o2 !== void 0 ? o2 : 2;
    t2.moveTo(0, 0 - i2);
    for (let e3 = 0; e3 < n2; e3++)
      t2.rotate(Math.PI / n2), t2.lineTo(0, 0 - i2 * a2), t2.rotate(Math.PI / n2), t2.lineTo(0, 0 - i2);
  }
}
class Rt extends kt {
  getSidesData(t2, e2) {
    var i2, o2;
    const s2 = t2.shapeData, n2 = (o2 = (i2 = s2 == null ? void 0 : s2.sides) !== null && i2 !== void 0 ? i2 : s2 == null ? void 0 : s2.nb_sides) !== null && o2 !== void 0 ? o2 : 5;
    return {count: {denominator: 1, numerator: n2}, length: 2.66 * e2 / (n2 / 3)};
  }
  getCenter(t2, e2) {
    return {x: -e2 / (this.getSidesCount(t2) / 3.5), y: -e2 / 0.76};
  }
}
class St {
  constructor(t2) {
    this.container = t2, this.size = {height: 0, width: 0}, this.context = null, this.generatedCanvas = false;
  }
  init() {
    var t2, e2, i2, o2, s2, n2, a2, r2, l2, c2, d2, h2;
    this.resize();
    const u2 = this.container.actualOptions, v2 = this.element;
    v2 && (u2.fullScreen.enable ? (this.originalStyle = J.deepExtend({}, v2.style), v2.style.position = "fixed", v2.style.zIndex = u2.fullScreen.zIndex.toString(10), v2.style.top = "0", v2.style.left = "0", v2.style.width = "100%", v2.style.height = "100%") : (v2.style.position = (e2 = (t2 = this.originalStyle) === null || t2 === void 0 ? void 0 : t2.position) !== null && e2 !== void 0 ? e2 : "", v2.style.zIndex = (o2 = (i2 = this.originalStyle) === null || i2 === void 0 ? void 0 : i2.zIndex) !== null && o2 !== void 0 ? o2 : "", v2.style.top = (n2 = (s2 = this.originalStyle) === null || s2 === void 0 ? void 0 : s2.top) !== null && n2 !== void 0 ? n2 : "", v2.style.left = (r2 = (a2 = this.originalStyle) === null || a2 === void 0 ? void 0 : a2.left) !== null && r2 !== void 0 ? r2 : "", v2.style.width = (c2 = (l2 = this.originalStyle) === null || l2 === void 0 ? void 0 : l2.width) !== null && c2 !== void 0 ? c2 : "", v2.style.height = (h2 = (d2 = this.originalStyle) === null || d2 === void 0 ? void 0 : d2.height) !== null && h2 !== void 0 ? h2 : ""));
    const p2 = u2.backgroundMask.cover, y2 = p2.color, f2 = u2.particles.move.trail, m2 = tt.colorToRgb(y2);
    this.coverColor = m2 !== void 0 ? {r: m2.r, g: m2.g, b: m2.b, a: p2.opacity} : void 0, this.trailFillColor = tt.colorToRgb(f2.fillColor), this.initBackground(), this.paint();
  }
  loadCanvas(t2, e2) {
    var i2;
    t2.className || (t2.className = Q.canvasClass), this.generatedCanvas && ((i2 = this.element) === null || i2 === void 0 || i2.remove()), this.generatedCanvas = e2 != null ? e2 : this.generatedCanvas, this.element = t2, this.originalStyle = J.deepExtend({}, this.element.style), this.size.height = t2.offsetHeight, this.size.width = t2.offsetWidth, this.context = this.element.getContext("2d"), this.container.retina.init(), this.initBackground();
  }
  destroy() {
    var t2;
    this.generatedCanvas && ((t2 = this.element) === null || t2 === void 0 || t2.remove()), this.context && it.clear(this.context, this.size);
  }
  paint() {
    const t2 = this.container.actualOptions;
    this.context && (t2.backgroundMask.enable && t2.backgroundMask.cover && this.coverColor ? (it.clear(this.context, this.size), this.paintBase(tt.getStyleFromRgb(this.coverColor, this.coverColor.a))) : this.paintBase());
  }
  clear() {
    const t2 = this.container.actualOptions, e2 = t2.particles.move.trail;
    t2.backgroundMask.enable ? this.paint() : e2.enable && e2.length > 0 && this.trailFillColor ? this.paintBase(tt.getStyleFromRgb(this.trailFillColor, 1 / e2.length)) : this.context && it.clear(this.context, this.size);
  }
  windowResize() {
    if (!this.element)
      return;
    const t2 = this.container;
    this.resize(), t2.actualOptions.setResponsive(this.size.width, t2.retina.pixelRatio, t2.options), t2.particles.setDensity();
    for (const [, e2] of t2.plugins)
      e2.resize !== void 0 && e2.resize();
  }
  resize() {
    if (!this.element)
      return;
    const t2 = this.container, e2 = t2.retina.pixelRatio, i2 = t2.canvas.size, o2 = i2.width, s2 = i2.height;
    i2.width = this.element.offsetWidth * e2, i2.height = this.element.offsetHeight * e2, this.element.width = i2.width, this.element.height = i2.height, this.container.started && (this.resizeFactor = {width: i2.width / o2, height: i2.height / s2});
  }
  drawConnectLine(t2, e2) {
    var i2;
    const o2 = this.context;
    if (!o2)
      return;
    const s2 = this.lineStyle(t2, e2);
    if (!s2)
      return;
    const n2 = t2.getPosition(), a2 = e2.getPosition();
    it.drawConnectLine(o2, (i2 = t2.linksWidth) !== null && i2 !== void 0 ? i2 : this.container.retina.linksWidth, s2, n2, a2);
  }
  drawGrabLine(t2, e2, i2, o2) {
    var s2;
    const n2 = this.container, a2 = n2.canvas.context;
    if (!a2)
      return;
    const r2 = t2.getPosition();
    it.drawGrabLine(a2, (s2 = t2.linksWidth) !== null && s2 !== void 0 ? s2 : n2.retina.linksWidth, r2, o2, e2, i2);
  }
  drawParticleShadow(t2, e2) {
    this.context && it.drawParticleShadow(this.container, this.context, t2, e2);
  }
  drawLinkTriangle(t2, e2, i2) {
    var o2;
    const s2 = this.container, n2 = s2.actualOptions, a2 = e2.destination, r2 = i2.destination, l2 = t2.options.links.triangles, c2 = (o2 = l2.opacity) !== null && o2 !== void 0 ? o2 : (e2.opacity + i2.opacity) / 2;
    if (c2 <= 0)
      return;
    const d2 = t2.getPosition(), h2 = a2.getPosition(), u2 = r2.getPosition(), v2 = this.context;
    if (!v2)
      return;
    if (E.getDistance(d2, h2) > s2.retina.linksDistance || E.getDistance(u2, h2) > s2.retina.linksDistance || E.getDistance(u2, d2) > s2.retina.linksDistance)
      return;
    let p2 = tt.colorToRgb(l2.color);
    if (!p2) {
      const e3 = t2.options.links, i3 = e3.id !== void 0 ? s2.particles.linksColors.get(e3.id) : s2.particles.linksColor;
      p2 = tt.getLinkColor(t2, a2, i3);
    }
    p2 && it.drawLinkTriangle(v2, d2, h2, u2, n2.backgroundMask.enable, n2.backgroundMask.composite, p2, c2);
  }
  drawLinkLine(t2, e2) {
    var i2, o2;
    const s2 = this.container, n2 = s2.actualOptions, a2 = e2.destination;
    let r2 = e2.opacity;
    const l2 = t2.getPosition(), c2 = a2.getPosition(), d2 = this.context;
    if (!d2)
      return;
    let h2;
    const u2 = t2.options.twinkle.lines;
    if (u2.enable) {
      const t3 = u2.frequency, e3 = tt.colorToRgb(u2.color);
      Math.random() < t3 && e3 !== void 0 && (h2 = e3, r2 = u2.opacity);
    }
    if (!h2) {
      const e3 = t2.options.links, i3 = e3.id !== void 0 ? s2.particles.linksColors.get(e3.id) : s2.particles.linksColor;
      h2 = tt.getLinkColor(t2, a2, i3);
    }
    if (!h2)
      return;
    const v2 = (i2 = t2.linksWidth) !== null && i2 !== void 0 ? i2 : s2.retina.linksWidth, p2 = (o2 = t2.linksDistance) !== null && o2 !== void 0 ? o2 : s2.retina.linksDistance;
    it.drawLinkLine(d2, v2, l2, c2, p2, s2.canvas.size, t2.options.links.warp, n2.backgroundMask.enable, n2.backgroundMask.composite, h2, r2, t2.options.links.shadow);
  }
  drawParticle(t2, e2) {
    var i2, o2, s2, n2;
    if (((i2 = t2.image) === null || i2 === void 0 ? void 0 : i2.loaded) === false || t2.spawning || t2.destroyed)
      return;
    const a2 = t2.getFillColor(), r2 = (o2 = t2.getStrokeColor()) !== null && o2 !== void 0 ? o2 : a2;
    if (!a2 && !r2)
      return;
    const l2 = this.container.actualOptions, c2 = t2.options.twinkle.particles, d2 = c2.frequency, h2 = tt.colorToRgb(c2.color), u2 = c2.enable && Math.random() < d2, v2 = t2.getRadius(), p2 = u2 ? c2.opacity : (s2 = t2.bubble.opacity) !== null && s2 !== void 0 ? s2 : t2.opacity.value, y2 = t2.infecter.infectionStage, f2 = l2.infection.stages, m2 = y2 !== void 0 ? f2[y2].color : void 0, g2 = tt.colorToRgb(m2), b2 = u2 && h2 !== void 0 ? h2 : g2 != null ? g2 : a2 ? tt.hslToRgb(a2) : void 0, w2 = u2 && h2 !== void 0 ? h2 : g2 != null ? g2 : r2 ? tt.hslToRgb(r2) : void 0, x2 = b2 !== void 0 ? tt.getStyleFromRgb(b2, p2) : void 0;
    if (!this.context || !x2 && !w2)
      return;
    const k2 = w2 !== void 0 ? tt.getStyleFromRgb(w2, (n2 = t2.stroke.opacity) !== null && n2 !== void 0 ? n2 : p2) : x2;
    this.drawParticleLinks(t2), v2 > 0 && it.drawParticle(this.container, this.context, t2, e2, x2, k2, l2.backgroundMask.enable, l2.backgroundMask.composite, v2, p2, t2.options.shadow);
  }
  drawParticleLinks(t2) {
    if (!this.context)
      return;
    const e2 = this.container, i2 = e2.particles, o2 = t2.options;
    if (t2.links.length > 0) {
      this.context.save();
      const s2 = t2.links.filter((i3) => e2.particles.getLinkFrequency(t2, i3.destination) <= o2.links.frequency);
      for (const n2 of s2) {
        const a2 = n2.destination;
        if (o2.links.triangles.enable) {
          const r2 = s2.map((t3) => t3.destination), l2 = a2.links.filter((t3) => e2.particles.getLinkFrequency(a2, t3.destination) <= a2.options.links.frequency && r2.indexOf(t3.destination) >= 0);
          if (l2.length)
            for (const e3 of l2) {
              const s3 = e3.destination;
              i2.getTriangleFrequency(t2, a2, s3) > o2.links.triangles.frequency || this.drawLinkTriangle(t2, n2, e3);
            }
        }
        n2.opacity > 0 && e2.retina.linksWidth > 0 && this.drawLinkLine(t2, n2);
      }
      this.context.restore();
    }
  }
  drawPlugin(t2, e2) {
    this.context && it.drawPlugin(this.context, t2, e2);
  }
  drawLight(t2) {
    this.context && it.drawLight(this.container, this.context, t2);
  }
  paintBase(t2) {
    this.context && it.paintBase(this.context, this.size, t2);
  }
  lineStyle(t2, e2) {
    if (!this.context)
      return;
    const i2 = this.container.actualOptions.interactivity.modes.connect;
    return it.gradient(this.context, t2, e2, i2.links.opacity);
  }
  initBackground() {
    const t2 = this.container.actualOptions.background, e2 = this.element, i2 = e2 == null ? void 0 : e2.style;
    if (i2) {
      if (t2.color) {
        const e3 = tt.colorToRgb(t2.color);
        i2.backgroundColor = e3 ? tt.getStyleFromRgb(e3, t2.opacity) : "";
      } else
        i2.backgroundColor = "";
      i2.backgroundImage = t2.image || "", i2.backgroundPosition = t2.position || "", i2.backgroundRepeat = t2.repeat || "", i2.backgroundSize = t2.size || "";
    }
  }
}
function Ct(t2, e2, i2, o2, s2) {
  switch (e2) {
    case B.max:
      i2 >= s2 && t2.destroy();
      break;
    case B.min:
      i2 <= o2 && t2.destroy();
  }
}
class zt {
  constructor(t2, e2) {
    this.container = t2, this.particle = e2;
  }
  update(t2) {
    this.particle.destroyed || (this.updateLife(t2), this.particle.destroyed || this.particle.spawning || (this.updateOpacity(t2), this.updateSize(t2), this.updateAngle(t2), this.updateColor(t2), this.updateStrokeColor(t2), this.updateOutModes(t2)));
  }
  updateLife(t2) {
    const e2 = this.particle;
    let i2 = false;
    if (e2.spawning && (e2.lifeDelayTime += t2.value, e2.lifeDelayTime >= e2.lifeDelay && (i2 = true, e2.spawning = false, e2.lifeDelayTime = 0, e2.lifeTime = 0)), e2.lifeDuration !== -1 && !e2.spawning && (i2 ? e2.lifeTime = 0 : e2.lifeTime += t2.value, e2.lifeTime >= e2.lifeDuration)) {
      if (e2.lifeTime = 0, e2.livesRemaining > 0 && e2.livesRemaining--, e2.livesRemaining === 0)
        return void e2.destroy();
      const t3 = this.container.canvas.size;
      e2.position.x = E.randomInRange(E.setRangeValue(0, t3.width)), e2.position.y = E.randomInRange(E.setRangeValue(0, t3.height)), e2.spawning = true, e2.lifeDelayTime = 0, e2.lifeTime = 0, e2.reset();
      const i3 = e2.options.life;
      e2.lifeDelay = 1e3 * E.getValue(i3.delay), e2.lifeDuration = 1e3 * E.getValue(i3.duration);
    }
  }
  updateOpacity(t2) {
    var e2, i2;
    const o2 = this.particle, s2 = o2.options.opacity, n2 = s2.animation, a2 = E.getRangeMin(s2.value), r2 = E.getRangeMax(s2.value);
    if (!o2.destroyed && n2.enable && (n2.count <= 0 || o2.loops.size < n2.count)) {
      switch (o2.opacity.status) {
        case q.increasing:
          o2.opacity.value >= r2 ? (o2.opacity.status = q.decreasing, o2.loops.opacity++) : o2.opacity.value += ((e2 = o2.opacity.velocity) !== null && e2 !== void 0 ? e2 : 0) * t2.factor;
          break;
        case q.decreasing:
          o2.opacity.value <= a2 ? (o2.opacity.status = q.increasing, o2.loops.opacity++) : o2.opacity.value -= ((i2 = o2.opacity.velocity) !== null && i2 !== void 0 ? i2 : 0) * t2.factor;
      }
      Ct(o2, n2.destroy, o2.opacity.value, a2, r2), o2.destroyed || (o2.opacity.value = E.clamp(o2.opacity.value, a2, r2));
    }
  }
  updateSize(t2) {
    var e2;
    const i2 = this.container, o2 = this.particle, s2 = o2.options.size, n2 = s2.animation, a2 = ((e2 = o2.size.velocity) !== null && e2 !== void 0 ? e2 : 0) * t2.factor, r2 = E.getRangeMin(s2.value) * i2.retina.pixelRatio, l2 = E.getRangeMax(s2.value) * i2.retina.pixelRatio;
    if (!o2.destroyed && n2.enable && (n2.count <= 0 || o2.loops.size < n2.count)) {
      switch (o2.size.status) {
        case q.increasing:
          o2.size.value >= l2 ? (o2.size.status = q.decreasing, o2.loops.size++) : o2.size.value += a2;
          break;
        case q.decreasing:
          o2.size.value <= r2 ? (o2.size.status = q.increasing, o2.loops.size++) : o2.size.value -= a2;
      }
      Ct(o2, n2.destroy, o2.size.value, r2, l2), o2.destroyed || (o2.size.value = E.clamp(o2.size.value, r2, l2));
    }
  }
  updateAngle(t2) {
    var e2;
    const i2 = this.particle, o2 = i2.options.rotate.animation, s2 = ((e2 = i2.rotate.velocity) !== null && e2 !== void 0 ? e2 : 0) * t2.factor, n2 = 2 * Math.PI;
    if (o2.enable)
      switch (i2.rotate.status) {
        case q.increasing:
          i2.rotate.value += s2, i2.rotate.value > n2 && (i2.rotate.value -= n2);
          break;
        case q.decreasing:
        default:
          i2.rotate.value -= s2, i2.rotate.value < 0 && (i2.rotate.value += n2);
      }
  }
  updateColor(t2) {
    var e2, i2, o2;
    const s2 = this.particle, n2 = s2.options.color.animation;
    ((e2 = s2.color) === null || e2 === void 0 ? void 0 : e2.h) !== void 0 && this.updateColorValue(s2, t2, s2.color.h, n2.h, 360, false), ((i2 = s2.color) === null || i2 === void 0 ? void 0 : i2.s) !== void 0 && this.updateColorValue(s2, t2, s2.color.s, n2.s, 100, true), ((o2 = s2.color) === null || o2 === void 0 ? void 0 : o2.l) !== void 0 && this.updateColorValue(s2, t2, s2.color.l, n2.l, 100, true);
  }
  updateStrokeColor(t2) {
    var e2, i2, o2, s2, n2, a2, r2, l2, c2, d2, h2, u2;
    const v2 = this.particle;
    if (!v2.stroke.color)
      return;
    const p2 = v2.stroke.color.animation, y2 = p2;
    if (y2.enable !== void 0) {
      const s3 = (i2 = (e2 = v2.strokeColor) === null || e2 === void 0 ? void 0 : e2.h) !== null && i2 !== void 0 ? i2 : (o2 = v2.color) === null || o2 === void 0 ? void 0 : o2.h;
      s3 && this.updateColorValue(v2, t2, s3, y2, 360, false);
    } else {
      const e3 = p2, i3 = (n2 = (s2 = v2.strokeColor) === null || s2 === void 0 ? void 0 : s2.h) !== null && n2 !== void 0 ? n2 : (a2 = v2.color) === null || a2 === void 0 ? void 0 : a2.h;
      i3 && this.updateColorValue(v2, t2, i3, e3.h, 360, false);
      const o3 = (l2 = (r2 = v2.strokeColor) === null || r2 === void 0 ? void 0 : r2.s) !== null && l2 !== void 0 ? l2 : (c2 = v2.color) === null || c2 === void 0 ? void 0 : c2.s;
      o3 && this.updateColorValue(v2, t2, o3, e3.s, 100, true);
      const y3 = (h2 = (d2 = v2.strokeColor) === null || d2 === void 0 ? void 0 : d2.l) !== null && h2 !== void 0 ? h2 : (u2 = v2.color) === null || u2 === void 0 ? void 0 : u2.l;
      y3 && this.updateColorValue(v2, t2, y3, e3.l, 100, true);
    }
  }
  updateColorValue(t2, e2, i2, o2, s2, n2) {
    var a2;
    const r2 = i2;
    if (!r2 || !o2.enable)
      return;
    const l2 = E.randomInRange(o2.offset), c2 = ((a2 = i2.velocity) !== null && a2 !== void 0 ? a2 : 0) * e2.factor + 3.6 * l2;
    n2 && r2.status !== q.increasing ? (r2.value -= c2, r2.value < 0 && (r2.status = q.increasing, r2.value += r2.value)) : (r2.value += c2, n2 && r2.value > s2 && (r2.status = q.decreasing, r2.value -= r2.value % s2)), r2.value > s2 && (r2.value %= s2);
  }
  updateOutModes(t2) {
    var e2, i2, o2, s2;
    const n2 = this.particle.options.move.outModes;
    this.updateOutMode(t2, (e2 = n2.bottom) !== null && e2 !== void 0 ? e2 : n2.default, C.bottom), this.updateOutMode(t2, (i2 = n2.left) !== null && i2 !== void 0 ? i2 : n2.default, C.left), this.updateOutMode(t2, (o2 = n2.right) !== null && o2 !== void 0 ? o2 : n2.default, C.right), this.updateOutMode(t2, (s2 = n2.top) !== null && s2 !== void 0 ? s2 : n2.default, C.top);
  }
  updateOutMode(t2, e2, i2) {
    const o2 = this.container, s2 = this.particle;
    switch (e2) {
      case V.bounce:
      case V.bounceVertical:
      case V.bounceHorizontal:
      case "bounceVertical":
      case "bounceHorizontal":
      case V.split:
        this.updateBounce(t2, i2, e2);
        break;
      case V.destroy:
        J.isPointInside(s2.position, o2.canvas.size, s2.getRadius(), i2) || o2.particles.remove(s2, true);
        break;
      case V.out:
        J.isPointInside(s2.position, o2.canvas.size, s2.getRadius(), i2) || this.fixOutOfCanvasPosition(i2);
        break;
      case V.none:
        this.bounceNone(i2);
    }
  }
  fixOutOfCanvasPosition(t2) {
    const e2 = this.container, i2 = this.particle, o2 = i2.options.move.warp, s2 = e2.canvas.size, n2 = {bottom: s2.height + i2.getRadius() - i2.offset.y, left: -i2.getRadius() - i2.offset.x, right: s2.width + i2.getRadius() + i2.offset.x, top: -i2.getRadius() - i2.offset.y}, a2 = i2.getRadius(), r2 = J.calculateBounds(i2.position, a2);
    t2 === C.right && r2.left > s2.width - i2.offset.x ? (i2.position.x = n2.left, o2 || (i2.position.y = Math.random() * s2.height)) : t2 === C.left && r2.right < -i2.offset.x && (i2.position.x = n2.right, o2 || (i2.position.y = Math.random() * s2.height)), t2 === C.bottom && r2.top > s2.height - i2.offset.y ? (o2 || (i2.position.x = Math.random() * s2.width), i2.position.y = n2.top) : t2 === C.top && r2.bottom < -i2.offset.y && (o2 || (i2.position.x = Math.random() * s2.width), i2.position.y = n2.bottom);
  }
  updateBounce(t2, e2, i2) {
    const o2 = this.container, s2 = this.particle;
    let n2 = false;
    for (const [, i3] of o2.plugins)
      if (i3.particleBounce !== void 0 && (n2 = i3.particleBounce(s2, t2, e2)), n2)
        break;
    if (n2)
      return;
    const a2 = s2.getPosition(), r2 = s2.offset, l2 = s2.getRadius(), c2 = J.calculateBounds(a2, l2), d2 = o2.canvas.size;
    !function(t3) {
      if (t3.outMode === V.bounce || t3.outMode === V.bounceHorizontal || t3.outMode === "bounceHorizontal" || t3.outMode === V.split) {
        const e3 = t3.particle.velocity.x;
        let i3 = false;
        if (t3.direction === C.right && t3.bounds.right >= t3.canvasSize.width && e3 > 0 || t3.direction === C.left && t3.bounds.left <= 0 && e3 < 0) {
          const e4 = E.getValue(t3.particle.options.bounce.horizontal);
          t3.particle.velocity.x *= -e4, i3 = true;
        }
        if (!i3)
          return;
        const o3 = t3.offset.x + t3.size;
        t3.bounds.right >= t3.canvasSize.width ? t3.particle.position.x = t3.canvasSize.width - o3 : t3.bounds.left <= 0 && (t3.particle.position.x = o3), t3.outMode === V.split && t3.particle.destroy();
      }
    }({particle: s2, outMode: i2, direction: e2, bounds: c2, canvasSize: d2, offset: r2, size: l2}), function(t3) {
      if (t3.outMode === V.bounce || t3.outMode === V.bounceVertical || t3.outMode === "bounceVertical" || t3.outMode === V.split) {
        const e3 = t3.particle.velocity.y;
        let i3 = false;
        if (t3.direction === C.bottom && t3.bounds.bottom >= t3.canvasSize.height && e3 > 0 || t3.direction === C.top && t3.bounds.top <= 0 && e3 < 0) {
          const e4 = E.getValue(t3.particle.options.bounce.vertical);
          t3.particle.velocity.y *= -e4, i3 = true;
        }
        if (!i3)
          return;
        const o3 = t3.offset.y + t3.size;
        t3.bounds.bottom >= t3.canvasSize.height ? t3.particle.position.y = t3.canvasSize.height - o3 : t3.bounds.top <= 0 && (t3.particle.position.y = o3), t3.outMode === V.split && t3.particle.destroy();
      }
    }({particle: s2, outMode: i2, direction: e2, bounds: c2, canvasSize: d2, offset: r2, size: l2});
  }
  bounceNone(t2) {
    const e2 = this.particle;
    if (e2.options.move.distance)
      return;
    const i2 = e2.options.move.gravity, o2 = this.container;
    if (i2.enable) {
      const s2 = e2.position;
      (i2.acceleration >= 0 && s2.y > o2.canvas.size.height && t2 === C.bottom || i2.acceleration < 0 && s2.y < 0 && t2 === C.top) && o2.particles.remove(e2);
    } else
      J.isPointInside(e2.position, o2.canvas.size, e2.getRadius(), t2) || o2.particles.remove(e2);
  }
}
class At {
  constructor() {
    this.value = "#fff";
  }
  static create(t2, e2) {
    const i2 = t2 != null ? t2 : new At();
    return e2 !== void 0 && i2.load(typeof e2 == "string" ? {value: e2} : e2), i2;
  }
  load(t2) {
    (t2 == null ? void 0 : t2.value) !== void 0 && (this.value = t2.value);
  }
}
class Tt {
  constructor() {
    this.blur = 5, this.color = new At(), this.enable = false, this.color.value = "#00ff00";
  }
  load(t2) {
    t2 !== void 0 && (t2.blur !== void 0 && (this.blur = t2.blur), this.color = At.create(this.color, t2.color), t2.enable !== void 0 && (this.enable = t2.enable));
  }
}
class Et {
  constructor() {
    this.enable = false, this.frequency = 1;
  }
  load(t2) {
    t2 !== void 0 && (t2.color !== void 0 && (this.color = At.create(this.color, t2.color)), t2.enable !== void 0 && (this.enable = t2.enable), t2.frequency !== void 0 && (this.frequency = t2.frequency), t2.opacity !== void 0 && (this.opacity = t2.opacity));
  }
}
class Dt {
  constructor() {
    this.blink = false, this.color = new At(), this.consent = false, this.distance = 100, this.enable = false, this.frequency = 1, this.opacity = 1, this.shadow = new Tt(), this.triangles = new Et(), this.width = 1, this.warp = false;
  }
  load(t2) {
    t2 !== void 0 && (t2.id !== void 0 && (this.id = t2.id), t2.blink !== void 0 && (this.blink = t2.blink), this.color = At.create(this.color, t2.color), t2.consent !== void 0 && (this.consent = t2.consent), t2.distance !== void 0 && (this.distance = t2.distance), t2.enable !== void 0 && (this.enable = t2.enable), t2.frequency !== void 0 && (this.frequency = t2.frequency), t2.opacity !== void 0 && (this.opacity = t2.opacity), this.shadow.load(t2.shadow), this.triangles.load(t2.triangles), t2.width !== void 0 && (this.width = t2.width), t2.warp !== void 0 && (this.warp = t2.warp));
  }
}
class Ot {
  constructor() {
    this.enable = false, this.rotate = {x: 3e3, y: 3e3};
  }
  get rotateX() {
    return this.rotate.x;
  }
  set rotateX(t2) {
    this.rotate.x = t2;
  }
  get rotateY() {
    return this.rotate.y;
  }
  set rotateY(t2) {
    this.rotate.y = t2;
  }
  load(t2) {
    var e2, i2, o2, s2;
    if (t2 === void 0)
      return;
    t2.enable !== void 0 && (this.enable = t2.enable);
    const n2 = (i2 = (e2 = t2.rotate) === null || e2 === void 0 ? void 0 : e2.x) !== null && i2 !== void 0 ? i2 : t2.rotateX;
    n2 !== void 0 && (this.rotate.x = n2);
    const a2 = (s2 = (o2 = t2.rotate) === null || o2 === void 0 ? void 0 : o2.y) !== null && s2 !== void 0 ? s2 : t2.rotateY;
    a2 !== void 0 && (this.rotate.y = a2);
  }
}
class It {
  constructor() {
    this.enable = false, this.length = 10, this.fillColor = new At(), this.fillColor.value = "#000000";
  }
  load(t2) {
    t2 !== void 0 && (t2.enable !== void 0 && (this.enable = t2.enable), this.fillColor = At.create(this.fillColor, t2.fillColor), t2.length !== void 0 && (this.length = t2.length));
  }
}
class Ft {
  constructor() {
    this.enable = false, this.minimumValue = 0;
  }
  load(t2) {
    t2 && (t2.enable !== void 0 && (this.enable = t2.enable), t2.minimumValue !== void 0 && (this.minimumValue = t2.minimumValue));
  }
}
class Lt {
  constructor() {
    this.random = new Ft(), this.value = 0;
  }
  load(t2) {
    t2 && (typeof t2.random == "boolean" ? this.random.enable = t2.random : this.random.load(t2.random), t2.value !== void 0 && (this.value = E.setRangeValue(t2.value, this.random.enable ? this.random.minimumValue : void 0)));
  }
}
class Vt extends Lt {
  constructor() {
    super();
  }
}
class Ht {
  constructor() {
    this.clamp = true, this.delay = new Vt(), this.enable = false;
  }
  load(t2) {
    t2 !== void 0 && (t2.clamp !== void 0 && (this.clamp = t2.clamp), this.delay.load(t2.delay), t2.enable !== void 0 && (this.enable = t2.enable), this.generator = t2.generator);
  }
}
class _t {
  constructor() {
    this.offset = 45, this.value = 90;
  }
  load(t2) {
    t2 !== void 0 && (t2.offset !== void 0 && (this.offset = t2.offset), t2.value !== void 0 && (this.value = t2.value));
  }
}
class qt {
  constructor() {
    this.acceleration = 9.81, this.enable = false, this.maxSpeed = 50;
  }
  load(t2) {
    t2 && (t2.acceleration !== void 0 && (this.acceleration = t2.acceleration), t2.enable !== void 0 && (this.enable = t2.enable), t2.maxSpeed !== void 0 && (this.maxSpeed = t2.maxSpeed));
  }
}
class Bt {
  constructor() {
    this.default = V.out;
  }
  load(t2) {
    var e2, i2, o2, s2;
    t2 && (t2.default !== void 0 && (this.default = t2.default), this.bottom = (e2 = t2.bottom) !== null && e2 !== void 0 ? e2 : t2.default, this.left = (i2 = t2.left) !== null && i2 !== void 0 ? i2 : t2.default, this.right = (o2 = t2.right) !== null && o2 !== void 0 ? o2 : t2.default, this.top = (s2 = t2.top) !== null && s2 !== void 0 ? s2 : t2.default);
  }
}
class $t {
  constructor() {
    this.angle = new _t(), this.attract = new Ot(), this.decay = 0, this.distance = 0, this.direction = z.none, this.drift = 0, this.enable = false, this.gravity = new qt(), this.path = new Ht(), this.outModes = new Bt(), this.random = false, this.size = false, this.speed = 2, this.straight = false, this.trail = new It(), this.vibrate = false, this.warp = false;
  }
  get collisions() {
    return false;
  }
  set collisions(t2) {
  }
  get bounce() {
    return this.collisions;
  }
  set bounce(t2) {
    this.collisions = t2;
  }
  get out_mode() {
    return this.outMode;
  }
  set out_mode(t2) {
    this.outMode = t2;
  }
  get outMode() {
    return this.outModes.default;
  }
  set outMode(t2) {
    this.outModes.default = t2;
  }
  get noise() {
    return this.path;
  }
  set noise(t2) {
    this.path = t2;
  }
  load(t2) {
    var e2, i2, o2;
    if (t2 === void 0)
      return;
    t2.angle !== void 0 && (typeof t2.angle == "number" ? this.angle.value = t2.angle : this.angle.load(t2.angle)), this.attract.load(t2.attract), t2.decay !== void 0 && (this.decay = t2.decay), t2.direction !== void 0 && (this.direction = t2.direction), t2.distance !== void 0 && (this.distance = t2.distance), t2.drift !== void 0 && (this.drift = E.setRangeValue(t2.drift)), t2.enable !== void 0 && (this.enable = t2.enable), this.gravity.load(t2.gravity);
    const s2 = (e2 = t2.outMode) !== null && e2 !== void 0 ? e2 : t2.out_mode;
    t2.outModes === void 0 && s2 === void 0 || (typeof t2.outModes == "string" || t2.outModes === void 0 && s2 !== void 0 ? this.outModes.load({default: (i2 = t2.outModes) !== null && i2 !== void 0 ? i2 : s2}) : this.outModes.load(t2.outModes)), this.path.load((o2 = t2.path) !== null && o2 !== void 0 ? o2 : t2.noise), t2.random !== void 0 && (this.random = t2.random), t2.size !== void 0 && (this.size = t2.size), t2.speed !== void 0 && (this.speed = E.setRangeValue(t2.speed)), t2.straight !== void 0 && (this.straight = t2.straight), this.trail.load(t2.trail), t2.vibrate !== void 0 && (this.vibrate = t2.vibrate), t2.warp !== void 0 && (this.warp = t2.warp);
  }
}
class Wt {
  constructor() {
    this.enable = false, this.area = 800, this.factor = 1e3;
  }
  get value_area() {
    return this.area;
  }
  set value_area(t2) {
    this.area = t2;
  }
  load(t2) {
    var e2;
    if (t2 === void 0)
      return;
    t2.enable !== void 0 && (this.enable = t2.enable);
    const i2 = (e2 = t2.area) !== null && e2 !== void 0 ? e2 : t2.value_area;
    i2 !== void 0 && (this.area = i2), t2.factor !== void 0 && (this.factor = t2.factor);
  }
}
class Gt {
  constructor() {
    this.density = new Wt(), this.limit = 0, this.value = 100;
  }
  get max() {
    return this.limit;
  }
  set max(t2) {
    this.limit = t2;
  }
  load(t2) {
    var e2;
    if (t2 === void 0)
      return;
    this.density.load(t2.density);
    const i2 = (e2 = t2.limit) !== null && e2 !== void 0 ? e2 : t2.max;
    i2 !== void 0 && (this.limit = i2), t2.value !== void 0 && (this.value = t2.value);
  }
}
class Nt {
  constructor() {
    this.count = 0, this.enable = false, this.speed = 1, this.sync = false;
  }
  load(t2) {
    t2 && (t2.count !== void 0 && (this.count = t2.count), t2.enable !== void 0 && (this.enable = t2.enable), t2.speed !== void 0 && (this.speed = t2.speed), t2.sync !== void 0 && (this.sync = t2.sync));
  }
}
class Ut extends Nt {
  constructor() {
    super(), this.destroy = B.none, this.enable = false, this.minimumValue = 0, this.speed = 2, this.startValue = G.random, this.sync = false;
  }
  get opacity_min() {
    return this.minimumValue;
  }
  set opacity_min(t2) {
    this.minimumValue = t2;
  }
  load(t2) {
    var e2;
    if (t2 === void 0)
      return;
    super.load(t2), t2.destroy !== void 0 && (this.destroy = t2.destroy), t2.enable !== void 0 && (this.enable = t2.enable);
    const i2 = (e2 = t2.minimumValue) !== null && e2 !== void 0 ? e2 : t2.opacity_min;
    i2 !== void 0 && (this.minimumValue = i2), t2.speed !== void 0 && (this.speed = t2.speed), t2.startValue !== void 0 && (this.startValue = t2.startValue), t2.sync !== void 0 && (this.sync = t2.sync);
  }
}
class jt extends Lt {
  constructor() {
    super(), this.animation = new Ut(), this.random.minimumValue = 0.1, this.value = 1;
  }
  get anim() {
    return this.animation;
  }
  set anim(t2) {
    this.animation = t2;
  }
  load(t2) {
    var e2;
    if (!t2)
      return;
    super.load(t2);
    const i2 = (e2 = t2.animation) !== null && e2 !== void 0 ? e2 : t2.anim;
    i2 !== void 0 && (this.animation.load(i2), this.value = E.setRangeValue(this.value, this.animation.enable ? this.animation.minimumValue : void 0));
  }
}
class Yt {
  constructor() {
    this.options = {}, this.type = W.circle;
  }
  get image() {
    var t2;
    return (t2 = this.options[W.image]) !== null && t2 !== void 0 ? t2 : this.options[W.images];
  }
  set image(t2) {
    this.options[W.image] = t2, this.options[W.images] = t2;
  }
  get custom() {
    return this.options;
  }
  set custom(t2) {
    this.options = t2;
  }
  get images() {
    return this.image instanceof Array ? this.image : [this.image];
  }
  set images(t2) {
    this.image = t2;
  }
  get stroke() {
    return [];
  }
  set stroke(t2) {
  }
  get character() {
    var t2;
    return (t2 = this.options[W.character]) !== null && t2 !== void 0 ? t2 : this.options[W.char];
  }
  set character(t2) {
    this.options[W.character] = t2, this.options[W.char] = t2;
  }
  get polygon() {
    var t2;
    return (t2 = this.options[W.polygon]) !== null && t2 !== void 0 ? t2 : this.options[W.star];
  }
  set polygon(t2) {
    this.options[W.polygon] = t2, this.options[W.star] = t2;
  }
  load(t2) {
    var e2, i2, o2;
    if (t2 === void 0)
      return;
    const s2 = (e2 = t2.options) !== null && e2 !== void 0 ? e2 : t2.custom;
    if (s2 !== void 0)
      for (const t3 in s2) {
        const e3 = s2[t3];
        e3 !== void 0 && (this.options[t3] = J.deepExtend((i2 = this.options[t3]) !== null && i2 !== void 0 ? i2 : {}, e3));
      }
    this.loadShape(t2.character, W.character, W.char, true), this.loadShape(t2.polygon, W.polygon, W.star, false), this.loadShape((o2 = t2.image) !== null && o2 !== void 0 ? o2 : t2.images, W.image, W.images, true), t2.type !== void 0 && (this.type = t2.type);
  }
  loadShape(t2, e2, i2, o2) {
    var s2, n2, a2, r2;
    t2 !== void 0 && (t2 instanceof Array ? (this.options[e2] instanceof Array || (this.options[e2] = [], this.options[i2] && !o2 || (this.options[i2] = [])), this.options[e2] = J.deepExtend((s2 = this.options[e2]) !== null && s2 !== void 0 ? s2 : [], t2), this.options[i2] && !o2 || (this.options[i2] = J.deepExtend((n2 = this.options[i2]) !== null && n2 !== void 0 ? n2 : [], t2))) : (this.options[e2] instanceof Array && (this.options[e2] = {}, this.options[i2] && !o2 || (this.options[i2] = {})), this.options[e2] = J.deepExtend((a2 = this.options[e2]) !== null && a2 !== void 0 ? a2 : {}, t2), this.options[i2] && !o2 || (this.options[i2] = J.deepExtend((r2 = this.options[i2]) !== null && r2 !== void 0 ? r2 : {}, t2))));
  }
}
class Xt extends Nt {
  constructor() {
    super(), this.destroy = B.none, this.enable = false, this.minimumValue = 0, this.speed = 5, this.startValue = G.random, this.sync = false;
  }
  get size_min() {
    return this.minimumValue;
  }
  set size_min(t2) {
    this.minimumValue = t2;
  }
  load(t2) {
    var e2;
    if (t2 === void 0)
      return;
    super.load(t2), t2.destroy !== void 0 && (this.destroy = t2.destroy), t2.enable !== void 0 && (this.enable = t2.enable);
    const i2 = (e2 = t2.minimumValue) !== null && e2 !== void 0 ? e2 : t2.size_min;
    i2 !== void 0 && (this.minimumValue = i2), t2.speed !== void 0 && (this.speed = t2.speed), t2.startValue !== void 0 && (this.startValue = t2.startValue), t2.sync !== void 0 && (this.sync = t2.sync);
  }
}
class Jt extends Lt {
  constructor() {
    super(), this.animation = new Xt(), this.random.minimumValue = 1, this.value = 3;
  }
  get anim() {
    return this.animation;
  }
  set anim(t2) {
    this.animation = t2;
  }
  load(t2) {
    var e2;
    if (!t2)
      return;
    super.load(t2);
    const i2 = (e2 = t2.animation) !== null && e2 !== void 0 ? e2 : t2.anim;
    i2 !== void 0 && (this.animation.load(i2), this.value = E.setRangeValue(this.value, this.animation.enable ? this.animation.minimumValue : void 0));
  }
}
class Qt {
  constructor() {
    this.enable = false, this.speed = 0, this.sync = false;
  }
  load(t2) {
    t2 !== void 0 && (t2.enable !== void 0 && (this.enable = t2.enable), t2.speed !== void 0 && (this.speed = t2.speed), t2.sync !== void 0 && (this.sync = t2.sync));
  }
}
class Zt extends Lt {
  constructor() {
    super(), this.animation = new Qt(), this.direction = A.clockwise, this.path = false, this.value = 0;
  }
  load(t2) {
    t2 && (super.load(t2), t2.direction !== void 0 && (this.direction = t2.direction), this.animation.load(t2.animation), t2.path !== void 0 && (this.path = t2.path));
  }
}
class Kt {
  constructor() {
    this.blur = 0, this.color = new At(), this.enable = false, this.offset = {x: 0, y: 0}, this.color.value = "#000000";
  }
  load(t2) {
    t2 !== void 0 && (t2.blur !== void 0 && (this.blur = t2.blur), this.color = At.create(this.color, t2.color), t2.enable !== void 0 && (this.enable = t2.enable), t2.offset !== void 0 && (t2.offset.x !== void 0 && (this.offset.x = t2.offset.x), t2.offset.y !== void 0 && (this.offset.y = t2.offset.y)));
  }
}
class te {
  constructor() {
    this.count = 0, this.enable = false, this.offset = 0, this.speed = 1, this.sync = true;
  }
  load(t2) {
    t2 !== void 0 && (t2.count !== void 0 && (this.count = t2.count), t2.enable !== void 0 && (this.enable = t2.enable), t2.offset !== void 0 && (this.offset = E.setRangeValue(t2.offset)), t2.speed !== void 0 && (this.speed = t2.speed), t2.sync !== void 0 && (this.sync = t2.sync));
  }
}
class ee {
  constructor() {
    this.h = new te(), this.s = new te(), this.l = new te();
  }
  load(t2) {
    t2 && (this.h.load(t2.h), this.s.load(t2.s), this.l.load(t2.l));
  }
}
class ie extends At {
  constructor() {
    super(), this.animation = new ee();
  }
  static create(t2, e2) {
    const i2 = t2 != null ? t2 : new ie();
    return e2 !== void 0 && i2.load(typeof e2 == "string" ? {value: e2} : e2), i2;
  }
  load(t2) {
    if (super.load(t2), !t2)
      return;
    const e2 = t2.animation;
    e2 !== void 0 && (e2.enable !== void 0 ? this.animation.h.load(e2) : this.animation.load(t2.animation));
  }
}
class oe {
  constructor() {
    this.width = 0;
  }
  load(t2) {
    t2 !== void 0 && (t2.color !== void 0 && (this.color = ie.create(this.color, t2.color)), t2.width !== void 0 && (this.width = t2.width), t2.opacity !== void 0 && (this.opacity = t2.opacity));
  }
}
class se extends Lt {
  constructor() {
    super(), this.random.minimumValue = 0.1, this.value = 1;
  }
}
class ne {
  constructor() {
    this.horizontal = new se(), this.vertical = new se();
  }
  load(t2) {
    t2 && (this.horizontal.load(t2.horizontal), this.vertical.load(t2.vertical));
  }
}
class ae {
  constructor() {
    this.enable = true, this.retries = 0;
  }
  load(t2) {
    t2 && (t2.enable !== void 0 && (this.enable = t2.enable), t2.retries !== void 0 && (this.retries = t2.retries));
  }
}
class re {
  constructor() {
    this.bounce = new ne(), this.enable = false, this.mode = L.bounce, this.overlap = new ae();
  }
  load(t2) {
    t2 !== void 0 && (this.bounce.load(t2.bounce), t2.enable !== void 0 && (this.enable = t2.enable), t2.mode !== void 0 && (this.mode = t2.mode), this.overlap.load(t2.overlap));
  }
}
class le {
  constructor() {
    this.enable = false, this.frequency = 0.05, this.opacity = 1;
  }
  load(t2) {
    t2 !== void 0 && (t2.color !== void 0 && (this.color = At.create(this.color, t2.color)), t2.enable !== void 0 && (this.enable = t2.enable), t2.frequency !== void 0 && (this.frequency = t2.frequency), t2.opacity !== void 0 && (this.opacity = t2.opacity));
  }
}
class ce {
  constructor() {
    this.lines = new le(), this.particles = new le();
  }
  load(t2) {
    t2 !== void 0 && (this.lines.load(t2.lines), this.particles.load(t2.particles));
  }
}
class de extends Lt {
  constructor() {
    super(), this.sync = false;
  }
  load(t2) {
    t2 && (super.load(t2), t2.sync !== void 0 && (this.sync = t2.sync));
  }
}
class he extends Lt {
  constructor() {
    super(), this.random.minimumValue = 1e-4, this.sync = false;
  }
  load(t2) {
    t2 !== void 0 && (super.load(t2), t2.sync !== void 0 && (this.sync = t2.sync));
  }
}
class ue {
  constructor() {
    this.count = 0, this.delay = new de(), this.duration = new he();
  }
  load(t2) {
    t2 !== void 0 && (t2.count !== void 0 && (this.count = t2.count), this.delay.load(t2.delay), this.duration.load(t2.duration));
  }
}
class ve extends Lt {
  constructor() {
    super(), this.value = 3;
  }
}
class pe extends Lt {
  constructor() {
    super(), this.value = {min: 4, max: 9};
  }
}
class ye {
  constructor() {
    this.count = 1, this.factor = new ve(), this.rate = new pe();
  }
  load(t2) {
    t2 && (t2.count !== void 0 && (this.count = t2.count), this.factor.load(t2.factor), this.rate.load(t2.rate), t2.particles !== void 0 && (this.particles = J.deepExtend({}, t2.particles)));
  }
}
class fe {
  constructor() {
    this.mode = O.none, this.split = new ye();
  }
  load(t2) {
    t2 && (t2.mode !== void 0 && (this.mode = t2.mode), this.split.load(t2.split));
  }
}
class me {
  constructor() {
    this.bounce = new ne(), this.collisions = new re(), this.color = new ie(), this.destroy = new fe(), this.life = new ue(), this.links = new Dt(), this.move = new $t(), this.number = new Gt(), this.opacity = new jt(), this.reduceDuplicates = false, this.rotate = new Zt(), this.shadow = new Kt(), this.shape = new Yt(), this.size = new Jt(), this.stroke = new oe(), this.twinkle = new ce();
  }
  get line_linked() {
    return this.links;
  }
  set line_linked(t2) {
    this.links = t2;
  }
  get lineLinked() {
    return this.links;
  }
  set lineLinked(t2) {
    this.links = t2;
  }
  load(t2) {
    var e2, i2, o2, s2, n2, a2, r2;
    if (t2 === void 0)
      return;
    this.bounce.load(t2.bounce), this.color = ie.create(this.color, t2.color), this.destroy.load(t2.destroy), this.life.load(t2.life);
    const l2 = (i2 = (e2 = t2.links) !== null && e2 !== void 0 ? e2 : t2.lineLinked) !== null && i2 !== void 0 ? i2 : t2.line_linked;
    l2 !== void 0 && this.links.load(l2), this.move.load(t2.move), this.number.load(t2.number), this.opacity.load(t2.opacity), t2.reduceDuplicates !== void 0 && (this.reduceDuplicates = t2.reduceDuplicates), this.rotate.load(t2.rotate), this.shape.load(t2.shape), this.size.load(t2.size), this.shadow.load(t2.shadow), this.twinkle.load(t2.twinkle);
    const c2 = (s2 = (o2 = t2.move) === null || o2 === void 0 ? void 0 : o2.collisions) !== null && s2 !== void 0 ? s2 : (n2 = t2.move) === null || n2 === void 0 ? void 0 : n2.bounce;
    c2 !== void 0 && (this.collisions.enable = c2), this.collisions.load(t2.collisions);
    const d2 = (a2 = t2.stroke) !== null && a2 !== void 0 ? a2 : (r2 = t2.shape) === null || r2 === void 0 ? void 0 : r2.stroke;
    d2 !== void 0 && (d2 instanceof Array ? this.stroke = d2.map((t3) => {
      const e3 = new oe();
      return e3.load(t3), e3;
    }) : (this.stroke instanceof Array && (this.stroke = new oe()), this.stroke.load(d2)));
  }
}
class ge {
  constructor(t2) {
    this.container = t2;
  }
  startInfection(t2) {
    t2 > this.container.actualOptions.infection.stages.length || t2 < 0 || (this.infectionDelay = 0, this.infectionDelayStage = t2);
  }
  updateInfectionStage(t2) {
    t2 > this.container.actualOptions.infection.stages.length || t2 < 0 || this.infectionStage !== void 0 && this.infectionStage > t2 || (this.infectionStage = t2, this.infectionTime = 0);
  }
  updateInfection(t2) {
    const e2 = this.container.actualOptions, i2 = e2.infection, o2 = e2.infection.stages, s2 = o2.length;
    if (this.infectionDelay !== void 0 && this.infectionDelayStage !== void 0) {
      const e3 = this.infectionDelayStage;
      if (e3 > s2 || e3 < 0)
        return;
      this.infectionDelay > 1e3 * i2.delay ? (this.infectionStage = e3, this.infectionTime = 0, delete this.infectionDelay, delete this.infectionDelayStage) : this.infectionDelay += t2;
    } else
      delete this.infectionDelay, delete this.infectionDelayStage;
    if (this.infectionStage !== void 0 && this.infectionTime !== void 0) {
      const e3 = o2[this.infectionStage];
      e3.duration !== void 0 && e3.duration >= 0 && this.infectionTime > 1e3 * e3.duration ? this.nextInfectionStage() : this.infectionTime += t2;
    } else
      delete this.infectionStage, delete this.infectionTime;
  }
  nextInfectionStage() {
    const t2 = this.container.actualOptions, e2 = t2.infection.stages.length;
    if (!(e2 <= 0 || this.infectionStage === void 0) && (this.infectionTime = 0, e2 <= ++this.infectionStage)) {
      if (t2.infection.cure)
        return delete this.infectionStage, void delete this.infectionTime;
      this.infectionStage = 0, this.infectionTime = 0;
    }
  }
}
class be {
  constructor(t2, e2) {
    this.container = t2, this.particle = e2;
  }
  move(t2) {
    const e2 = this.particle;
    e2.bubble.inRange = false, e2.links = [];
    for (const [, i2] of this.container.plugins) {
      if (e2.destroyed)
        break;
      i2.particleUpdate && i2.particleUpdate(e2, t2);
    }
    e2.destroyed || (this.moveParticle(t2), this.moveParallax());
  }
  moveParticle(t2) {
    var e2, i2;
    const o2 = this.particle, s2 = o2.options;
    if (!s2.move.enable)
      return;
    const n2 = this.container, a2 = this.getProximitySpeedFactor(), r2 = ((e2 = o2.moveSpeed) !== null && e2 !== void 0 ? e2 : E.getRangeValue(o2.options.move.speed) * n2.retina.pixelRatio) * n2.retina.reduceFactor, l2 = E.getRangeMax(o2.options.size.value) * n2.retina.pixelRatio, c2 = r2 / 2 * (s2.move.size ? o2.getRadius() / l2 : 1) * a2 * t2.factor, d2 = (i2 = o2.moveDrift) !== null && i2 !== void 0 ? i2 : E.getRangeValue(o2.options.move.drift) * n2.retina.pixelRatio;
    this.applyPath(t2);
    const h2 = s2.move.gravity;
    h2.enable && (o2.velocity.y += h2.acceleration * t2.factor / (60 * c2)), o2.velocity.x += d2 * t2.factor / (60 * c2);
    const u2 = 1 - o2.options.move.decay;
    o2.velocity.multTo(u2);
    const v2 = o2.velocity.mult(c2);
    h2.enable && v2.y >= h2.maxSpeed && h2.maxSpeed > 0 && (v2.y = h2.maxSpeed, o2.velocity.y = v2.y / c2), o2.position.addTo(v2), s2.move.vibrate && (o2.position.x += Math.sin(o2.position.x * Math.cos(o2.position.y)), o2.position.y += Math.cos(o2.position.y * Math.sin(o2.position.x)));
    const p2 = o2.initialPosition, y2 = E.getDistance(p2, o2.position);
    o2.maxDistance && (y2 >= o2.maxDistance && !o2.misplaced ? (o2.misplaced = y2 > o2.maxDistance, o2.velocity.x = o2.velocity.y / 2 - o2.velocity.x, o2.velocity.y = o2.velocity.x / 2 - o2.velocity.y) : y2 < o2.maxDistance && o2.misplaced ? o2.misplaced = false : o2.misplaced && ((o2.position.x < p2.x && o2.velocity.x < 0 || o2.position.x > p2.x && o2.velocity.x > 0) && (o2.velocity.x *= -Math.random()), (o2.position.y < p2.y && o2.velocity.y < 0 || o2.position.y > p2.y && o2.velocity.y > 0) && (o2.velocity.y *= -Math.random())));
  }
  applyPath(t2) {
    const e2 = this.particle, i2 = e2.options.move.path;
    if (!i2.enable)
      return;
    const o2 = this.container;
    if (e2.lastPathTime <= e2.pathDelay)
      return void (e2.lastPathTime += t2.value);
    let s2 = o2.pathGenerator;
    if (i2.generator) {
      const t3 = vt.getPathGenerator(i2.generator);
      t3 && (s2 = t3);
    }
    const n2 = s2.generate(e2);
    e2.velocity.addTo(n2), i2.clamp && (e2.velocity.x = E.clamp(e2.velocity.x, -1, 1), e2.velocity.y = E.clamp(e2.velocity.y, -1, 1)), e2.lastPathTime -= e2.pathDelay;
  }
  moveParallax() {
    const t2 = this.container, e2 = t2.actualOptions;
    if (J.isSsr() || !e2.interactivity.events.onHover.parallax.enable)
      return;
    const i2 = this.particle, o2 = e2.interactivity.events.onHover.parallax.force, s2 = t2.interactivity.mouse.position;
    if (!s2)
      return;
    const n2 = t2.canvas.size.width / 2, a2 = t2.canvas.size.height / 2, r2 = e2.interactivity.events.onHover.parallax.smooth, l2 = i2.getRadius() / o2, c2 = (s2.x - n2) * l2, d2 = (s2.y - a2) * l2;
    i2.offset.x += (c2 - i2.offset.x) / r2, i2.offset.y += (d2 - i2.offset.y) / r2;
  }
  getProximitySpeedFactor() {
    const t2 = this.container, e2 = t2.actualOptions;
    if (!J.isInArray(F.slow, e2.interactivity.events.onHover.mode))
      return 1;
    const i2 = this.container.interactivity.mouse.position;
    if (!i2)
      return 1;
    const o2 = this.particle.getPosition(), s2 = E.getDistance(i2, o2), n2 = t2.retina.slowModeRadius;
    if (s2 > n2)
      return 1;
    return (s2 / n2 || 0) / e2.interactivity.modes.slow.factor;
  }
}
class we {
  constructor(t2, e2, i2, o2) {
    var s2, n2, a2, r2, l2, c2, d2, h2, u2;
    this.id = t2, this.container = e2, this.links = [], this.fill = true, this.close = true, this.lastPathTime = 0, this.destroyed = false, this.unbreakable = false, this.splitCount = 0, this.misplaced = false, this.loops = {opacity: 0, size: 0};
    const v2 = e2.retina.pixelRatio, p2 = e2.actualOptions, y2 = new me();
    y2.load(p2.particles);
    const f2 = y2.shape.type, m2 = y2.reduceDuplicates;
    if (this.shape = f2 instanceof Array ? J.itemFromArray(f2, this.id, m2) : f2, o2 == null ? void 0 : o2.shape) {
      if (o2.shape.type) {
        const t4 = o2.shape.type;
        this.shape = t4 instanceof Array ? J.itemFromArray(t4, this.id, m2) : t4;
      }
      const t3 = new Yt();
      if (t3.load(o2.shape), this.shape) {
        const e3 = t3.options[this.shape];
        e3 && (this.shapeData = J.deepExtend({}, e3 instanceof Array ? J.itemFromArray(e3, this.id, m2) : e3));
      }
    } else {
      const t3 = y2.shape.options[this.shape];
      t3 && (this.shapeData = J.deepExtend({}, t3 instanceof Array ? J.itemFromArray(t3, this.id, m2) : t3));
    }
    o2 !== void 0 && y2.load(o2), ((s2 = this.shapeData) === null || s2 === void 0 ? void 0 : s2.particles) !== void 0 && y2.load((n2 = this.shapeData) === null || n2 === void 0 ? void 0 : n2.particles), this.fill = (r2 = (a2 = this.shapeData) === null || a2 === void 0 ? void 0 : a2.fill) !== null && r2 !== void 0 ? r2 : this.fill, this.close = (c2 = (l2 = this.shapeData) === null || l2 === void 0 ? void 0 : l2.close) !== null && c2 !== void 0 ? c2 : this.close, this.options = y2, this.pathDelay = 1e3 * E.getValue(this.options.move.path.delay), e2.retina.initParticle(this);
    const g2 = this.options.color, b2 = this.options.size, w2 = E.getValue(b2) * e2.retina.pixelRatio, x2 = typeof b2.random == "boolean" ? b2.random : b2.random.enable;
    this.size = {value: w2}, this.direction = this.options.move.direction, this.bubble = {inRange: false}, this.initialVelocity = this.calculateVelocity(), this.velocity = this.initialVelocity.copy();
    const k2 = this.options.rotate;
    this.rotate = {value: E.getRangeValue(k2.value) * Math.PI / 180};
    let P2 = k2.direction;
    if (P2 === A.random) {
      P2 = Math.floor(2 * Math.random()) > 0 ? A.counterClockwise : A.clockwise;
    }
    switch (P2) {
      case A.counterClockwise:
      case "counterClockwise":
        this.rotate.status = q.decreasing;
        break;
      case A.clockwise:
        this.rotate.status = q.increasing;
    }
    const M2 = this.options.rotate.animation;
    M2.enable && (this.rotate.velocity = M2.speed / 360 * e2.retina.reduceFactor, M2.sync || (this.rotate.velocity *= Math.random()));
    const R2 = this.options.size.animation;
    if (R2.enable) {
      if (this.size.status = q.increasing, !x2)
        switch (R2.startValue) {
          case G.min:
            this.size.value = R2.minimumValue * v2;
            break;
          case G.random:
            this.size.value = E.randomInRange(E.setRangeValue(R2.minimumValue * v2, this.size.value));
            break;
          case G.max:
          default:
            this.size.status = q.decreasing;
        }
      this.size.velocity = ((d2 = this.sizeAnimationSpeed) !== null && d2 !== void 0 ? d2 : e2.retina.sizeAnimationSpeed) / 100 * e2.retina.reduceFactor, R2.sync || (this.size.velocity *= Math.random());
    }
    const S2 = tt.colorToHsl(g2, this.id, m2);
    if (S2) {
      this.color = {h: {value: S2.h}, s: {value: S2.s}, l: {value: S2.l}};
      const t3 = this.options.color.animation;
      this.setColorAnimation(t3.h, this.color.h), this.setColorAnimation(t3.s, this.color.s), this.setColorAnimation(t3.l, this.color.l);
    }
    this.position = this.calcPosition(this.container, i2), this.initialPosition = this.position.copy(), this.offset = T.create(0, 0);
    const C2 = this.options.opacity, z2 = typeof C2.random == "boolean" ? C2.random : C2.random.enable;
    this.opacity = {value: E.getValue(C2)};
    const D2 = C2.animation;
    if (D2.enable) {
      if (this.opacity.status = q.increasing, !z2)
        switch (D2.startValue) {
          case G.min:
            this.opacity.value = D2.minimumValue;
            break;
          case G.random:
            this.opacity.value = E.randomInRange(E.setRangeValue(D2.minimumValue, this.opacity.value));
            break;
          case G.max:
          default:
            this.opacity.status = q.decreasing;
        }
      this.opacity.velocity = D2.speed / 100 * e2.retina.reduceFactor, D2.sync || (this.opacity.velocity *= Math.random());
    }
    this.sides = 24;
    let O2 = e2.drawers.get(this.shape);
    O2 || (O2 = vt.getShapeDrawer(this.shape), O2 && e2.drawers.set(this.shape, O2));
    const I2 = O2 == null ? void 0 : O2.getSidesCount;
    I2 && (this.sides = I2(this));
    const F2 = this.loadImageShape(e2, O2);
    F2 && (this.image = F2.image, this.fill = F2.fill, this.close = F2.close), this.stroke = this.options.stroke instanceof Array ? J.itemFromArray(this.options.stroke, this.id, m2) : this.options.stroke, this.strokeWidth = this.stroke.width * e2.retina.pixelRatio;
    const L2 = (h2 = tt.colorToHsl(this.stroke.color)) !== null && h2 !== void 0 ? h2 : this.getFillColor();
    if (L2) {
      this.strokeColor = {h: {value: L2.h}, s: {value: L2.s}, l: {value: L2.l}};
      const t3 = (u2 = this.stroke.color) === null || u2 === void 0 ? void 0 : u2.animation;
      t3 && this.strokeColor && (this.setColorAnimation(t3.h, this.strokeColor.h), this.setColorAnimation(t3.s, this.strokeColor.s), this.setColorAnimation(t3.l, this.strokeColor.l));
    }
    const V2 = y2.life;
    this.lifeDelay = e2.retina.reduceFactor ? E.getValue(V2.delay) * (V2.delay.sync ? 1 : Math.random()) / e2.retina.reduceFactor * 1e3 : 0, this.lifeDelayTime = 0, this.lifeDuration = e2.retina.reduceFactor ? E.getValue(V2.duration) * (V2.duration.sync ? 1 : Math.random()) / e2.retina.reduceFactor * 1e3 : 0, this.lifeTime = 0, this.livesRemaining = y2.life.count, this.spawning = this.lifeDelay > 0, this.lifeDuration <= 0 && (this.lifeDuration = -1), this.livesRemaining <= 0 && (this.livesRemaining = -1), this.shadowColor = tt.colorToRgb(this.options.shadow.color), this.updater = new zt(e2, this), this.infecter = new ge(e2), this.mover = new be(e2, this), O2 && O2.particleInit && O2.particleInit(e2, this);
  }
  move(t2) {
    this.mover.move(t2);
  }
  update(t2) {
    this.updater.update(t2);
  }
  draw(t2) {
    this.container.canvas.drawParticle(this, t2);
  }
  getPosition() {
    return this.position.add(this.offset);
  }
  getRadius() {
    return this.bubble.radius || this.size.value;
  }
  getMass() {
    const t2 = this.getRadius();
    return Math.pow(t2, 2) * Math.PI / 2;
  }
  getFillColor() {
    var t2;
    return (t2 = this.bubble.color) !== null && t2 !== void 0 ? t2 : tt.getHslFromAnimation(this.color);
  }
  getStrokeColor() {
    var t2, e2;
    return (e2 = (t2 = this.bubble.color) !== null && t2 !== void 0 ? t2 : tt.getHslFromAnimation(this.strokeColor)) !== null && e2 !== void 0 ? e2 : this.getFillColor();
  }
  destroy(t2) {
    if (this.destroyed = true, this.bubble.inRange = false, this.links = [], this.unbreakable)
      return;
    this.destroyed = true, this.bubble.inRange = false;
    for (const [, e2] of this.container.plugins)
      e2.particleDestroyed && e2.particleDestroyed(this, t2);
    if (t2)
      return;
    this.options.destroy.mode === O.split && this.split();
  }
  reset() {
    this.loops.opacity = 0, this.loops.size = 0;
  }
  split() {
    const t2 = this.options.destroy.split;
    if (t2.count >= 0 && this.splitCount++ > t2.count)
      return;
    const e2 = E.getRangeValue(t2.rate.value);
    for (let t3 = 0; t3 < e2; t3++)
      this.container.particles.addSplitParticle(this);
  }
  setColorAnimation(t2, e2) {
    if (t2.enable) {
      if (e2.velocity = t2.speed / 100 * this.container.retina.reduceFactor, t2.sync)
        return;
      e2.status = q.increasing, e2.velocity *= Math.random(), e2.value && (e2.value *= Math.random());
    } else
      e2.velocity = 0;
  }
  calcPosition(t2, e2, i2 = 0) {
    var o2, s2;
    for (const [, i3] of t2.plugins) {
      const t3 = i3.particlePosition !== void 0 ? i3.particlePosition(e2, this) : void 0;
      if (t3 !== void 0)
        return T.create(t3.x, t3.y);
    }
    const n2 = T.create((o2 = e2 == null ? void 0 : e2.x) !== null && o2 !== void 0 ? o2 : Math.random() * t2.canvas.size.width, (s2 = e2 == null ? void 0 : e2.y) !== null && s2 !== void 0 ? s2 : Math.random() * t2.canvas.size.height), a2 = this.options.move.outMode;
    return (J.isInArray(a2, V.bounce) || J.isInArray(a2, V.bounceHorizontal)) && (n2.x > t2.canvas.size.width - 2 * this.size.value ? n2.x -= this.size.value : n2.x < 2 * this.size.value && (n2.x += this.size.value)), (J.isInArray(a2, V.bounce) || J.isInArray(a2, V.bounceVertical)) && (n2.y > t2.canvas.size.height - 2 * this.size.value ? n2.y -= this.size.value : n2.y < 2 * this.size.value && (n2.y += this.size.value)), this.checkOverlap(n2, i2) ? this.calcPosition(t2, void 0, i2 + 1) : n2;
  }
  checkOverlap(t2, e2 = 0) {
    const i2 = this.options.collisions.overlap;
    if (!i2.enable) {
      const o2 = i2.retries;
      if (o2 >= 0 && e2 > o2)
        throw new Error("Particle is overlapping and can't be placed");
      let s2 = false;
      for (const e3 of this.container.particles.array)
        if (E.getDistance(t2, e3.position) < this.size.value + e3.size.value) {
          s2 = true;
          break;
        }
      return s2;
    }
    return false;
  }
  calculateVelocity() {
    const t2 = E.getParticleBaseVelocity(this.direction).copy(), e2 = this.options.move;
    let i2, o2 = Math.PI / 4;
    typeof e2.angle == "number" ? i2 = Math.PI / 180 * e2.angle : (i2 = Math.PI / 180 * e2.angle.value, o2 = Math.PI / 180 * e2.angle.offset);
    const s2 = {left: Math.sin(o2 + i2 / 2) - Math.sin(o2 - i2 / 2), right: Math.cos(o2 + i2 / 2) - Math.cos(o2 - i2 / 2)};
    return e2.straight && !e2.random || (t2.x += E.randomInRange(E.setRangeValue(s2.left, s2.right)) / 2, t2.y += E.randomInRange(E.setRangeValue(s2.left, s2.right)) / 2), t2;
  }
  loadImageShape(t2, e2) {
    var i2, o2, s2, n2, a2;
    if (this.shape !== W.image && this.shape !== W.images)
      return;
    const r2 = e2.getImages(t2).images, l2 = this.shapeData, c2 = (i2 = r2.find((t3) => t3.source === l2.src)) !== null && i2 !== void 0 ? i2 : r2[0], d2 = this.getFillColor();
    let h2;
    if (!c2)
      return;
    if (c2.svgData !== void 0 && l2.replaceColor && d2) {
      const t3 = tt.replaceColorSvg(c2, d2, this.opacity.value), e3 = new Blob([t3], {type: "image/svg+xml"}), i3 = URL || window.URL || window.webkitURL || window, s3 = i3.createObjectURL(e3), n3 = new Image();
      h2 = {data: c2, loaded: false, ratio: l2.width / l2.height, replaceColor: (o2 = l2.replaceColor) !== null && o2 !== void 0 ? o2 : l2.replace_color, source: l2.src}, n3.addEventListener("load", () => {
        this.image && (this.image.loaded = true, c2.element = n3), i3.revokeObjectURL(s3);
      }), n3.addEventListener("error", () => {
        i3.revokeObjectURL(s3), J.loadImage(l2.src).then((t4) => {
          this.image && t4 && (c2.element = t4.element, this.image.loaded = true);
        });
      }), n3.src = s3;
    } else
      h2 = {data: c2, loaded: true, ratio: l2.width / l2.height, replaceColor: (s2 = l2.replaceColor) !== null && s2 !== void 0 ? s2 : l2.replace_color, source: l2.src};
    h2.ratio || (h2.ratio = 1);
    return {image: h2, fill: (n2 = l2.fill) !== null && n2 !== void 0 ? n2 : this.fill, close: (a2 = l2.close) !== null && a2 !== void 0 ? a2 : this.close};
  }
}
class xe {
  constructor(t2) {
    this.container = t2;
  }
  isEnabled() {
    const t2 = this.container, e2 = t2.interactivity.mouse, i2 = t2.actualOptions.interactivity.events;
    if (!i2.onHover.enable || !e2.position)
      return false;
    const o2 = i2.onHover.mode;
    return J.isInArray(F.grab, o2);
  }
  reset() {
  }
  interact() {
    var t2;
    const e2 = this.container, i2 = e2.actualOptions.interactivity;
    if (i2.events.onHover.enable && e2.interactivity.status === Q.mouseMoveEvent) {
      const o2 = e2.interactivity.mouse.position;
      if (o2 === void 0)
        return;
      const s2 = e2.retina.grabModeDistance, n2 = e2.particles.quadTree.queryCircle(o2, s2);
      for (const a2 of n2) {
        const n3 = a2.getPosition(), r2 = E.getDistance(n3, o2);
        if (r2 <= s2) {
          const n4 = i2.modes.grab.links, l2 = n4.opacity, c2 = l2 - r2 * l2 / s2;
          if (c2 > 0) {
            const i3 = (t2 = n4.color) !== null && t2 !== void 0 ? t2 : a2.options.links.color;
            if (!e2.particles.grabLineColor) {
              const t3 = e2.actualOptions.interactivity.modes.grab.links;
              e2.particles.grabLineColor = tt.getLinkRandomColor(i3, t3.blink, t3.consent);
            }
            const s3 = tt.getLinkColor(a2, void 0, e2.particles.grabLineColor);
            if (s3 === void 0)
              return;
            e2.canvas.drawGrabLine(a2, s3, c2, o2);
          }
        }
      }
    }
  }
}
class ke {
  constructor(t2) {
    this.container = t2;
  }
  isEnabled() {
    const t2 = this.container, e2 = t2.actualOptions, i2 = t2.interactivity.mouse, o2 = e2.interactivity.events, s2 = o2.onDiv, n2 = J.isDivModeEnabled(I.repulse, s2);
    if (!(n2 || o2.onHover.enable && i2.position || o2.onClick.enable && i2.clickPosition))
      return false;
    const a2 = o2.onHover.mode, r2 = o2.onClick.mode;
    return J.isInArray(F.repulse, a2) || J.isInArray(D.repulse, r2) || n2;
  }
  reset() {
  }
  interact() {
    const t2 = this.container, e2 = t2.actualOptions, i2 = t2.interactivity.status === Q.mouseMoveEvent, o2 = e2.interactivity.events, s2 = o2.onHover.enable, n2 = o2.onHover.mode, a2 = o2.onClick.enable, r2 = o2.onClick.mode, l2 = o2.onDiv;
    i2 && s2 && J.isInArray(F.repulse, n2) ? this.hoverRepulse() : a2 && J.isInArray(D.repulse, r2) ? this.clickRepulse() : J.divModeExecute(I.repulse, l2, (t3, e3) => this.singleSelectorRepulse(t3, e3));
  }
  singleSelectorRepulse(t2, e2) {
    const i2 = this.container, o2 = document.querySelectorAll(t2);
    o2.length && o2.forEach((t3) => {
      const o3 = t3, s2 = i2.retina.pixelRatio, n2 = {x: (o3.offsetLeft + o3.offsetWidth / 2) * s2, y: (o3.offsetTop + o3.offsetHeight / 2) * s2}, a2 = o3.offsetWidth / 2 * s2, r2 = e2.type === N.circle ? new st(n2.x, n2.y, a2) : new nt(o3.offsetLeft * s2, o3.offsetTop * s2, o3.offsetWidth * s2, o3.offsetHeight * s2), l2 = i2.actualOptions.interactivity.modes.repulse.divs, c2 = J.divMode(l2, o3);
      this.processRepulse(n2, a2, r2, c2);
    });
  }
  hoverRepulse() {
    const t2 = this.container, e2 = t2.interactivity.mouse.position;
    if (!e2)
      return;
    const i2 = t2.retina.repulseModeDistance;
    this.processRepulse(e2, i2, new st(e2.x, e2.y, i2));
  }
  processRepulse(t2, e2, i2, o2) {
    var s2;
    const n2 = this.container, a2 = n2.particles.quadTree.query(i2);
    for (const i3 of a2) {
      const {dx: a3, dy: r2, distance: l2} = E.getDistances(i3.position, t2), c2 = {x: a3 / l2, y: r2 / l2}, d2 = 100 * ((s2 = o2 == null ? void 0 : o2.speed) !== null && s2 !== void 0 ? s2 : n2.actualOptions.interactivity.modes.repulse.speed), h2 = E.clamp((1 - Math.pow(l2 / e2, 2)) * d2, 0, 50);
      i3.position.x += c2.x * h2, i3.position.y += c2.y * h2;
    }
  }
  clickRepulse() {
    const t2 = this.container;
    if (t2.repulse.finish || (t2.repulse.count || (t2.repulse.count = 0), t2.repulse.count++, t2.repulse.count === t2.particles.count && (t2.repulse.finish = true)), t2.repulse.clicking) {
      const e2 = t2.retina.repulseModeDistance, i2 = Math.pow(e2 / 6, 3), o2 = t2.interactivity.mouse.clickPosition;
      if (o2 === void 0)
        return;
      const s2 = new st(o2.x, o2.y, i2), n2 = t2.particles.quadTree.query(s2);
      for (const e3 of n2) {
        const {dx: s3, dy: n3, distance: a2} = E.getDistances(o2, e3.position), r2 = a2 * a2;
        if (r2 <= i2) {
          t2.repulse.particles.push(e3);
          const o3 = t2.actualOptions.interactivity.modes.repulse.speed, a3 = T.create(s3, n3);
          a3.length = -i2 * o3 / r2, e3.velocity.setTo(a3);
        }
      }
    } else if (t2.repulse.clicking === false) {
      for (const e2 of t2.repulse.particles)
        e2.velocity.setTo(e2.initialVelocity);
      t2.repulse.particles = [];
    }
  }
}
function Pe(t2, e2, i2, o2) {
  if (e2 > i2) {
    const s2 = t2 + (e2 - i2) * o2;
    return E.clamp(s2, t2, e2);
  }
  if (e2 < i2) {
    const s2 = t2 - (i2 - e2) * o2;
    return E.clamp(s2, e2, t2);
  }
}
class Me {
  constructor(t2) {
    this.container = t2;
  }
  isEnabled() {
    const t2 = this.container, e2 = t2.actualOptions, i2 = t2.interactivity.mouse, o2 = e2.interactivity.events, s2 = o2.onDiv, n2 = J.isDivModeEnabled(I.bubble, s2);
    if (!(n2 || o2.onHover.enable && i2.position || o2.onClick.enable && i2.clickPosition))
      return false;
    const a2 = o2.onHover.mode, r2 = o2.onClick.mode;
    return J.isInArray(F.bubble, a2) || J.isInArray(D.bubble, r2) || n2;
  }
  reset(t2, e2) {
    t2.bubble.inRange && !e2 || (delete t2.bubble.div, delete t2.bubble.opacity, delete t2.bubble.radius, delete t2.bubble.color);
  }
  interact() {
    const t2 = this.container.actualOptions.interactivity.events, e2 = t2.onHover, i2 = t2.onClick, o2 = e2.enable, s2 = e2.mode, n2 = i2.enable, a2 = i2.mode, r2 = t2.onDiv;
    o2 && J.isInArray(F.bubble, s2) ? this.hoverBubble() : n2 && J.isInArray(D.bubble, a2) ? this.clickBubble() : J.divModeExecute(I.bubble, r2, (t3, e3) => this.singleSelectorHover(t3, e3));
  }
  singleSelectorHover(t2, e2) {
    const i2 = this.container, o2 = document.querySelectorAll(t2);
    o2.length && o2.forEach((t3) => {
      const o3 = t3, s2 = i2.retina.pixelRatio, n2 = {x: (o3.offsetLeft + o3.offsetWidth / 2) * s2, y: (o3.offsetTop + o3.offsetHeight / 2) * s2}, a2 = o3.offsetWidth / 2 * s2, r2 = e2.type === N.circle ? new st(n2.x, n2.y, a2) : new nt(o3.offsetLeft * s2, o3.offsetTop * s2, o3.offsetWidth * s2, o3.offsetHeight * s2), l2 = i2.particles.quadTree.query(r2);
      for (const t4 of l2) {
        if (!r2.contains(t4.getPosition()))
          continue;
        t4.bubble.inRange = true;
        const e3 = i2.actualOptions.interactivity.modes.bubble.divs, s3 = J.divMode(e3, o3);
        t4.bubble.div && t4.bubble.div === o3 || (this.reset(t4, true), t4.bubble.div = o3), this.hoverBubbleSize(t4, 1, s3), this.hoverBubbleOpacity(t4, 1, s3), this.hoverBubbleColor(t4, s3);
      }
    });
  }
  process(t2, e2, i2, o2) {
    const s2 = this.container, n2 = o2.bubbleObj.optValue;
    if (n2 === void 0)
      return;
    const a2 = s2.actualOptions.interactivity.modes.bubble.duration, r2 = s2.retina.bubbleModeDistance, l2 = o2.particlesObj.optValue, c2 = o2.bubbleObj.value, d2 = o2.particlesObj.value || 0, h2 = o2.type;
    if (n2 !== l2)
      if (s2.bubble.durationEnd)
        c2 && (h2 === $.size && delete t2.bubble.radius, h2 === $.opacity && delete t2.bubble.opacity);
      else if (e2 <= r2) {
        if ((c2 != null ? c2 : d2) !== n2) {
          const e3 = d2 - i2 * (d2 - n2) / a2;
          h2 === $.size && (t2.bubble.radius = e3), h2 === $.opacity && (t2.bubble.opacity = e3);
        }
      } else
        h2 === $.size && delete t2.bubble.radius, h2 === $.opacity && delete t2.bubble.opacity;
  }
  clickBubble() {
    const t2 = this.container, e2 = t2.actualOptions, i2 = t2.interactivity.mouse.clickPosition;
    if (i2 === void 0)
      return;
    const o2 = t2.retina.bubbleModeDistance, s2 = t2.particles.quadTree.queryCircle(i2, o2);
    for (const o3 of s2) {
      if (!t2.bubble.clicking)
        continue;
      o3.bubble.inRange = !t2.bubble.durationEnd;
      const s3 = o3.getPosition(), n2 = E.getDistance(s3, i2), a2 = (new Date().getTime() - (t2.interactivity.mouse.clickTime || 0)) / 1e3;
      a2 > e2.interactivity.modes.bubble.duration && (t2.bubble.durationEnd = true), a2 > 2 * e2.interactivity.modes.bubble.duration && (t2.bubble.clicking = false, t2.bubble.durationEnd = false);
      const r2 = {bubbleObj: {optValue: t2.retina.bubbleModeSize, value: o3.bubble.radius}, particlesObj: {optValue: E.getRangeMax(o3.options.size.value) * t2.retina.pixelRatio, value: o3.size.value}, type: $.size};
      this.process(o3, n2, a2, r2);
      const l2 = {bubbleObj: {optValue: e2.interactivity.modes.bubble.opacity, value: o3.bubble.opacity}, particlesObj: {optValue: E.getRangeMax(o3.options.opacity.value), value: o3.opacity.value}, type: $.opacity};
      this.process(o3, n2, a2, l2), t2.bubble.durationEnd ? delete o3.bubble.color : n2 <= t2.retina.bubbleModeDistance ? this.hoverBubbleColor(o3) : delete o3.bubble.color;
    }
  }
  hoverBubble() {
    const t2 = this.container, e2 = t2.interactivity.mouse.position;
    if (e2 === void 0)
      return;
    const i2 = t2.retina.bubbleModeDistance, o2 = t2.particles.quadTree.queryCircle(e2, i2);
    for (const s2 of o2) {
      s2.bubble.inRange = true;
      const o3 = s2.getPosition(), n2 = E.getDistance(o3, e2), a2 = 1 - n2 / i2;
      n2 <= i2 ? a2 >= 0 && t2.interactivity.status === Q.mouseMoveEvent && (this.hoverBubbleSize(s2, a2), this.hoverBubbleOpacity(s2, a2), this.hoverBubbleColor(s2)) : this.reset(s2), t2.interactivity.status === Q.mouseLeaveEvent && this.reset(s2);
    }
  }
  hoverBubbleSize(t2, e2, i2) {
    const o2 = this.container, s2 = (i2 == null ? void 0 : i2.size) ? i2.size * o2.retina.pixelRatio : o2.retina.bubbleModeSize;
    if (s2 === void 0)
      return;
    const n2 = E.getRangeMax(t2.options.size.value) * o2.retina.pixelRatio, a2 = Pe(t2.size.value, s2, n2, e2);
    a2 !== void 0 && (t2.bubble.radius = a2);
  }
  hoverBubbleOpacity(t2, e2, i2) {
    var o2;
    const s2 = this.container.actualOptions, n2 = (o2 = i2 == null ? void 0 : i2.opacity) !== null && o2 !== void 0 ? o2 : s2.interactivity.modes.bubble.opacity;
    if (n2 === void 0)
      return;
    const a2 = t2.options.opacity.value, r2 = Pe(t2.opacity.value, n2, E.getRangeMax(a2), e2);
    r2 !== void 0 && (t2.bubble.opacity = r2);
  }
  hoverBubbleColor(t2, e2) {
    var i2;
    const o2 = this.container.actualOptions;
    if (t2.bubble.color === void 0) {
      const s2 = (i2 = e2 == null ? void 0 : e2.color) !== null && i2 !== void 0 ? i2 : o2.interactivity.modes.bubble.color;
      if (s2 === void 0)
        return;
      const n2 = s2 instanceof Array ? J.itemFromArray(s2) : s2;
      t2.bubble.color = tt.colorToHsl(n2);
    }
  }
}
class Re {
  constructor(t2) {
    this.container = t2;
  }
  isEnabled() {
    const t2 = this.container, e2 = t2.interactivity.mouse, i2 = t2.actualOptions.interactivity.events;
    if (!i2.onHover.enable || !e2.position)
      return false;
    const o2 = i2.onHover.mode;
    return J.isInArray(F.connect, o2);
  }
  reset() {
  }
  interact() {
    const t2 = this.container;
    if (t2.actualOptions.interactivity.events.onHover.enable && t2.interactivity.status === "mousemove") {
      const e2 = t2.interactivity.mouse.position;
      if (!e2)
        return;
      const i2 = Math.abs(t2.retina.connectModeRadius), o2 = t2.particles.quadTree.queryCircle(e2, i2);
      let s2 = 0;
      for (const e3 of o2) {
        const i3 = e3.getPosition();
        for (const n2 of o2.slice(s2 + 1)) {
          const o3 = n2.getPosition(), s3 = Math.abs(t2.retina.connectModeDistance), a2 = Math.abs(i3.x - o3.x), r2 = Math.abs(i3.y - o3.y);
          a2 < s3 && r2 < s3 && t2.canvas.drawConnectLine(e3, n2);
        }
        ++s2;
      }
    }
  }
}
class Se {
  constructor(t2) {
    this.container = t2;
  }
  isEnabled(t2) {
    return t2.options.links.enable;
  }
  reset() {
  }
  interact(t2) {
    var e2;
    const i2 = this.container, o2 = t2.options.links, s2 = o2.opacity, n2 = (e2 = t2.linksDistance) !== null && e2 !== void 0 ? e2 : i2.retina.linksDistance, a2 = i2.canvas.size, r2 = o2.warp, l2 = t2.getPosition(), c2 = r2 ? new at(l2.x, l2.y, n2, a2) : new st(l2.x, l2.y, n2), d2 = i2.particles.quadTree.query(c2);
    for (const e3 of d2) {
      const c3 = e3.options.links;
      if (t2 === e3 || !c3.enable || o2.id !== c3.id || e3.spawning || e3.destroyed)
        continue;
      const d3 = e3.getPosition();
      let h2 = E.getDistance(l2, d3);
      if (r2 && h2 > n2) {
        const t3 = {x: d3.x - a2.width, y: d3.y};
        if (h2 = E.getDistance(l2, t3), h2 > n2) {
          const t4 = {x: d3.x - a2.width, y: d3.y - a2.height};
          if (h2 = E.getDistance(l2, t4), h2 > n2) {
            const t5 = {x: d3.x, y: d3.y - a2.height};
            h2 = E.getDistance(l2, t5);
          }
        }
      }
      if (h2 > n2)
        return;
      const u2 = (1 - h2 / n2) * s2, v2 = t2.options.links;
      let p2 = v2.id !== void 0 ? i2.particles.linksColors.get(v2.id) : i2.particles.linksColor;
      if (!p2) {
        const t3 = v2.color;
        p2 = tt.getLinkRandomColor(t3, v2.blink, v2.consent), v2.id !== void 0 ? i2.particles.linksColors.set(v2.id, p2) : i2.particles.linksColor = p2;
      }
      e3.links.map((t3) => t3.destination).indexOf(t2) === -1 && t2.links.map((t3) => t3.destination).indexOf(e3) === -1 && t2.links.push({destination: e3, opacity: u2});
    }
  }
}
class Ce {
  constructor(t2) {
    this.container = t2;
  }
  interact(t2) {
    var e2;
    const i2 = this.container, o2 = (e2 = t2.linksDistance) !== null && e2 !== void 0 ? e2 : i2.retina.linksDistance, s2 = t2.getPosition(), n2 = i2.particles.quadTree.queryCircle(s2, o2);
    for (const e3 of n2) {
      if (t2 === e3 || !e3.options.move.attract.enable || e3.destroyed || e3.spawning)
        continue;
      const i3 = e3.getPosition(), {dx: o3, dy: n3} = E.getDistances(s2, i3), a2 = t2.options.move.attract.rotate, r2 = o3 / (1e3 * a2.x), l2 = n3 / (1e3 * a2.y);
      t2.velocity.x -= r2, t2.velocity.y -= l2, e3.velocity.x += r2, e3.velocity.y += l2;
    }
  }
  isEnabled(t2) {
    return t2.options.move.attract.enable;
  }
  reset() {
  }
}
class ze {
  constructor(t2) {
    this.container = t2;
  }
  isEnabled(t2) {
    return t2.options.collisions.enable;
  }
  reset() {
  }
  interact(t2) {
    const e2 = this.container, i2 = t2.getPosition(), o2 = e2.particles.quadTree.queryCircle(i2, 2 * t2.getRadius());
    for (const e3 of o2) {
      if (t2 === e3 || !e3.options.collisions.enable || t2.options.collisions.mode !== e3.options.collisions.mode || e3.destroyed || e3.spawning)
        continue;
      const o3 = e3.getPosition();
      E.getDistance(i2, o3) <= t2.getRadius() + e3.getRadius() && this.resolveCollision(t2, e3);
    }
  }
  resolveCollision(t2, e2) {
    switch (t2.options.collisions.mode) {
      case L.absorb:
        this.absorb(t2, e2);
        break;
      case L.bounce:
        !function(t3, e3) {
          J.circleBounce(J.circleBounceDataFromParticle(t3), J.circleBounceDataFromParticle(e3));
        }(t2, e2);
        break;
      case L.destroy:
        !function(t3, e3) {
          t3.getRadius() === void 0 && e3.getRadius() !== void 0 ? t3.destroy() : t3.getRadius() !== void 0 && e3.getRadius() === void 0 ? e3.destroy() : t3.getRadius() !== void 0 && e3.getRadius() !== void 0 && (t3.getRadius() >= e3.getRadius() ? e3.destroy() : t3.destroy());
        }(t2, e2);
    }
  }
  absorb(t2, e2) {
    const i2 = this.container, o2 = i2.actualOptions.fpsLimit / 1e3;
    if (t2.getRadius() === void 0 && e2.getRadius() !== void 0)
      t2.destroy();
    else if (t2.getRadius() !== void 0 && e2.getRadius() === void 0)
      e2.destroy();
    else if (t2.getRadius() !== void 0 && e2.getRadius() !== void 0)
      if (t2.getRadius() >= e2.getRadius()) {
        const s2 = E.clamp(t2.getRadius() / e2.getRadius(), 0, e2.getRadius()) * o2;
        t2.size.value += s2, e2.size.value -= s2, e2.getRadius() <= i2.retina.pixelRatio && (e2.size.value = 0, e2.destroy());
      } else {
        const s2 = E.clamp(e2.getRadius() / t2.getRadius(), 0, t2.getRadius()) * o2;
        t2.size.value -= s2, e2.size.value += s2, t2.getRadius() <= i2.retina.pixelRatio && (t2.size.value = 0, t2.destroy());
      }
  }
}
class Ae {
  constructor(t2) {
    this.container = t2;
  }
  isEnabled() {
    return this.container.actualOptions.infection.enable;
  }
  reset() {
  }
  interact(t2, e2) {
    var i2, o2;
    const s2 = t2.infecter;
    if (s2.updateInfection(e2.value), s2.infectionStage === void 0)
      return;
    const n2 = this.container, a2 = n2.actualOptions.infection;
    if (!a2.enable || a2.stages.length < 1)
      return;
    const r2 = a2.stages[s2.infectionStage], l2 = n2.retina.pixelRatio, c2 = 2 * t2.getRadius() + r2.radius * l2, d2 = t2.getPosition(), h2 = (i2 = r2.infectedStage) !== null && i2 !== void 0 ? i2 : s2.infectionStage, u2 = n2.particles.quadTree.queryCircle(d2, c2), v2 = r2.rate, p2 = u2.length;
    for (const e3 of u2) {
      if (e3 === t2 || e3.destroyed || e3.spawning || e3.infecter.infectionStage !== void 0 && e3.infecter.infectionStage === s2.infectionStage)
        continue;
      const i3 = e3.infecter;
      if (Math.random() < v2 / p2) {
        if (i3.infectionStage === void 0)
          i3.startInfection(h2);
        else if (i3.infectionStage < s2.infectionStage)
          i3.updateInfectionStage(h2);
        else if (i3.infectionStage > s2.infectionStage) {
          const t3 = a2.stages[i3.infectionStage], e4 = (o2 = t3 == null ? void 0 : t3.infectedStage) !== null && o2 !== void 0 ? o2 : i3.infectionStage;
          s2.updateInfectionStage(e4);
        }
      }
    }
  }
}
class Te {
  constructor(t2) {
    this.container = t2, this.delay = 0;
  }
  interact(t2) {
    if (!this.container.retina.reduceFactor)
      return;
    const e2 = this.container, i2 = e2.actualOptions.interactivity.modes.trail, o2 = 1e3 * i2.delay / this.container.retina.reduceFactor;
    this.delay < o2 && (this.delay += t2.value), this.delay >= o2 && (e2.particles.push(i2.quantity, e2.interactivity.mouse, i2.particles), this.delay -= o2);
  }
  isEnabled() {
    const t2 = this.container, e2 = t2.actualOptions, i2 = t2.interactivity.mouse, o2 = e2.interactivity.events;
    return i2.clicking && i2.inside && !!i2.position && J.isInArray(D.trail, o2.onClick.mode) || i2.inside && !!i2.position && J.isInArray(F.trail, o2.onHover.mode);
  }
  reset() {
  }
}
class Ee {
  constructor(t2) {
    this.container = t2;
  }
  isEnabled() {
    const t2 = this.container, e2 = t2.actualOptions, i2 = t2.interactivity.mouse, o2 = e2.interactivity.events;
    if (!(o2.onHover.enable && i2.position || o2.onClick.enable && i2.clickPosition))
      return false;
    const s2 = o2.onHover.mode, n2 = o2.onClick.mode;
    return J.isInArray(F.attract, s2) || J.isInArray(D.attract, n2);
  }
  reset() {
  }
  interact() {
    const t2 = this.container, e2 = t2.actualOptions, i2 = t2.interactivity.status === Q.mouseMoveEvent, o2 = e2.interactivity.events, s2 = o2.onHover.enable, n2 = o2.onHover.mode, a2 = o2.onClick.enable, r2 = o2.onClick.mode;
    i2 && s2 && J.isInArray(F.attract, n2) ? this.hoverAttract() : a2 && J.isInArray(D.attract, r2) && this.clickAttract();
  }
  hoverAttract() {
    const t2 = this.container, e2 = t2.interactivity.mouse.position;
    if (!e2)
      return;
    const i2 = t2.retina.attractModeDistance;
    this.processAttract(e2, i2, new st(e2.x, e2.y, i2));
  }
  processAttract(t2, e2, i2) {
    const o2 = this.container, s2 = o2.particles.quadTree.query(i2);
    for (const i3 of s2) {
      const {dx: s3, dy: n2, distance: a2} = E.getDistances(i3.position, t2), r2 = {x: s3 / a2, y: n2 / a2}, l2 = o2.actualOptions.interactivity.modes.attract.speed, c2 = E.clamp((1 - Math.pow(a2 / e2, 2)) * l2, 0, 50);
      i3.position.x -= r2.x * c2, i3.position.y -= r2.y * c2;
    }
  }
  clickAttract() {
    const t2 = this.container;
    if (t2.attract.finish || (t2.attract.count || (t2.attract.count = 0), t2.attract.count++, t2.attract.count === t2.particles.count && (t2.attract.finish = true)), t2.attract.clicking) {
      const e2 = t2.interactivity.mouse.clickPosition;
      if (!e2)
        return;
      const i2 = t2.retina.attractModeDistance;
      this.processAttract(e2, i2, new st(e2.x, e2.y, i2));
    } else
      t2.attract.clicking === false && (t2.attract.particles = []);
  }
}
class De {
  constructor(t2) {
    this.container = t2;
  }
  interact(t2) {
    const e2 = this.container;
    if (e2.actualOptions.interactivity.events.onHover.enable && e2.interactivity.status === "mousemove") {
      const i2 = this.container.interactivity.mouse.position;
      i2 && e2.canvas.drawParticleShadow(t2, i2);
    }
  }
  isEnabled() {
    const t2 = this.container, e2 = t2.interactivity.mouse, i2 = t2.actualOptions.interactivity.events;
    if (!i2.onHover.enable || !e2.position)
      return false;
    const o2 = i2.onHover.mode;
    return J.isInArray(F.light, o2);
  }
  reset() {
  }
}
class Oe {
  constructor(t2) {
    this.container = t2;
  }
  interact() {
    const t2 = this.container;
    if (t2.actualOptions.interactivity.events.onHover.enable && t2.interactivity.status === "mousemove") {
      const e2 = t2.interactivity.mouse.position;
      if (!e2)
        return;
      t2.canvas.drawLight(e2);
    }
  }
  isEnabled() {
    const t2 = this.container, e2 = t2.interactivity.mouse, i2 = t2.actualOptions.interactivity.events;
    if (!i2.onHover.enable || !e2.position)
      return false;
    const o2 = i2.onHover.mode;
    return J.isInArray(F.light, o2);
  }
  reset() {
  }
}
class Ie {
  constructor(t2) {
    this.container = t2;
  }
  isEnabled() {
    const t2 = this.container, e2 = t2.actualOptions, i2 = t2.interactivity.mouse, o2 = e2.interactivity.events, s2 = o2.onDiv;
    return i2.position && o2.onHover.enable && J.isInArray(F.bounce, o2.onHover.mode) || J.isDivModeEnabled(I.bounce, s2);
  }
  interact() {
    const t2 = this.container, e2 = t2.actualOptions.interactivity.events, i2 = t2.interactivity.status === Q.mouseMoveEvent, o2 = e2.onHover.enable, s2 = e2.onHover.mode, n2 = e2.onDiv;
    i2 && o2 && J.isInArray(F.bounce, s2) ? this.processMouseBounce() : J.divModeExecute(I.bounce, n2, (t3, e3) => this.singleSelectorBounce(t3, e3));
  }
  reset() {
  }
  processMouseBounce() {
    const t2 = this.container, e2 = 10 * t2.retina.pixelRatio, i2 = t2.interactivity.mouse.position, o2 = t2.retina.bounceModeDistance;
    i2 && this.processBounce(i2, o2, new st(i2.x, i2.y, o2 + e2));
  }
  singleSelectorBounce(t2, e2) {
    const i2 = this.container, o2 = document.querySelectorAll(t2);
    o2.length && o2.forEach((t3) => {
      const o3 = t3, s2 = i2.retina.pixelRatio, n2 = {x: (o3.offsetLeft + o3.offsetWidth / 2) * s2, y: (o3.offsetTop + o3.offsetHeight / 2) * s2}, a2 = o3.offsetWidth / 2 * s2, r2 = 10 * s2, l2 = e2.type === N.circle ? new st(n2.x, n2.y, a2 + r2) : new nt(o3.offsetLeft * s2 - r2, o3.offsetTop * s2 - r2, o3.offsetWidth * s2 + 2 * r2, o3.offsetHeight * s2 + 2 * r2);
      this.processBounce(n2, a2, l2);
    });
  }
  processBounce(t2, e2, i2) {
    const o2 = this.container.particles.quadTree.query(i2);
    for (const s2 of o2)
      i2 instanceof st ? J.circleBounce(J.circleBounceDataFromParticle(s2), {position: t2, radius: e2, mass: Math.pow(e2, 2) * Math.PI / 2, velocity: T.create(0, 0), factor: {horizontal: 0, vertical: 0}}) : i2 instanceof nt && J.rectBounce(s2, J.calculateBounds(t2, e2));
  }
}
class Fe {
  constructor(t2) {
    this.container = t2, this.externalInteractors = [new Ie(t2), new Me(t2), new Re(t2), new xe(t2), new Oe(t2), new Ee(t2), new ke(t2), new Te(t2)], this.particleInteractors = [new Ce(t2), new De(t2), new ze(t2), new Ae(t2), new Se(t2)];
  }
  init() {
  }
  externalInteract(t2) {
    for (const e2 of this.externalInteractors)
      e2.isEnabled() && e2.interact(t2);
  }
  particlesInteract(t2, e2) {
    for (const e3 of this.externalInteractors)
      e3.reset(t2);
    for (const i2 of this.particleInteractors)
      i2.isEnabled(t2) && i2.interact(t2, e2);
  }
}
class Le {
  constructor(t2) {
    this.container = t2, this.nextId = 0, this.array = [], this.limit = 0, this.linksFreq = new Map(), this.trianglesFreq = new Map(), this.interactionManager = new Fe(t2);
    const e2 = this.container.canvas.size;
    this.linksColors = new Map(), this.quadTree = new yt(new nt(-e2.width / 4, -e2.height / 4, 3 * e2.width / 2, 3 * e2.height / 2), 4);
  }
  get count() {
    return this.array.length;
  }
  init() {
    const t2 = this.container, e2 = t2.actualOptions;
    this.linksFreq = new Map(), this.trianglesFreq = new Map();
    let i2 = false;
    for (const i3 of e2.manualParticles) {
      const e3 = i3.position ? {x: i3.position.x * t2.canvas.size.width / 100, y: i3.position.y * t2.canvas.size.height / 100} : void 0;
      this.addParticle(e3, i3.options);
    }
    for (const [, e3] of t2.plugins)
      if (e3.particlesInitialization !== void 0 && (i2 = e3.particlesInitialization()), i2)
        break;
    if (!i2)
      for (let t3 = this.count; t3 < e2.particles.number.value; t3++)
        this.addParticle();
    if (e2.infection.enable)
      for (let t3 = 0; t3 < e2.infection.infections; t3++) {
        const t4 = this.array.filter((t5) => t5.infecter.infectionStage === void 0);
        J.itemFromArray(t4).infecter.startInfection(0);
      }
    this.interactionManager.init(), t2.pathGenerator.init();
  }
  redraw() {
    this.clear(), this.init(), this.draw({value: 0, factor: 0});
  }
  removeAt(t2, e2, i2) {
    if (t2 >= 0 && t2 <= this.count)
      for (const o2 of this.array.splice(t2, e2 != null ? e2 : 1))
        o2.destroy(i2);
  }
  remove(t2, e2) {
    this.removeAt(this.array.indexOf(t2), void 0, e2);
  }
  update(t2) {
    const e2 = this.container, i2 = [];
    e2.pathGenerator.update();
    for (const [, i3] of e2.plugins)
      i3.update !== void 0 && i3.update(t2);
    for (const e3 of this.array) {
      const o2 = this.container.canvas.resizeFactor;
      o2 && (e3.position.x *= o2.width, e3.position.y *= o2.height), e3.move(t2), e3.destroyed ? i2.push(e3) : this.quadTree.insert(new pt(e3.getPosition(), e3));
    }
    for (const t3 of i2)
      this.remove(t3);
    this.interactionManager.externalInteract(t2);
    for (const e3 of this.container.particles.array)
      e3.update(t2), e3.destroyed || e3.spawning || this.interactionManager.particlesInteract(e3, t2);
    delete e2.canvas.resizeFactor;
  }
  draw(t2) {
    const e2 = this.container;
    e2.canvas.clear();
    const i2 = this.container.canvas.size;
    this.quadTree = new yt(new nt(-i2.width / 4, -i2.height / 4, 3 * i2.width / 2, 3 * i2.height / 2), 4), this.update(t2);
    for (const [, i3] of e2.plugins)
      e2.canvas.drawPlugin(i3, t2);
    for (const e3 of this.array)
      e3.draw(t2);
  }
  clear() {
    this.array = [];
  }
  push(t2, e2, i2) {
    const o2 = this.container, s2 = o2.actualOptions.particles.number.limit * o2.density;
    if (this.pushing = true, s2 > 0) {
      const e3 = this.count + t2 - s2;
      e3 > 0 && this.removeQuantity(e3);
    }
    for (let o3 = 0; o3 < t2; o3++)
      this.addParticle(e2 == null ? void 0 : e2.position, i2);
    this.pushing = false;
  }
  addParticle(t2, e2) {
    return this.pushParticle(t2, e2);
  }
  addSplitParticle(t2) {
    const e2 = t2.options.destroy.split, i2 = new me();
    i2.load(t2.options);
    const o2 = E.getRangeValue(e2.factor.value);
    i2.color.load({value: {hsl: t2.getFillColor()}}), typeof i2.size.value == "number" ? i2.size.value /= o2 : (i2.size.value.min /= o2, i2.size.value.max /= o2), i2.load(e2.particles);
    const s2 = E.setRangeValue(-t2.size.value, t2.size.value), n2 = {x: t2.position.x + E.randomInRange(s2), y: t2.position.y + E.randomInRange(s2)};
    return this.pushParticle(n2, i2, (e3) => !(e3.size.value < 0.5) && (e3.velocity.length = E.randomInRange(E.setRangeValue(t2.velocity.length, e3.velocity.length)), e3.splitCount = t2.splitCount + 1, e3.unbreakable = true, setTimeout(() => {
      e3.unbreakable = false;
    }, 500), true));
  }
  removeQuantity(t2) {
    this.removeAt(0, t2);
  }
  getLinkFrequency(t2, e2) {
    const i2 = `${Math.min(t2.id, e2.id)}_${Math.max(t2.id, e2.id)}`;
    let o2 = this.linksFreq.get(i2);
    return o2 === void 0 && (o2 = Math.random(), this.linksFreq.set(i2, o2)), o2;
  }
  getTriangleFrequency(t2, e2, i2) {
    let [o2, s2, n2] = [t2.id, e2.id, i2.id];
    o2 > s2 && ([s2, o2] = [o2, s2]), s2 > n2 && ([n2, s2] = [s2, n2]), o2 > n2 && ([n2, o2] = [o2, n2]);
    const a2 = `${o2}_${s2}_${n2}`;
    let r2 = this.trianglesFreq.get(a2);
    return r2 === void 0 && (r2 = Math.random(), this.trianglesFreq.set(a2, r2)), r2;
  }
  setDensity() {
    const t2 = this.container.actualOptions;
    this.applyDensity(t2.particles);
  }
  applyDensity(t2) {
    var e2;
    if (!((e2 = t2.number.density) === null || e2 === void 0 ? void 0 : e2.enable))
      return;
    const i2 = t2.number, o2 = this.initDensityFactor(i2.density), s2 = i2.value, n2 = i2.limit > 0 ? i2.limit : s2, a2 = Math.min(s2, n2) * o2, r2 = this.count;
    this.limit = i2.limit * o2, r2 < a2 ? this.push(Math.abs(a2 - r2), void 0, t2) : r2 > a2 && this.removeQuantity(r2 - a2);
  }
  initDensityFactor(t2) {
    const e2 = this.container;
    if (!e2.canvas.element || !t2.enable)
      return 1;
    const i2 = e2.canvas.element, o2 = e2.retina.pixelRatio;
    return i2.width * i2.height / (t2.factor * o2 * o2 * t2.area);
  }
  pushParticle(t2, e2, i2) {
    try {
      const o2 = new we(this.nextId, this.container, t2, e2);
      let s2 = true;
      if (i2 && (s2 = i2(o2)), !s2)
        return;
      return this.array.push(o2), this.nextId++, o2;
    } catch (t3) {
      return void console.warn(`error adding particle: ${t3}`);
    }
  }
}
class Ve {
  constructor(t2) {
    this.container = t2;
  }
  init() {
    const t2 = this.container, e2 = t2.actualOptions;
    this.pixelRatio = !e2.detectRetina || J.isSsr() ? 1 : window.devicePixelRatio;
    const i2 = this.container.actualOptions.motion;
    if (i2 && (i2.disable || i2.reduce.value))
      if (J.isSsr() || typeof matchMedia == "undefined" || !matchMedia)
        this.reduceFactor = 1;
      else {
        const e3 = matchMedia("(prefers-reduced-motion: reduce)");
        if (e3) {
          this.handleMotionChange(e3);
          const i3 = () => {
            this.handleMotionChange(e3), t2.refresh().catch(() => {
            });
          };
          e3.addEventListener !== void 0 ? e3.addEventListener("change", i3) : e3.addListener !== void 0 && e3.addListener(i3);
        }
      }
    else
      this.reduceFactor = 1;
    const o2 = this.pixelRatio;
    if (t2.canvas.element) {
      const e3 = t2.canvas.element;
      t2.canvas.size.width = e3.offsetWidth * o2, t2.canvas.size.height = e3.offsetHeight * o2;
    }
    const s2 = e2.particles;
    this.linksDistance = s2.links.distance * o2, this.linksWidth = s2.links.width * o2, this.sizeAnimationSpeed = s2.size.animation.speed * o2;
    const n2 = e2.interactivity.modes;
    this.connectModeDistance = n2.connect.distance * o2, this.connectModeRadius = n2.connect.radius * o2, this.grabModeDistance = n2.grab.distance * o2, this.repulseModeDistance = n2.repulse.distance * o2, this.bounceModeDistance = n2.bounce.distance * o2, this.attractModeDistance = n2.attract.distance * o2, this.slowModeRadius = n2.slow.radius * o2, this.bubbleModeDistance = n2.bubble.distance * o2, n2.bubble.size && (this.bubbleModeSize = n2.bubble.size * o2);
  }
  initParticle(t2) {
    const e2 = t2.options, i2 = this.pixelRatio;
    t2.linksDistance = e2.links.distance * i2, t2.linksWidth = e2.links.width * i2, t2.moveDrift = E.getRangeValue(e2.move.drift) * i2, t2.moveSpeed = E.getRangeValue(e2.move.speed) * i2, t2.sizeAnimationSpeed = e2.size.animation.speed * i2, t2.maxDistance = e2.move.distance * i2;
  }
  handleMotionChange(t2) {
    const e2 = this.container.actualOptions;
    if (t2.matches) {
      const t3 = e2.motion;
      this.reduceFactor = t3.disable ? 0 : t3.reduce.value ? 1 / t3.reduce.factor : 1;
    } else
      this.reduceFactor = 1;
  }
}
class He {
  constructor(t2) {
    this.container = t2;
  }
  nextFrame(t2) {
    try {
      const e2 = this.container;
      if (e2.lastFrameTime !== void 0 && t2 < e2.lastFrameTime + 1e3 / e2.fpsLimit)
        return void e2.draw();
      const i2 = t2 - e2.lastFrameTime, o2 = {value: i2, factor: 60 * i2 / 1e3};
      e2.lastFrameTime = t2, e2.particles.draw(o2), e2.getAnimationStatus() && e2.draw();
    } catch (t3) {
      console.error("tsParticles error in animation loop", t3);
    }
  }
}
class _e {
  constructor() {
    this.enable = false, this.mode = [];
  }
  load(t2) {
    t2 !== void 0 && (t2.enable !== void 0 && (this.enable = t2.enable), t2.mode !== void 0 && (this.mode = t2.mode));
  }
}
class qe {
  constructor() {
    this.selectors = [], this.enable = false, this.mode = [], this.type = N.circle;
  }
  get elementId() {
    return this.ids;
  }
  set elementId(t2) {
    this.ids = t2;
  }
  get el() {
    return this.elementId;
  }
  set el(t2) {
    this.elementId = t2;
  }
  get ids() {
    return this.selectors instanceof Array ? this.selectors.map((t2) => t2.replace("#", "")) : this.selectors.replace("#", "");
  }
  set ids(t2) {
    this.selectors = t2 instanceof Array ? t2.map((t3) => `#${t3}`) : `#${t2}`;
  }
  load(t2) {
    var e2, i2;
    if (t2 === void 0)
      return;
    const o2 = (i2 = (e2 = t2.ids) !== null && e2 !== void 0 ? e2 : t2.elementId) !== null && i2 !== void 0 ? i2 : t2.el;
    o2 !== void 0 && (this.ids = o2), t2.selectors !== void 0 && (this.selectors = t2.selectors), t2.enable !== void 0 && (this.enable = t2.enable), t2.mode !== void 0 && (this.mode = t2.mode), t2.type !== void 0 && (this.type = t2.type);
  }
}
class Be {
  constructor() {
    this.enable = false, this.force = 2, this.smooth = 10;
  }
  load(t2) {
    t2 !== void 0 && (t2.enable !== void 0 && (this.enable = t2.enable), t2.force !== void 0 && (this.force = t2.force), t2.smooth !== void 0 && (this.smooth = t2.smooth));
  }
}
class $e {
  constructor() {
    this.enable = false, this.mode = [], this.parallax = new Be();
  }
  load(t2) {
    t2 !== void 0 && (t2.enable !== void 0 && (this.enable = t2.enable), t2.mode !== void 0 && (this.mode = t2.mode), this.parallax.load(t2.parallax));
  }
}
class We {
  constructor() {
    this.onClick = new _e(), this.onDiv = new qe(), this.onHover = new $e(), this.resize = true;
  }
  get onclick() {
    return this.onClick;
  }
  set onclick(t2) {
    this.onClick = t2;
  }
  get ondiv() {
    return this.onDiv;
  }
  set ondiv(t2) {
    this.onDiv = t2;
  }
  get onhover() {
    return this.onHover;
  }
  set onhover(t2) {
    this.onHover = t2;
  }
  load(t2) {
    var e2, i2, o2;
    if (t2 === void 0)
      return;
    this.onClick.load((e2 = t2.onClick) !== null && e2 !== void 0 ? e2 : t2.onclick);
    const s2 = (i2 = t2.onDiv) !== null && i2 !== void 0 ? i2 : t2.ondiv;
    s2 !== void 0 && (s2 instanceof Array ? this.onDiv = s2.map((t3) => {
      const e3 = new qe();
      return e3.load(t3), e3;
    }) : (this.onDiv = new qe(), this.onDiv.load(s2))), this.onHover.load((o2 = t2.onHover) !== null && o2 !== void 0 ? o2 : t2.onhover), t2.resize !== void 0 && (this.resize = t2.resize);
  }
}
class Ge {
  constructor() {
    this.distance = 200, this.duration = 0.4;
  }
  load(t2) {
    t2 !== void 0 && (t2.distance !== void 0 && (this.distance = t2.distance), t2.duration !== void 0 && (this.duration = t2.duration), t2.opacity !== void 0 && (this.opacity = t2.opacity), t2.color !== void 0 && (t2.color instanceof Array ? this.color = t2.color.map((t3) => At.create(void 0, t3)) : (this.color instanceof Array && (this.color = new At()), this.color = At.create(this.color, t2.color))), t2.size !== void 0 && (this.size = t2.size));
  }
}
class Ne extends Ge {
  constructor() {
    super(), this.selectors = [];
  }
  get ids() {
    return this.selectors instanceof Array ? this.selectors.map((t2) => t2.replace("#", "")) : this.selectors.replace("#", "");
  }
  set ids(t2) {
    this.selectors = t2 instanceof Array ? t2.map((t3) => `#${t3}`) : `#${t2}`;
  }
  load(t2) {
    super.load(t2), t2 !== void 0 && (t2.ids !== void 0 && (this.ids = t2.ids), t2.selectors !== void 0 && (this.selectors = t2.selectors));
  }
}
class Ue extends Ge {
  load(t2) {
    super.load(t2), t2 !== void 0 && t2.divs !== void 0 && (t2.divs instanceof Array ? this.divs = t2.divs.map((t3) => {
      const e2 = new Ne();
      return e2.load(t3), e2;
    }) : ((this.divs instanceof Array || !this.divs) && (this.divs = new Ne()), this.divs.load(t2.divs)));
  }
}
class je {
  constructor() {
    this.opacity = 0.5;
  }
  load(t2) {
    t2 !== void 0 && t2.opacity !== void 0 && (this.opacity = t2.opacity);
  }
}
class Ye {
  constructor() {
    this.distance = 80, this.links = new je(), this.radius = 60;
  }
  get line_linked() {
    return this.links;
  }
  set line_linked(t2) {
    this.links = t2;
  }
  get lineLinked() {
    return this.links;
  }
  set lineLinked(t2) {
    this.links = t2;
  }
  load(t2) {
    var e2, i2;
    t2 !== void 0 && (t2.distance !== void 0 && (this.distance = t2.distance), this.links.load((i2 = (e2 = t2.links) !== null && e2 !== void 0 ? e2 : t2.lineLinked) !== null && i2 !== void 0 ? i2 : t2.line_linked), t2.radius !== void 0 && (this.radius = t2.radius));
  }
}
class Xe {
  constructor() {
    this.blink = false, this.consent = false, this.opacity = 1;
  }
  load(t2) {
    t2 !== void 0 && (t2.blink !== void 0 && (this.blink = t2.blink), t2.color !== void 0 && (this.color = At.create(this.color, t2.color)), t2.consent !== void 0 && (this.consent = t2.consent), t2.opacity !== void 0 && (this.opacity = t2.opacity));
  }
}
class Je {
  constructor() {
    this.distance = 100, this.links = new Xe();
  }
  get line_linked() {
    return this.links;
  }
  set line_linked(t2) {
    this.links = t2;
  }
  get lineLinked() {
    return this.links;
  }
  set lineLinked(t2) {
    this.links = t2;
  }
  load(t2) {
    var e2, i2;
    t2 !== void 0 && (t2.distance !== void 0 && (this.distance = t2.distance), this.links.load((i2 = (e2 = t2.links) !== null && e2 !== void 0 ? e2 : t2.lineLinked) !== null && i2 !== void 0 ? i2 : t2.line_linked));
  }
}
class Qe {
  constructor() {
    this.quantity = 2;
  }
  get particles_nb() {
    return this.quantity;
  }
  set particles_nb(t2) {
    this.quantity = t2;
  }
  load(t2) {
    var e2;
    if (t2 === void 0)
      return;
    const i2 = (e2 = t2.quantity) !== null && e2 !== void 0 ? e2 : t2.particles_nb;
    i2 !== void 0 && (this.quantity = i2);
  }
}
class Ze {
  constructor() {
    this.quantity = 4;
  }
  get particles_nb() {
    return this.quantity;
  }
  set particles_nb(t2) {
    this.quantity = t2;
  }
  load(t2) {
    var e2;
    if (t2 === void 0)
      return;
    const i2 = (e2 = t2.quantity) !== null && e2 !== void 0 ? e2 : t2.particles_nb;
    i2 !== void 0 && (this.quantity = i2);
  }
}
class Ke {
  constructor() {
    this.distance = 200, this.duration = 0.4, this.speed = 1;
  }
  load(t2) {
    t2 !== void 0 && (t2.distance !== void 0 && (this.distance = t2.distance), t2.duration !== void 0 && (this.duration = t2.duration), t2.speed !== void 0 && (this.speed = t2.speed));
  }
}
class ti extends Ke {
  constructor() {
    super(), this.selectors = [];
  }
  get ids() {
    return this.selectors instanceof Array ? this.selectors.map((t2) => t2.replace("#", "")) : this.selectors.replace("#", "");
  }
  set ids(t2) {
    this.selectors = t2 instanceof Array ? t2.map(() => `#${t2}`) : `#${t2}`;
  }
  load(t2) {
    super.load(t2), t2 !== void 0 && (t2.ids !== void 0 && (this.ids = t2.ids), t2.selectors !== void 0 && (this.selectors = t2.selectors));
  }
}
class ei extends Ke {
  load(t2) {
    super.load(t2), (t2 == null ? void 0 : t2.divs) !== void 0 && (t2.divs instanceof Array ? this.divs = t2.divs.map((t3) => {
      const e2 = new ti();
      return e2.load(t3), e2;
    }) : ((this.divs instanceof Array || !this.divs) && (this.divs = new ti()), this.divs.load(t2.divs)));
  }
}
class ii {
  constructor() {
    this.factor = 3, this.radius = 200;
  }
  get active() {
    return false;
  }
  set active(t2) {
  }
  load(t2) {
    t2 !== void 0 && (t2.factor !== void 0 && (this.factor = t2.factor), t2.radius !== void 0 && (this.radius = t2.radius));
  }
}
class oi {
  constructor() {
    this.delay = 1, this.quantity = 1;
  }
  load(t2) {
    t2 !== void 0 && (t2.delay !== void 0 && (this.delay = t2.delay), t2.quantity !== void 0 && (this.quantity = t2.quantity), t2.particles !== void 0 && (this.particles = J.deepExtend({}, t2.particles)));
  }
}
class si {
  constructor() {
    this.distance = 200, this.duration = 0.4, this.speed = 1;
  }
  load(t2) {
    t2 !== void 0 && (t2.distance !== void 0 && (this.distance = t2.distance), t2.duration !== void 0 && (this.duration = t2.duration), t2.speed !== void 0 && (this.speed = t2.speed));
  }
}
class ni {
  constructor() {
    this.start = new At(), this.stop = new At(), this.start.value = "#ffffff", this.stop.value = "#000000";
  }
  load(t2) {
    t2 !== void 0 && (this.start = At.create(this.start, t2.start), this.stop = At.create(this.stop, t2.stop));
  }
}
class ai {
  constructor() {
    this.gradient = new ni(), this.radius = 1e3;
  }
  load(t2) {
    t2 !== void 0 && (this.gradient.load(t2.gradient), t2.radius !== void 0 && (this.radius = t2.radius));
  }
}
class ri {
  constructor() {
    this.color = new At(), this.color.value = "#000000", this.length = 2e3;
  }
  load(t2) {
    t2 !== void 0 && (this.color = At.create(this.color, t2.color), t2.length !== void 0 && (this.length = t2.length));
  }
}
class li {
  constructor() {
    this.area = new ai(), this.shadow = new ri();
  }
  load(t2) {
    t2 !== void 0 && (this.area.load(t2.area), this.shadow.load(t2.shadow));
  }
}
class ci {
  constructor() {
    this.distance = 200;
  }
  load(t2) {
    t2 && t2.distance !== void 0 && (this.distance = t2.distance);
  }
}
class di {
  constructor() {
    this.attract = new si(), this.bounce = new ci(), this.bubble = new Ue(), this.connect = new Ye(), this.grab = new Je(), this.light = new li(), this.push = new Ze(), this.remove = new Qe(), this.repulse = new ei(), this.slow = new ii(), this.trail = new oi();
  }
  load(t2) {
    t2 !== void 0 && (this.attract.load(t2.attract), this.bubble.load(t2.bubble), this.connect.load(t2.connect), this.grab.load(t2.grab), this.light.load(t2.light), this.push.load(t2.push), this.remove.load(t2.remove), this.repulse.load(t2.repulse), this.slow.load(t2.slow), this.trail.load(t2.trail));
  }
}
class hi {
  constructor() {
    this.detectsOn = U.canvas, this.events = new We(), this.modes = new di();
  }
  get detect_on() {
    return this.detectsOn;
  }
  set detect_on(t2) {
    this.detectsOn = t2;
  }
  load(t2) {
    var e2, i2, o2;
    if (t2 === void 0)
      return;
    const s2 = (e2 = t2.detectsOn) !== null && e2 !== void 0 ? e2 : t2.detect_on;
    s2 !== void 0 && (this.detectsOn = s2), this.events.load(t2.events), this.modes.load(t2.modes), ((o2 = (i2 = t2.modes) === null || i2 === void 0 ? void 0 : i2.slow) === null || o2 === void 0 ? void 0 : o2.active) === true && (this.events.onHover.mode instanceof Array ? this.events.onHover.mode.indexOf(F.slow) < 0 && this.events.onHover.mode.push(F.slow) : this.events.onHover.mode !== F.slow && (this.events.onHover.mode = [this.events.onHover.mode, F.slow]));
  }
}
class ui {
  constructor() {
    this.color = new At(), this.opacity = 1;
  }
  load(t2) {
    t2 !== void 0 && (t2.color !== void 0 && (this.color = At.create(this.color, t2.color)), t2.opacity !== void 0 && (this.opacity = t2.opacity));
  }
}
class vi {
  constructor() {
    this.composite = "destination-out", this.cover = new ui(), this.enable = false;
  }
  load(t2) {
    if (t2 !== void 0) {
      if (t2.composite !== void 0 && (this.composite = t2.composite), t2.cover !== void 0) {
        const e2 = t2.cover, i2 = typeof t2.cover == "string" ? {color: t2.cover} : t2.cover;
        this.cover.load(e2.color !== void 0 ? e2 : {color: i2});
      }
      t2.enable !== void 0 && (this.enable = t2.enable);
    }
  }
}
class pi {
  constructor() {
    this.color = new At(), this.color.value = "", this.image = "", this.position = "", this.repeat = "", this.size = "", this.opacity = 1;
  }
  load(t2) {
    t2 !== void 0 && (t2.color !== void 0 && (this.color = At.create(this.color, t2.color)), t2.image !== void 0 && (this.image = t2.image), t2.position !== void 0 && (this.position = t2.position), t2.repeat !== void 0 && (this.repeat = t2.repeat), t2.size !== void 0 && (this.size = t2.size), t2.opacity !== void 0 && (this.opacity = t2.opacity));
  }
}
class yi {
  constructor() {
    this.color = new At(), this.color.value = "#ff0000", this.radius = 0, this.rate = 1;
  }
  load(t2) {
    t2 !== void 0 && (t2.color !== void 0 && (this.color = At.create(this.color, t2.color)), this.duration = t2.duration, this.infectedStage = t2.infectedStage, t2.radius !== void 0 && (this.radius = t2.radius), t2.rate !== void 0 && (this.rate = t2.rate));
  }
}
class fi {
  constructor() {
    this.cure = false, this.delay = 0, this.enable = false, this.infections = 0, this.stages = [];
  }
  load(t2) {
    t2 !== void 0 && (t2.cure !== void 0 && (this.cure = t2.cure), t2.delay !== void 0 && (this.delay = t2.delay), t2.enable !== void 0 && (this.enable = t2.enable), t2.infections !== void 0 && (this.infections = t2.infections), t2.stages !== void 0 && (this.stages = t2.stages.map((t3) => {
      const e2 = new yi();
      return e2.load(t3), e2;
    })));
  }
}
class mi {
  constructor() {
    this.mode = _.any, this.value = false;
  }
  load(t2) {
    t2 !== void 0 && (t2.mode !== void 0 && (this.mode = t2.mode), t2.value !== void 0 && (this.value = t2.value));
  }
}
class gi {
  constructor() {
    this.name = "", this.default = new mi();
  }
  load(t2) {
    t2 !== void 0 && (t2.name !== void 0 && (this.name = t2.name), this.default.load(t2.default), t2.options !== void 0 && (this.options = J.deepExtend({}, t2.options)));
  }
}
class bi {
  constructor() {
    this.enable = false, this.zIndex = -1;
  }
  load(t2) {
    t2 && (t2.enable !== void 0 && (this.enable = t2.enable), t2.zIndex !== void 0 && (this.zIndex = t2.zIndex));
  }
}
class wi {
  constructor() {
    this.factor = 4, this.value = true;
  }
  load(t2) {
    t2 && (t2.factor !== void 0 && (this.factor = t2.factor), t2.value !== void 0 && (this.value = t2.value));
  }
}
class xi {
  constructor() {
    this.disable = false, this.reduce = new wi();
  }
  load(t2) {
    t2 && (t2.disable !== void 0 && (this.disable = t2.disable), this.reduce.load(t2.reduce));
  }
}
class ki {
  load(t2) {
    var e2, i2;
    t2 && (t2.position !== void 0 && (this.position = {x: (e2 = t2.position.x) !== null && e2 !== void 0 ? e2 : 50, y: (i2 = t2.position.y) !== null && i2 !== void 0 ? i2 : 50}), t2.options !== void 0 && (this.options = J.deepExtend({}, t2.options)));
  }
}
class Pi {
  constructor() {
    this.maxWidth = 1 / 0, this.options = {};
  }
  load(t2) {
    t2 && (t2.maxWidth !== void 0 && (this.maxWidth = t2.maxWidth), t2.options !== void 0 && (this.options = J.deepExtend({}, t2.options)));
  }
}
class Mi {
  constructor() {
    this.autoPlay = true, this.background = new pi(), this.backgroundMask = new vi(), this.fullScreen = new bi(), this.detectRetina = true, this.fpsLimit = 60, this.infection = new fi(), this.interactivity = new hi(), this.manualParticles = [], this.motion = new xi(), this.particles = new me(), this.pauseOnBlur = true, this.pauseOnOutsideViewport = true, this.responsive = [], this.themes = [];
  }
  get fps_limit() {
    return this.fpsLimit;
  }
  set fps_limit(t2) {
    this.fpsLimit = t2;
  }
  get retina_detect() {
    return this.detectRetina;
  }
  set retina_detect(t2) {
    this.detectRetina = t2;
  }
  get backgroundMode() {
    return this.fullScreen;
  }
  set backgroundMode(t2) {
    this.fullScreen.load(t2);
  }
  load(t2) {
    var e2, i2, o2;
    if (t2 === void 0)
      return;
    if (t2.preset !== void 0)
      if (t2.preset instanceof Array)
        for (const e3 of t2.preset)
          this.importPreset(e3);
      else
        this.importPreset(t2.preset);
    t2.autoPlay !== void 0 && (this.autoPlay = t2.autoPlay);
    const s2 = (e2 = t2.detectRetina) !== null && e2 !== void 0 ? e2 : t2.retina_detect;
    s2 !== void 0 && (this.detectRetina = s2);
    const n2 = (i2 = t2.fpsLimit) !== null && i2 !== void 0 ? i2 : t2.fps_limit;
    if (n2 !== void 0 && (this.fpsLimit = n2), t2.pauseOnBlur !== void 0 && (this.pauseOnBlur = t2.pauseOnBlur), t2.pauseOnOutsideViewport !== void 0 && (this.pauseOnOutsideViewport = t2.pauseOnOutsideViewport), this.background.load(t2.background), this.fullScreen.load((o2 = t2.fullScreen) !== null && o2 !== void 0 ? o2 : t2.backgroundMode), this.backgroundMask.load(t2.backgroundMask), this.infection.load(t2.infection), this.interactivity.load(t2.interactivity), t2.manualParticles !== void 0 && (this.manualParticles = t2.manualParticles.map((t3) => {
      const e3 = new ki();
      return e3.load(t3), e3;
    })), this.motion.load(t2.motion), this.particles.load(t2.particles), vt.loadOptions(this, t2), t2.responsive !== void 0)
      for (const e3 of t2.responsive) {
        const t3 = new Pi();
        t3.load(e3), this.responsive.push(t3);
      }
    if (this.responsive.sort((t3, e3) => t3.maxWidth - e3.maxWidth), t2.themes !== void 0)
      for (const e3 of t2.themes) {
        const t3 = new gi();
        t3.load(e3), this.themes.push(t3);
      }
  }
  setTheme(t2) {
    if (t2) {
      const e2 = this.themes.find((e3) => e3.name === t2);
      e2 && this.load(e2.options);
    } else {
      const t3 = typeof matchMedia != "undefined" && matchMedia("(prefers-color-scheme: dark)").matches;
      let e2 = this.themes.find((e3) => e3.default.value && (e3.default.mode === _.dark && t3 || e3.default.mode === _.light && !t3));
      e2 || (e2 = this.themes.find((t4) => t4.default.value && t4.default.mode === _.any)), e2 && this.load(e2.options);
    }
  }
  importPreset(t2) {
    this.load(vt.getPreset(t2));
  }
  setResponsive(t2, e2, i2) {
    var o2;
    this.load(i2), this.load((o2 = this.responsive.find((i3) => i3.maxWidth * e2 > t2)) === null || o2 === void 0 ? void 0 : o2.options);
  }
}
var Ri = function(t2, e2, i2, o2) {
  return new (i2 || (i2 = Promise))(function(s2, n2) {
    function a2(t3) {
      try {
        l2(o2.next(t3));
      } catch (t4) {
        n2(t4);
      }
    }
    function r2(t3) {
      try {
        l2(o2.throw(t3));
      } catch (t4) {
        n2(t4);
      }
    }
    function l2(t3) {
      var e3;
      t3.done ? s2(t3.value) : (e3 = t3.value, e3 instanceof i2 ? e3 : new i2(function(t4) {
        t4(e3);
      })).then(a2, r2);
    }
    l2((o2 = o2.apply(t2, e2 || [])).next());
  });
};
class Si {
  constructor(t2, e2, ...i2) {
    this.id = t2, this.fpsLimit = 60, this.firstStart = true, this.started = false, this.destroyed = false, this.paused = true, this.lastFrameTime = 0, this.pageHidden = false, this._sourceOptions = e2, this.retina = new Ve(this), this.canvas = new St(this), this.particles = new Le(this), this.drawer = new He(this), this.pathGenerator = {generate: () => {
      const t3 = T.create(0, 0);
      return t3.length = Math.random(), t3.angle = Math.random() * Math.PI * 2, t3;
    }, init: () => {
    }, update: () => {
    }}, this.interactivity = {mouse: {clicking: false, inside: false}}, this.bubble = {}, this.repulse = {particles: []}, this.attract = {particles: []}, this.plugins = new Map(), this.drawers = new Map(), this.density = 1, this._options = new Mi(), this.actualOptions = new Mi();
    for (const t3 of i2)
      this._options.load(vt.getPreset(t3));
    const o2 = vt.getSupportedShapes();
    for (const t3 of o2) {
      const e3 = vt.getShapeDrawer(t3);
      e3 && this.drawers.set(t3, e3);
    }
    this._options && this._options.load(this._sourceOptions), this.eventListeners = new lt(this), typeof IntersectionObserver != "undefined" && IntersectionObserver && (this.intersectionObserver = new IntersectionObserver((t3) => this.intersectionManager(t3)));
  }
  get options() {
    return this._options;
  }
  get sourceOptions() {
    return this._sourceOptions;
  }
  play(t2) {
    const e2 = this.paused || t2;
    if (!this.firstStart || this.actualOptions.autoPlay) {
      if (this.paused && (this.paused = false), e2) {
        for (const [, t3] of this.plugins)
          t3.play && t3.play();
        this.lastFrameTime = performance.now();
      }
      this.draw();
    } else
      this.firstStart = false;
  }
  pause() {
    if (this.drawAnimationFrame !== void 0 && (J.cancelAnimation(this.drawAnimationFrame), delete this.drawAnimationFrame), !this.paused) {
      for (const [, t2] of this.plugins)
        t2.pause && t2.pause();
      this.pageHidden || (this.paused = true);
    }
  }
  draw() {
    this.drawAnimationFrame = J.animate((t2) => this.drawer.nextFrame(t2));
  }
  getAnimationStatus() {
    return !this.paused;
  }
  setNoise(t2, e2, i2) {
    this.setPath(t2, e2, i2);
  }
  setPath(t2, e2, i2) {
    t2 && (typeof t2 == "function" ? (this.pathGenerator.generate = t2, e2 && (this.pathGenerator.init = e2), i2 && (this.pathGenerator.update = i2)) : (t2.generate && (this.pathGenerator.generate = t2.generate), t2.init && (this.pathGenerator.init = t2.init), t2.update && (this.pathGenerator.update = t2.update)));
  }
  destroy() {
    this.stop(), this.canvas.destroy();
    for (const [, t2] of this.drawers)
      t2.destroy && t2.destroy(this);
    for (const t2 of this.drawers.keys())
      this.drawers.delete(t2);
    this.destroyed = true;
  }
  exportImg(t2) {
    this.exportImage(t2);
  }
  exportImage(t2, e2, i2) {
    var o2;
    return (o2 = this.canvas.element) === null || o2 === void 0 ? void 0 : o2.toBlob(t2, e2 != null ? e2 : "image/png", i2);
  }
  exportConfiguration() {
    return JSON.stringify(this.actualOptions, void 0, 2);
  }
  refresh() {
    return this.stop(), this.start();
  }
  reset() {
    return this._options = new Mi(), this.refresh();
  }
  stop() {
    if (this.started) {
      this.firstStart = true, this.started = false, this.eventListeners.removeListeners(), this.pause(), this.particles.clear(), this.canvas.clear(), this.interactivity.element instanceof HTMLElement && this.intersectionObserver && this.intersectionObserver.observe(this.interactivity.element);
      for (const [, t2] of this.plugins)
        t2.stop && t2.stop();
      for (const t2 of this.plugins.keys())
        this.plugins.delete(t2);
      this.particles.linksColors = new Map(), delete this.particles.grabLineColor, delete this.particles.linksColor;
    }
  }
  loadTheme(t2) {
    return Ri(this, void 0, void 0, function* () {
      this.actualOptions.setTheme(t2), yield this.refresh();
    });
  }
  start() {
    return Ri(this, void 0, void 0, function* () {
      if (!this.started) {
        yield this.init(), this.started = true, this.eventListeners.addListeners(), this.interactivity.element instanceof HTMLElement && this.intersectionObserver && this.intersectionObserver.observe(this.interactivity.element);
        for (const [, t2] of this.plugins)
          t2.startAsync !== void 0 ? yield t2.startAsync() : t2.start !== void 0 && t2.start();
        this.play();
      }
    });
  }
  init() {
    return Ri(this, void 0, void 0, function* () {
      this.actualOptions = new Mi(), this.actualOptions.load(this._options), this.retina.init(), this.canvas.init(), this.actualOptions.setResponsive(this.canvas.size.width, this.retina.pixelRatio, this._options), this.actualOptions.setTheme(void 0), this.fpsLimit = this.actualOptions.fpsLimit > 0 ? this.actualOptions.fpsLimit : 60;
      const t2 = vt.getAvailablePlugins(this);
      for (const [e2, i2] of t2)
        this.plugins.set(e2, i2);
      for (const [, t3] of this.drawers)
        t3.init && (yield t3.init(this));
      for (const [, t3] of this.plugins)
        t3.init ? t3.init(this.actualOptions) : t3.initAsync !== void 0 && (yield t3.initAsync(this.actualOptions));
      this.canvas.resize(), this.particles.init(), this.particles.setDensity();
    });
  }
  intersectionManager(t2) {
    if (this.actualOptions.pauseOnOutsideViewport)
      for (const e2 of t2)
        e2.target === this.interactivity.element && (e2.isIntersecting ? this.play() : this.pause());
  }
}
var Ci = function(t2, e2, i2, o2) {
  return new (i2 || (i2 = Promise))(function(s2, n2) {
    function a2(t3) {
      try {
        l2(o2.next(t3));
      } catch (t4) {
        n2(t4);
      }
    }
    function r2(t3) {
      try {
        l2(o2.throw(t3));
      } catch (t4) {
        n2(t4);
      }
    }
    function l2(t3) {
      var e3;
      t3.done ? s2(t3.value) : (e3 = t3.value, e3 instanceof i2 ? e3 : new i2(function(t4) {
        t4(e3);
      })).then(a2, r2);
    }
    l2((o2 = o2.apply(t2, e2 || [])).next());
  });
};
const zi = [];
function Ai(t2) {
  console.error(`Error tsParticles - fetch status: ${t2}`), console.error("Error tsParticles - File config not found");
}
class Ti {
  static dom() {
    return zi;
  }
  static domItem(t2) {
    const e2 = Ti.dom(), i2 = e2[t2];
    if (i2 && !i2.destroyed)
      return i2;
    e2.splice(t2, 1);
  }
  static load(t2, e2, i2) {
    return Ci(this, void 0, void 0, function* () {
      const o2 = document.getElementById(t2);
      if (o2)
        return Ti.set(t2, o2, e2, i2);
    });
  }
  static set(t2, e2, i2, o2) {
    return Ci(this, void 0, void 0, function* () {
      const s2 = i2 instanceof Array ? J.itemFromArray(i2, o2) : i2, n2 = Ti.dom(), a2 = n2.findIndex((e3) => e3.id === t2);
      if (a2 >= 0) {
        const t3 = Ti.domItem(a2);
        t3 && !t3.destroyed && (t3.destroy(), n2.splice(a2, 1));
      }
      let r2, l2;
      if (e2.tagName.toLowerCase() === "canvas")
        r2 = e2, l2 = false;
      else {
        const t3 = e2.getElementsByTagName("canvas");
        t3.length ? (r2 = t3[0], r2.className || (r2.className = Q.canvasClass), l2 = false) : (l2 = true, r2 = document.createElement("canvas"), r2.className = Q.canvasClass, r2.style.width = "100%", r2.style.height = "100%", e2.appendChild(r2));
      }
      const c2 = new Si(t2, s2);
      return a2 >= 0 ? n2.splice(a2, 0, c2) : n2.push(c2), c2.canvas.loadCanvas(r2, l2), yield c2.start(), c2;
    });
  }
  static loadJSON(t2, e2, i2) {
    return Ci(this, void 0, void 0, function* () {
      const o2 = e2 instanceof Array ? J.itemFromArray(e2, i2) : e2, s2 = yield fetch(o2);
      if (s2.ok)
        return Ti.load(t2, yield s2.json());
      Ai(s2.status);
    });
  }
  static setJSON(t2, e2, i2) {
    return Ci(this, void 0, void 0, function* () {
      const o2 = yield fetch(i2);
      if (o2.ok) {
        const i3 = yield o2.json();
        return Ti.set(t2, e2, i3);
      }
      Ai(o2.status);
    });
  }
  static setOnClickHandler(t2) {
    const e2 = Ti.dom();
    if (e2.length === 0)
      throw new Error("Can only set click handlers after calling tsParticles.load() or tsParticles.loadJSON()");
    for (const i2 of e2) {
      const e3 = i2.interactivity.element;
      if (!e3)
        continue;
      const o2 = (e4, o3) => {
        if (i2.destroyed)
          return;
        const s3 = i2.retina.pixelRatio, n3 = {x: o3.x * s3, y: o3.y * s3}, a3 = i2.particles.quadTree.queryCircle(n3, i2.retina.sizeValue);
        t2(e4, a3);
      }, s2 = (t3) => {
        if (i2.destroyed)
          return;
        const e4 = t3, s3 = {x: e4.offsetX || e4.clientX, y: e4.offsetY || e4.clientY};
        o2(t3, s3);
      }, n2 = () => {
        i2.destroyed || (c2 = true, d2 = false);
      }, a2 = () => {
        i2.destroyed || (d2 = true);
      }, r2 = (t3) => {
        var e4, s3, n3;
        if (!i2.destroyed) {
          if (c2 && !d2) {
            const a3 = t3, r3 = a3.touches[a3.touches.length - 1], l3 = (e4 = i2.canvas.element) === null || e4 === void 0 ? void 0 : e4.getBoundingClientRect(), c3 = {x: r3.clientX - ((s3 = l3 == null ? void 0 : l3.left) !== null && s3 !== void 0 ? s3 : 0), y: r3.clientY - ((n3 = l3 == null ? void 0 : l3.top) !== null && n3 !== void 0 ? n3 : 0)};
            o2(t3, c3);
          }
          c2 = false, d2 = false;
        }
      }, l2 = () => {
        i2.destroyed || (c2 = false, d2 = false);
      };
      let c2 = false, d2 = false;
      e3.addEventListener("click", s2), e3.addEventListener("touchstart", n2), e3.addEventListener("touchmove", a2), e3.addEventListener("touchend", r2), e3.addEventListener("touchcancel", l2);
    }
  }
}
var Ei, Di, Oi = function(t2, e2, i2, o2) {
  return new (i2 || (i2 = Promise))(function(s2, n2) {
    function a2(t3) {
      try {
        l2(o2.next(t3));
      } catch (t4) {
        n2(t4);
      }
    }
    function r2(t3) {
      try {
        l2(o2.throw(t3));
      } catch (t4) {
        n2(t4);
      }
    }
    function l2(t3) {
      var e3;
      t3.done ? s2(t3.value) : (e3 = t3.value, e3 instanceof i2 ? e3 : new i2(function(t4) {
        t4(e3);
      })).then(a2, r2);
    }
    l2((o2 = o2.apply(t2, e2 || [])).next());
  });
}, Ii = function(t2, e2, i2) {
  if (!e2.has(t2))
    throw new TypeError("attempted to set private field on non-instance");
  return e2.set(t2, i2), i2;
}, Fi = function(t2, e2) {
  if (!e2.has(t2))
    throw new TypeError("attempted to get private field on non-instance");
  return e2.get(t2);
};
Ei = new WeakMap();
class Li {
  constructor(t2, e2, i2, o2) {
    var s2, n2, a2;
    this.absorbers = t2, this.container = e2, this.initialPosition = o2 ? T.create(o2.x, o2.y) : void 0, this.options = i2, this.dragging = false, this.name = this.options.name, this.opacity = this.options.opacity, this.size = E.getValue(i2.size) * e2.retina.pixelRatio, this.mass = this.size * i2.size.density * e2.retina.reduceFactor;
    const r2 = i2.size.limit;
    this.limit = r2 !== void 0 ? r2 * e2.retina.pixelRatio * e2.retina.reduceFactor : r2;
    const l2 = typeof i2.color == "string" ? {value: i2.color} : i2.color;
    this.color = (s2 = tt.colorToRgb(l2)) !== null && s2 !== void 0 ? s2 : {b: 0, g: 0, r: 0}, this.position = (a2 = (n2 = this.initialPosition) === null || n2 === void 0 ? void 0 : n2.copy()) !== null && a2 !== void 0 ? a2 : this.calcPosition();
  }
  attract(t2) {
    const e2 = this.options;
    if (e2.draggable) {
      const t3 = this.container.interactivity.mouse;
      if (t3.clicking && t3.downPosition) {
        E.getDistance(this.position, t3.downPosition) <= this.size && (this.dragging = true);
      } else
        this.dragging = false;
      this.dragging && t3.position && (this.position.x = t3.position.x, this.position.y = t3.position.y);
    }
    const i2 = t2.getPosition(), {dx: o2, dy: s2, distance: n2} = E.getDistances(this.position, i2), a2 = T.create(o2, s2);
    if (a2.length = this.mass / Math.pow(n2, 2) * this.container.retina.reduceFactor, n2 < this.size + t2.getRadius()) {
      const i3 = 0.033 * t2.getRadius() * this.container.retina.pixelRatio;
      this.size > t2.getRadius() && n2 < this.size - t2.getRadius() ? e2.destroy ? t2.destroy() : (t2.needsNewPosition = true, this.updateParticlePosition(t2, a2)) : (e2.destroy && (t2.size.value -= i3), this.updateParticlePosition(t2, a2)), (this.limit === void 0 || this.size < this.limit) && (this.size += i3), this.mass += i3 * this.options.size.density * this.container.retina.reduceFactor;
    } else
      this.updateParticlePosition(t2, a2);
  }
  resize() {
    const t2 = this.initialPosition;
    this.position = t2 && J.isPointInside(t2, this.container.canvas.size) ? t2 : this.calcPosition();
  }
  draw(t2) {
    t2.translate(this.position.x, this.position.y), t2.beginPath(), t2.arc(0, 0, this.size, 0, 2 * Math.PI, false), t2.closePath(), t2.fillStyle = tt.getStyleFromRgb(this.color, this.opacity), t2.fill();
  }
  calcPosition() {
    var t2, e2;
    const i2 = this.container, o2 = this.options.position;
    return T.create(((t2 = o2 == null ? void 0 : o2.x) !== null && t2 !== void 0 ? t2 : 100 * Math.random()) / 100 * i2.canvas.size.width, ((e2 = o2 == null ? void 0 : o2.y) !== null && e2 !== void 0 ? e2 : 100 * Math.random()) / 100 * i2.canvas.size.height);
  }
  updateParticlePosition(t2, e2) {
    var i2;
    if (t2.destroyed)
      return;
    const o2 = this.container.canvas.size;
    if (t2.needsNewPosition) {
      const e3 = t2.getRadius();
      t2.position.x = Math.random() * (o2.width - 2 * e3) + e3, t2.position.y = Math.random() * (o2.height - 2 * e3) + e3, t2.needsNewPosition = false;
    }
    this.options.orbits ? (t2.orbit === void 0 && (t2.orbit = T.create(0, 0), t2.orbit.length = E.getDistance(t2.getPosition(), this.position), t2.orbit.angle = Math.random() * Math.PI * 2), t2.orbit.length <= this.size && !this.options.destroy && (t2.orbit.length = Math.random() * Math.max(o2.width, o2.height)), t2.velocity.x = 0, t2.velocity.y = 0, t2.position.setTo(t2.orbit.add(this.position)), t2.orbit.length -= e2.length, t2.orbit.angle += ((i2 = t2.moveSpeed) !== null && i2 !== void 0 ? i2 : E.getRangeValue(t2.options.move.speed) * this.container.retina.pixelRatio) / 100 * this.container.retina.reduceFactor) : t2.velocity.addTo(e2);
  }
}
class Vi extends Lt {
  constructor() {
    super(), this.density = 5, this.random.minimumValue = 1, this.value = 50;
  }
  load(t2) {
    t2 && (super.load(t2), t2.density !== void 0 && (this.density = t2.density), t2.limit !== void 0 && (this.limit = t2.limit), t2.limit !== void 0 && (this.limit = t2.limit));
  }
}
class Hi {
  constructor() {
    this.color = new At(), this.color.value = "#000000", this.draggable = false, this.opacity = 1, this.destroy = true, this.orbits = false, this.size = new Vi();
  }
  load(t2) {
    t2 !== void 0 && (t2.color !== void 0 && (this.color = At.create(this.color, t2.color)), t2.draggable !== void 0 && (this.draggable = t2.draggable), this.name = t2.name, t2.opacity !== void 0 && (this.opacity = t2.opacity), t2.position !== void 0 && (this.position = {x: t2.position.x, y: t2.position.y}), t2.size !== void 0 && this.size.load(t2.size), t2.destroy !== void 0 && (this.destroy = t2.destroy), t2.orbits !== void 0 && (this.orbits = t2.orbits));
  }
}
!function(t2) {
  t2.absorber = "absorber";
}(Di || (Di = {}));
class _i {
  constructor(t2) {
    this.container = t2, this.array = [], this.absorbers = [], this.interactivityAbsorbers = [];
    t2.addAbsorber = (t3, e2) => this.addAbsorber(t3, e2);
  }
  init(t2) {
    var e2, i2;
    if (!t2)
      return;
    t2.absorbers && (t2.absorbers instanceof Array ? this.absorbers = t2.absorbers.map((t3) => {
      const e3 = new Hi();
      return e3.load(t3), e3;
    }) : (this.absorbers instanceof Array && (this.absorbers = new Hi()), this.absorbers.load(t2.absorbers)));
    const o2 = (i2 = (e2 = t2.interactivity) === null || e2 === void 0 ? void 0 : e2.modes) === null || i2 === void 0 ? void 0 : i2.absorbers;
    if (o2 && (o2 instanceof Array ? this.interactivityAbsorbers = o2.map((t3) => {
      const e3 = new Hi();
      return e3.load(t3), e3;
    }) : (this.interactivityAbsorbers instanceof Array && (this.interactivityAbsorbers = new Hi()), this.interactivityAbsorbers.load(o2))), this.absorbers instanceof Array)
      for (const t3 of this.absorbers)
        this.addAbsorber(t3);
    else
      this.addAbsorber(this.absorbers);
  }
  particleUpdate(t2) {
    for (const e2 of this.array)
      if (e2.attract(t2), t2.destroyed)
        break;
  }
  draw(t2) {
    for (const e2 of this.array)
      t2.save(), e2.draw(t2), t2.restore();
  }
  stop() {
    this.array = [];
  }
  resize() {
    for (const t2 of this.array)
      t2.resize();
  }
  handleClickMode(t2) {
    const e2 = this.container, i2 = this.absorbers, o2 = this.interactivityAbsorbers;
    if (t2 === Di.absorber) {
      let t3;
      o2 instanceof Array ? o2.length > 0 && (t3 = J.itemFromArray(o2)) : t3 = o2;
      const s2 = t3 != null ? t3 : i2 instanceof Array ? J.itemFromArray(i2) : i2, n2 = e2.interactivity.mouse.clickPosition;
      this.addAbsorber(s2, n2);
    }
  }
  addAbsorber(t2, e2) {
    const i2 = new Li(this, this.container, t2, e2);
    return this.array.push(i2), i2;
  }
  removeAbsorber(t2) {
    const e2 = this.array.indexOf(t2);
    e2 >= 0 && this.array.splice(e2, 1);
  }
}
const qi = new class {
  constructor() {
    this.id = "absorbers";
  }
  getPlugin(t2) {
    return new _i(t2);
  }
  needsPlugin(t2) {
    var e2, i2, o2;
    if (t2 === void 0)
      return false;
    const s2 = t2.absorbers;
    let n2 = false;
    return s2 instanceof Array ? s2.length && (n2 = true) : (s2 !== void 0 || ((o2 = (i2 = (e2 = t2.interactivity) === null || e2 === void 0 ? void 0 : e2.events) === null || i2 === void 0 ? void 0 : i2.onClick) === null || o2 === void 0 ? void 0 : o2.mode) && J.isInArray(Di.absorber, t2.interactivity.events.onClick.mode)) && (n2 = true), n2;
  }
  loadOptions(t2, e2) {
    var i2, o2;
    if (!this.needsPlugin(t2) && !this.needsPlugin(e2))
      return;
    const s2 = t2;
    if (e2 == null ? void 0 : e2.absorbers)
      if ((e2 == null ? void 0 : e2.absorbers) instanceof Array)
        s2.absorbers = e2 == null ? void 0 : e2.absorbers.map((t3) => {
          const e3 = new Hi();
          return e3.load(t3), e3;
        });
      else {
        let t3 = s2.absorbers;
        (t3 == null ? void 0 : t3.load) === void 0 && (s2.absorbers = t3 = new Hi()), t3.load(e2 == null ? void 0 : e2.absorbers);
      }
    const n2 = (o2 = (i2 = e2 == null ? void 0 : e2.interactivity) === null || i2 === void 0 ? void 0 : i2.modes) === null || o2 === void 0 ? void 0 : o2.absorbers;
    if (n2)
      if (n2 instanceof Array)
        s2.interactivity.modes.absorbers = n2.map((t3) => {
          const e3 = new Hi();
          return e3.load(t3), e3;
        });
      else {
        let t3 = s2.interactivity.modes.absorbers;
        (t3 == null ? void 0 : t3.load) === void 0 && (s2.interactivity.modes.absorbers = t3 = new Hi()), t3.load(n2);
      }
  }
}();
class Bi {
  constructor() {
    this.mode = H.percent, this.height = 0, this.width = 0;
  }
  load(t2) {
    t2 !== void 0 && (t2.mode !== void 0 && (this.mode = t2.mode), t2.height !== void 0 && (this.height = t2.height), t2.width !== void 0 && (this.width = t2.width));
  }
}
function $i(t2, e2) {
  return t2 + e2 * (Math.random() - 0.5);
}
function Wi(t2, e2) {
  return {x: $i(t2.x, e2.x), y: $i(t2.y, e2.y)};
}
class Gi {
  constructor(t2, e2, i2, o2) {
    var s2, n2, a2, r2;
    this.emitters = t2, this.container = e2, this.firstSpawn = true, this.currentDuration = 0, this.currentEmitDelay = 0, this.currentSpawnDelay = 0, this.initialPosition = o2, this.emitterOptions = J.deepExtend({}, i2), this.spawnDelay = 1e3 * ((s2 = this.emitterOptions.life.delay) !== null && s2 !== void 0 ? s2 : 0) / this.container.retina.reduceFactor, this.position = (n2 = this.initialPosition) !== null && n2 !== void 0 ? n2 : this.calcPosition(), this.name = i2.name;
    let l2 = J.deepExtend({}, this.emitterOptions.particles);
    l2 === void 0 && (l2 = {}), l2.move === void 0 && (l2.move = {}), l2.move.direction === void 0 && (l2.move.direction = this.emitterOptions.direction), this.emitterOptions.spawnColor !== void 0 && (this.spawnColor = tt.colorToHsl(this.emitterOptions.spawnColor)), this.paused = !this.emitterOptions.autoPlay, this.particlesOptions = l2, this.size = (a2 = this.emitterOptions.size) !== null && a2 !== void 0 ? a2 : (() => {
      const t3 = new Bi();
      return t3.load({height: 0, mode: H.percent, width: 0}), t3;
    })(), this.lifeCount = (r2 = this.emitterOptions.life.count) !== null && r2 !== void 0 ? r2 : -1, this.immortal = this.lifeCount <= 0, this.play();
  }
  externalPlay() {
    this.paused = false, this.play();
  }
  externalPause() {
    this.paused = true, this.pause();
  }
  play() {
    this.paused || this.container.retina.reduceFactor && (this.lifeCount > 0 || this.immortal || !this.emitterOptions.life.count) && (this.emitDelay === void 0 && (this.emitDelay = 1e3 * this.emitterOptions.rate.delay / this.container.retina.reduceFactor), (this.lifeCount > 0 || this.immortal) && this.prepareToDie());
  }
  pause() {
    this.paused || delete this.emitDelay;
  }
  resize() {
    const t2 = this.initialPosition;
    this.position = t2 && J.isPointInside(t2, this.container.canvas.size) ? t2 : this.calcPosition();
  }
  update(t2) {
    var e2, i2, o2;
    this.paused || (this.firstSpawn && (this.firstSpawn = false, this.currentSpawnDelay = (e2 = this.spawnDelay) !== null && e2 !== void 0 ? e2 : 0, this.currentEmitDelay = (i2 = this.emitDelay) !== null && i2 !== void 0 ? i2 : 0, t2.value = 0), this.duration !== void 0 && (this.currentDuration += t2.value, this.currentDuration >= this.duration && (this.pause(), this.spawnDelay !== void 0 && delete this.spawnDelay, this.immortal || this.lifeCount--, this.lifeCount > 0 || this.immortal ? (this.position = this.calcPosition(), this.spawnDelay = 1e3 * ((o2 = this.emitterOptions.life.delay) !== null && o2 !== void 0 ? o2 : 0) / this.container.retina.reduceFactor) : this.destroy(), this.currentDuration -= this.duration, delete this.duration)), this.spawnDelay !== void 0 && (this.currentSpawnDelay += t2.value, this.currentSpawnDelay >= this.spawnDelay && (this.play(), this.currentSpawnDelay -= this.currentSpawnDelay, delete this.spawnDelay)), this.emitDelay !== void 0 && (this.currentEmitDelay += t2.value, this.currentEmitDelay >= this.emitDelay && (this.emit(), this.currentEmitDelay -= this.emitDelay)));
  }
  prepareToDie() {
    var t2;
    if (this.paused)
      return;
    const e2 = (t2 = this.emitterOptions.life) === null || t2 === void 0 ? void 0 : t2.duration;
    this.container.retina.reduceFactor && (this.lifeCount > 0 || this.immortal) && e2 !== void 0 && e2 > 0 && (this.duration = 1e3 * e2);
  }
  destroy() {
    this.emitters.removeEmitter(this);
  }
  calcPosition() {
    var t2, e2;
    const i2 = this.container, o2 = this.emitterOptions.position;
    return {x: ((t2 = o2 == null ? void 0 : o2.x) !== null && t2 !== void 0 ? t2 : 100 * Math.random()) / 100 * i2.canvas.size.width, y: ((e2 = o2 == null ? void 0 : o2.y) !== null && e2 !== void 0 ? e2 : 100 * Math.random()) / 100 * i2.canvas.size.height};
  }
  emit() {
    var t2;
    if (this.paused)
      return;
    const e2 = this.container, i2 = this.position, o2 = {x: this.size.mode === H.percent ? e2.canvas.size.width * this.size.width / 100 : this.size.width, y: this.size.mode === H.percent ? e2.canvas.size.height * this.size.height / 100 : this.size.height};
    for (let s2 = 0; s2 < this.emitterOptions.rate.quantity; s2++) {
      const s3 = J.deepExtend({}, this.particlesOptions);
      if (this.spawnColor !== void 0) {
        const e3 = (t2 = this.emitterOptions.spawnColor) === null || t2 === void 0 ? void 0 : t2.animation;
        if (e3) {
          const t3 = e3;
          if (t3.enable)
            this.spawnColor.h = this.setColorAnimation(t3, this.spawnColor.h, 360);
          else {
            const t4 = e3;
            this.spawnColor.h = this.setColorAnimation(t4.h, this.spawnColor.h, 360), this.spawnColor.s = this.setColorAnimation(t4.s, this.spawnColor.s, 100), this.spawnColor.l = this.setColorAnimation(t4.l, this.spawnColor.l, 100);
          }
        }
        s3.color ? s3.color.value = this.spawnColor : s3.color = {value: this.spawnColor};
      }
      e2.particles.addParticle(Wi(i2, o2), s3);
    }
  }
  setColorAnimation(t2, e2, i2) {
    var o2;
    const s2 = this.container;
    if (!t2.enable)
      return e2;
    const n2 = E.randomInRange(t2.offset), a2 = 1e3 * this.emitterOptions.rate.delay / s2.retina.reduceFactor;
    return (e2 + ((o2 = t2.speed) !== null && o2 !== void 0 ? o2 : 0) * s2.fpsLimit / a2 + 3.6 * n2) % i2;
  }
}
class Ni {
  constructor() {
    this.quantity = 1, this.delay = 0.1;
  }
  load(t2) {
    t2 !== void 0 && (t2.quantity !== void 0 && (this.quantity = t2.quantity), t2.delay !== void 0 && (this.delay = t2.delay));
  }
}
class Ui {
  load(t2) {
    t2 !== void 0 && (t2.count !== void 0 && (this.count = t2.count), t2.delay !== void 0 && (this.delay = t2.delay), t2.duration !== void 0 && (this.duration = t2.duration));
  }
}
class ji {
  constructor() {
    this.autoPlay = true, this.direction = z.none, this.life = new Ui(), this.rate = new Ni();
  }
  load(t2) {
    t2 !== void 0 && (t2.autoPlay !== void 0 && (this.autoPlay = t2.autoPlay), t2.size !== void 0 && (this.size === void 0 && (this.size = new Bi()), this.size.load(t2.size)), t2.direction !== void 0 && (this.direction = t2.direction), this.life.load(t2.life), this.name = t2.name, t2.particles !== void 0 && (this.particles = J.deepExtend({}, t2.particles)), this.rate.load(t2.rate), t2.position !== void 0 && (this.position = {x: t2.position.x, y: t2.position.y}), t2.spawnColor !== void 0 && (this.spawnColor === void 0 && (this.spawnColor = new ie()), this.spawnColor.load(t2.spawnColor)));
  }
}
var Yi;
!function(t2) {
  t2.emitter = "emitter";
}(Yi || (Yi = {}));
class Xi {
  constructor(t2) {
    this.container = t2, this.array = [], this.emitters = [], this.interactivityEmitters = [];
    const e2 = t2;
    e2.addEmitter = (t3, e3) => this.addEmitter(t3, e3), e2.playEmitter = (t3) => {
      const e3 = t3 === void 0 || typeof t3 == "number" ? this.array[t3 || 0] : this.array.find((e4) => e4.name === t3);
      e3 && e3.externalPlay();
    }, e2.pauseEmitter = (t3) => {
      const e3 = t3 === void 0 || typeof t3 == "number" ? this.array[t3 || 0] : this.array.find((e4) => e4.name === t3);
      e3 && e3.externalPause();
    };
  }
  init(t2) {
    var e2, i2;
    if (!t2)
      return;
    t2.emitters && (t2.emitters instanceof Array ? this.emitters = t2.emitters.map((t3) => {
      const e3 = new ji();
      return e3.load(t3), e3;
    }) : (this.emitters instanceof Array && (this.emitters = new ji()), this.emitters.load(t2.emitters)));
    const o2 = (i2 = (e2 = t2.interactivity) === null || e2 === void 0 ? void 0 : e2.modes) === null || i2 === void 0 ? void 0 : i2.emitters;
    if (o2 && (o2 instanceof Array ? this.interactivityEmitters = o2.map((t3) => {
      const e3 = new ji();
      return e3.load(t3), e3;
    }) : (this.interactivityEmitters instanceof Array && (this.interactivityEmitters = new ji()), this.interactivityEmitters.load(o2))), this.emitters instanceof Array)
      for (const t3 of this.emitters)
        this.addEmitter(t3);
    else
      this.addEmitter(this.emitters);
  }
  play() {
    for (const t2 of this.array)
      t2.play();
  }
  pause() {
    for (const t2 of this.array)
      t2.pause();
  }
  stop() {
    this.array = [];
  }
  update(t2) {
    for (const e2 of this.array)
      e2.update(t2);
  }
  handleClickMode(t2) {
    const e2 = this.container, i2 = this.emitters, o2 = this.interactivityEmitters;
    if (t2 === Yi.emitter) {
      let t3;
      o2 instanceof Array ? o2.length > 0 && (t3 = J.itemFromArray(o2)) : t3 = o2;
      const s2 = t3 != null ? t3 : i2 instanceof Array ? J.itemFromArray(i2) : i2, n2 = e2.interactivity.mouse.clickPosition;
      this.addEmitter(J.deepExtend({}, s2), n2);
    }
  }
  resize() {
    for (const t2 of this.array)
      t2.resize();
  }
  addEmitter(t2, e2) {
    const i2 = new Gi(this, this.container, t2, e2);
    return this.array.push(i2), i2;
  }
  removeEmitter(t2) {
    const e2 = this.array.indexOf(t2);
    e2 >= 0 && this.array.splice(e2, 1);
  }
}
const Ji = new class {
  constructor() {
    this.id = "emitters";
  }
  getPlugin(t2) {
    return new Xi(t2);
  }
  needsPlugin(t2) {
    var e2, i2, o2;
    if (t2 === void 0)
      return false;
    const s2 = t2.emitters;
    let n2 = false;
    return s2 instanceof Array ? s2.length && (n2 = true) : (s2 !== void 0 || ((o2 = (i2 = (e2 = t2.interactivity) === null || e2 === void 0 ? void 0 : e2.events) === null || i2 === void 0 ? void 0 : i2.onClick) === null || o2 === void 0 ? void 0 : o2.mode) && J.isInArray(Yi.emitter, t2.interactivity.events.onClick.mode)) && (n2 = true), n2;
  }
  loadOptions(t2, e2) {
    var i2, o2;
    if (!this.needsPlugin(t2) && !this.needsPlugin(e2))
      return;
    const s2 = t2;
    if (e2 == null ? void 0 : e2.emitters)
      if ((e2 == null ? void 0 : e2.emitters) instanceof Array)
        s2.emitters = e2 == null ? void 0 : e2.emitters.map((t3) => {
          const e3 = new ji();
          return e3.load(t3), e3;
        });
      else {
        let t3 = s2.emitters;
        (t3 == null ? void 0 : t3.load) === void 0 && (s2.emitters = t3 = new ji()), t3.load(e2 == null ? void 0 : e2.emitters);
      }
    const n2 = (o2 = (i2 = e2 == null ? void 0 : e2.interactivity) === null || i2 === void 0 ? void 0 : i2.modes) === null || o2 === void 0 ? void 0 : o2.emitters;
    if (n2)
      if (n2 instanceof Array)
        s2.interactivity.modes.emitters = n2.map((t3) => {
          const e3 = new ji();
          return e3.load(t3), e3;
        });
      else {
        let t3 = s2.interactivity.modes.emitters;
        (t3 == null ? void 0 : t3.load) === void 0 && (s2.interactivity.modes.emitters = t3 = new ji()), t3.load(n2);
      }
  }
}();
var Qi, Zi, Ki;
!function(t2) {
  t2.equidistant = "equidistant", t2.onePerPoint = "one-per-point", t2.perPoint = "per-point", t2.randomLength = "random-length", t2.randomPoint = "random-point";
}(Qi || (Qi = {})), function(t2) {
  t2.path = "path", t2.radius = "radius";
}(Zi || (Zi = {})), function(t2) {
  t2.inline = "inline", t2.inside = "inside", t2.outside = "outside", t2.none = "none";
}(Ki || (Ki = {}));
class to {
  constructor() {
    this.color = new At(), this.width = 0.5, this.opacity = 1;
  }
  load(t2) {
    var e2;
    t2 !== void 0 && (this.color = At.create(this.color, t2.color), typeof this.color.value == "string" && (this.opacity = (e2 = tt.stringToAlpha(this.color.value)) !== null && e2 !== void 0 ? e2 : this.opacity), t2.opacity !== void 0 && (this.opacity = t2.opacity), t2.width !== void 0 && (this.width = t2.width));
  }
}
class eo {
  constructor() {
    this.enable = false, this.stroke = new to();
  }
  get lineWidth() {
    return this.stroke.width;
  }
  set lineWidth(t2) {
    this.stroke.width = t2;
  }
  get lineColor() {
    return this.stroke.color;
  }
  set lineColor(t2) {
    this.stroke.color = At.create(this.stroke.color, t2);
  }
  load(t2) {
    var e2;
    if (t2 !== void 0) {
      t2.enable !== void 0 && (this.enable = t2.enable);
      const i2 = (e2 = t2.stroke) !== null && e2 !== void 0 ? e2 : {color: t2.lineColor, width: t2.lineWidth};
      this.stroke.load(i2);
    }
  }
}
class io {
  constructor() {
    this.radius = 10, this.type = Zi.path;
  }
  load(t2) {
    t2 !== void 0 && (t2.radius !== void 0 && (this.radius = t2.radius), t2.type !== void 0 && (this.type = t2.type));
  }
}
class oo {
  constructor() {
    this.arrangement = Qi.onePerPoint;
  }
  load(t2) {
    t2 !== void 0 && t2.arrangement !== void 0 && (this.arrangement = t2.arrangement);
  }
}
class so {
  constructor() {
    this.path = [], this.size = {height: 0, width: 0};
  }
  load(t2) {
    t2 !== void 0 && (t2.path !== void 0 && (this.path = t2.path), t2.size !== void 0 && (t2.size.width !== void 0 && (this.size.width = t2.size.width), t2.size.height !== void 0 && (this.size.height = t2.size.height)));
  }
}
class no {
  constructor() {
    this.draw = new eo(), this.enable = false, this.inline = new oo(), this.move = new io(), this.scale = 1, this.type = Ki.none;
  }
  get inlineArrangement() {
    return this.inline.arrangement;
  }
  set inlineArrangement(t2) {
    this.inline.arrangement = t2;
  }
  load(t2) {
    var e2;
    if (t2 !== void 0) {
      this.draw.load(t2.draw);
      const i2 = (e2 = t2.inline) !== null && e2 !== void 0 ? e2 : {arrangement: t2.inlineArrangement};
      i2 !== void 0 && this.inline.load(i2), this.move.load(t2.move), t2.scale !== void 0 && (this.scale = t2.scale), t2.type !== void 0 && (this.type = t2.type), t2.enable !== void 0 ? this.enable = t2.enable : this.enable = this.type !== Ki.none, t2.url !== void 0 && (this.url = t2.url), t2.data !== void 0 && (typeof t2.data == "string" ? this.data = t2.data : (this.data = new so(), this.data.load(t2.data))), t2.position !== void 0 && (this.position = J.deepExtend({}, t2.position));
    }
  }
}
var ao = function(t2, e2, i2, o2) {
  return new (i2 || (i2 = Promise))(function(s2, n2) {
    function a2(t3) {
      try {
        l2(o2.next(t3));
      } catch (t4) {
        n2(t4);
      }
    }
    function r2(t3) {
      try {
        l2(o2.throw(t3));
      } catch (t4) {
        n2(t4);
      }
    }
    function l2(t3) {
      var e3;
      t3.done ? s2(t3.value) : (e3 = t3.value, e3 instanceof i2 ? e3 : new i2(function(t4) {
        t4(e3);
      })).then(a2, r2);
    }
    l2((o2 = o2.apply(t2, e2 || [])).next());
  });
};
function ro(t2) {
  t2.velocity.x = t2.velocity.y / 2 - t2.velocity.x, t2.velocity.y = t2.velocity.x / 2 - t2.velocity.y;
}
function lo(t2, e2, i2) {
  const o2 = tt.colorToRgb(i2.color);
  if (o2) {
    t2.beginPath(), t2.moveTo(e2[0].x, e2[0].y);
    for (const i3 of e2)
      t2.lineTo(i3.x, i3.y);
    t2.closePath(), t2.strokeStyle = tt.getStyleFromRgb(o2), t2.lineWidth = i2.width, t2.stroke();
  }
}
function co(t2, e2, i2, o2) {
  t2.translate(o2.x, o2.y);
  const s2 = tt.colorToRgb(i2.color);
  s2 && (t2.strokeStyle = tt.getStyleFromRgb(s2, i2.opacity), t2.lineWidth = i2.width, t2.stroke(e2));
}
class ho {
  constructor(t2) {
    this.container = t2, this.dimension = {height: 0, width: 0}, this.path2DSupported = !!window.Path2D, this.options = new no(), this.polygonMaskMoveRadius = this.options.move.radius * t2.retina.pixelRatio;
  }
  initAsync(t2) {
    return ao(this, void 0, void 0, function* () {
      this.options.load(t2 == null ? void 0 : t2.polygon);
      const e2 = this.options;
      this.polygonMaskMoveRadius = e2.move.radius * this.container.retina.pixelRatio, e2.enable && (yield this.initRawData());
    });
  }
  resize() {
    const t2 = this.container, e2 = this.options;
    e2.enable && e2.type !== Ki.none && (this.redrawTimeout && clearTimeout(this.redrawTimeout), this.redrawTimeout = window.setTimeout(() => ao(this, void 0, void 0, function* () {
      yield this.initRawData(true), t2.particles.redraw();
    }), 250));
  }
  stop() {
    delete this.raw, delete this.paths;
  }
  particlesInitialization() {
    const t2 = this.options;
    return !(!t2.enable || t2.type !== Ki.inline || t2.inline.arrangement !== Qi.onePerPoint && t2.inline.arrangement !== Qi.perPoint) && (this.drawPoints(), true);
  }
  particlePosition(t2) {
    var e2, i2;
    if (this.options.enable && ((i2 = (e2 = this.raw) === null || e2 === void 0 ? void 0 : e2.length) !== null && i2 !== void 0 ? i2 : 0) > 0)
      return J.deepExtend({}, t2 || this.randomPoint());
  }
  particleBounce(t2) {
    const e2 = this.options;
    if (e2.enable && e2.type !== Ki.none && e2.type !== Ki.inline) {
      if (!this.checkInsidePolygon(t2.getPosition()))
        return ro(t2), true;
    } else if (e2.enable && e2.type === Ki.inline && t2.initialPosition) {
      if (E.getDistance(t2.initialPosition, t2.getPosition()) > this.polygonMaskMoveRadius)
        return ro(t2), true;
    }
    return false;
  }
  clickPositionValid(t2) {
    const e2 = this.options;
    return e2.enable && e2.type !== Ki.none && e2.type !== Ki.inline && this.checkInsidePolygon(t2);
  }
  draw(t2) {
    var e2;
    if (!((e2 = this.paths) === null || e2 === void 0 ? void 0 : e2.length))
      return;
    const i2 = this.options, o2 = i2.draw;
    if (!i2.enable || !o2.enable)
      return;
    const s2 = this.raw;
    for (const e3 of this.paths) {
      const i3 = e3.path2d, n2 = this.path2DSupported;
      t2 && (n2 && i3 && this.offset ? co(t2, i3, o2.stroke, this.offset) : s2 && lo(t2, s2, o2.stroke));
    }
  }
  checkInsidePolygon(t2) {
    var e2, i2;
    const o2 = this.container, s2 = this.options;
    if (!s2.enable || s2.type === Ki.none || s2.type === Ki.inline)
      return true;
    if (!this.raw)
      throw new Error(Q.noPolygonFound);
    const n2 = o2.canvas.size, a2 = (e2 = t2 == null ? void 0 : t2.x) !== null && e2 !== void 0 ? e2 : Math.random() * n2.width, r2 = (i2 = t2 == null ? void 0 : t2.y) !== null && i2 !== void 0 ? i2 : Math.random() * n2.height;
    let l2 = false;
    for (let t3 = 0, e3 = this.raw.length - 1; t3 < this.raw.length; e3 = t3++) {
      const i3 = this.raw[t3], o3 = this.raw[e3];
      i3.y > r2 != o3.y > r2 && a2 < (o3.x - i3.x) * (r2 - i3.y) / (o3.y - i3.y) + i3.x && (l2 = !l2);
    }
    return s2.type === Ki.inside ? l2 : s2.type === Ki.outside && !l2;
  }
  parseSvgPath(t2, e2) {
    var i2, o2, s2;
    const n2 = e2 != null && e2;
    if (this.paths !== void 0 && !n2)
      return this.raw;
    const a2 = this.container, r2 = this.options, l2 = new DOMParser().parseFromString(t2, "image/svg+xml"), c2 = l2.getElementsByTagName("svg")[0];
    let d2 = c2.getElementsByTagName("path");
    d2.length || (d2 = l2.getElementsByTagName("path")), this.paths = [];
    for (let t3 = 0; t3 < d2.length; t3++) {
      const e3 = d2.item(t3);
      e3 && this.paths.push({element: e3, length: e3.getTotalLength()});
    }
    const h2 = a2.retina.pixelRatio, u2 = r2.scale / h2;
    this.dimension.width = parseFloat((i2 = c2.getAttribute("width")) !== null && i2 !== void 0 ? i2 : "0") * u2, this.dimension.height = parseFloat((o2 = c2.getAttribute("height")) !== null && o2 !== void 0 ? o2 : "0") * u2;
    const v2 = (s2 = r2.position) !== null && s2 !== void 0 ? s2 : {x: 50, y: 50};
    return this.offset = {x: a2.canvas.size.width * v2.x / (100 * h2) - this.dimension.width / 2, y: a2.canvas.size.height * v2.y / (100 * h2) - this.dimension.height / 2}, function(t3, e3, i3) {
      const o3 = [];
      for (const s3 of t3) {
        const t4 = s3.element.pathSegList, n3 = t4.numberOfItems, a3 = {x: 0, y: 0};
        for (let s4 = 0; s4 < n3; s4++) {
          const n4 = t4.getItem(s4), r3 = window.SVGPathSeg;
          switch (n4.pathSegType) {
            case r3.PATHSEG_MOVETO_ABS:
            case r3.PATHSEG_LINETO_ABS:
            case r3.PATHSEG_CURVETO_CUBIC_ABS:
            case r3.PATHSEG_CURVETO_QUADRATIC_ABS:
            case r3.PATHSEG_ARC_ABS:
            case r3.PATHSEG_CURVETO_CUBIC_SMOOTH_ABS:
            case r3.PATHSEG_CURVETO_QUADRATIC_SMOOTH_ABS: {
              const t5 = n4;
              a3.x = t5.x, a3.y = t5.y;
              break;
            }
            case r3.PATHSEG_LINETO_HORIZONTAL_ABS:
              a3.x = n4.x;
              break;
            case r3.PATHSEG_LINETO_VERTICAL_ABS:
              a3.y = n4.y;
              break;
            case r3.PATHSEG_LINETO_REL:
            case r3.PATHSEG_MOVETO_REL:
            case r3.PATHSEG_CURVETO_CUBIC_REL:
            case r3.PATHSEG_CURVETO_QUADRATIC_REL:
            case r3.PATHSEG_ARC_REL:
            case r3.PATHSEG_CURVETO_CUBIC_SMOOTH_REL:
            case r3.PATHSEG_CURVETO_QUADRATIC_SMOOTH_REL: {
              const t5 = n4;
              a3.x += t5.x, a3.y += t5.y;
              break;
            }
            case r3.PATHSEG_LINETO_HORIZONTAL_REL:
              a3.x += n4.x;
              break;
            case r3.PATHSEG_LINETO_VERTICAL_REL:
              a3.y += n4.y;
              break;
            case r3.PATHSEG_UNKNOWN:
            case r3.PATHSEG_CLOSEPATH:
              continue;
          }
          o3.push({x: a3.x * e3 + i3.x, y: a3.y * e3 + i3.y});
        }
      }
      return o3;
    }(this.paths, u2, this.offset);
  }
  downloadSvgPath(t2, e2) {
    return ao(this, void 0, void 0, function* () {
      const i2 = this.options, o2 = t2 || i2.url, s2 = e2 != null && e2;
      if (!o2 || this.paths !== void 0 && !s2)
        return this.raw;
      const n2 = yield fetch(o2);
      if (!n2.ok)
        throw new Error("tsParticles Error - Error occurred during polygon mask download");
      return this.parseSvgPath(yield n2.text(), e2);
    });
  }
  drawPoints() {
    if (this.raw)
      for (const t2 of this.raw)
        this.container.particles.addParticle({x: t2.x, y: t2.y});
  }
  randomPoint() {
    const t2 = this.container, e2 = this.options;
    let i2;
    if (e2.type === Ki.inline)
      switch (e2.inline.arrangement) {
        case Qi.randomPoint:
          i2 = this.getRandomPoint();
          break;
        case Qi.randomLength:
          i2 = this.getRandomPointByLength();
          break;
        case Qi.equidistant:
          i2 = this.getEquidistantPointByIndex(t2.particles.count);
          break;
        case Qi.onePerPoint:
        case Qi.perPoint:
        default:
          i2 = this.getPointByIndex(t2.particles.count);
      }
    else
      i2 = {x: Math.random() * t2.canvas.size.width, y: Math.random() * t2.canvas.size.height};
    return this.checkInsidePolygon(i2) ? i2 : this.randomPoint();
  }
  getRandomPoint() {
    if (!this.raw || !this.raw.length)
      throw new Error(Q.noPolygonDataLoaded);
    const t2 = J.itemFromArray(this.raw);
    return {x: t2.x, y: t2.y};
  }
  getRandomPointByLength() {
    var t2, e2, i2;
    const o2 = this.options;
    if (!this.raw || !this.raw.length || !((t2 = this.paths) === null || t2 === void 0 ? void 0 : t2.length))
      throw new Error(Q.noPolygonDataLoaded);
    const s2 = J.itemFromArray(this.paths), n2 = Math.floor(Math.random() * s2.length) + 1, a2 = s2.element.getPointAtLength(n2);
    return {x: a2.x * o2.scale + (((e2 = this.offset) === null || e2 === void 0 ? void 0 : e2.x) || 0), y: a2.y * o2.scale + (((i2 = this.offset) === null || i2 === void 0 ? void 0 : i2.y) || 0)};
  }
  getEquidistantPointByIndex(t2) {
    var e2, i2, o2, s2, n2, a2, r2;
    const l2 = this.container.actualOptions, c2 = this.options;
    if (!this.raw || !this.raw.length || !((e2 = this.paths) === null || e2 === void 0 ? void 0 : e2.length))
      throw new Error(Q.noPolygonDataLoaded);
    let d2, h2 = 0;
    const u2 = this.paths.reduce((t3, e3) => t3 + e3.length, 0) / l2.particles.number.value;
    for (const e3 of this.paths) {
      const i3 = u2 * t2 - h2;
      if (i3 <= e3.length) {
        d2 = e3.element.getPointAtLength(i3);
        break;
      }
      h2 += e3.length;
    }
    return {x: ((i2 = d2 == null ? void 0 : d2.x) !== null && i2 !== void 0 ? i2 : 0) * c2.scale + ((s2 = (o2 = this.offset) === null || o2 === void 0 ? void 0 : o2.x) !== null && s2 !== void 0 ? s2 : 0), y: ((n2 = d2 == null ? void 0 : d2.y) !== null && n2 !== void 0 ? n2 : 0) * c2.scale + ((r2 = (a2 = this.offset) === null || a2 === void 0 ? void 0 : a2.y) !== null && r2 !== void 0 ? r2 : 0)};
  }
  getPointByIndex(t2) {
    if (!this.raw || !this.raw.length)
      throw new Error(Q.noPolygonDataLoaded);
    const e2 = this.raw[t2 % this.raw.length];
    return {x: e2.x, y: e2.y};
  }
  createPath2D() {
    var t2, e2;
    const i2 = this.options;
    if (this.path2DSupported && ((t2 = this.paths) === null || t2 === void 0 ? void 0 : t2.length))
      for (const t3 of this.paths) {
        const o2 = (e2 = t3.element) === null || e2 === void 0 ? void 0 : e2.getAttribute("d");
        if (o2) {
          const e3 = new Path2D(o2), s2 = document.createElementNS("http://www.w3.org/2000/svg", "svg").createSVGMatrix(), n2 = new Path2D(), a2 = s2.scale(i2.scale);
          n2.addPath ? (n2.addPath(e3, a2), t3.path2d = n2) : delete t3.path2d;
        } else
          delete t3.path2d;
        !t3.path2d && this.raw && (t3.path2d = new Path2D(), t3.path2d.moveTo(this.raw[0].x, this.raw[0].y), this.raw.forEach((e3, i3) => {
          var o3;
          i3 > 0 && ((o3 = t3.path2d) === null || o3 === void 0 || o3.lineTo(e3.x, e3.y));
        }), t3.path2d.closePath());
      }
  }
  initRawData(t2) {
    return ao(this, void 0, void 0, function* () {
      const e2 = this.options;
      if (e2.url)
        this.raw = yield this.downloadSvgPath(e2.url, t2);
      else if (e2.data) {
        const i2 = e2.data;
        let o2;
        if (typeof i2 != "string") {
          const t3 = i2.path instanceof Array ? i2.path.map((t4) => `<path d="${t4}" />`).join("") : `<path d="${i2.path}" />`;
          o2 = `<svg ${'xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"'} width="${i2.size.width}" height="${i2.size.height}">${t3}</svg>`;
        } else
          o2 = i2;
        this.raw = this.parseSvgPath(o2, t2);
      }
      this.createPath2D();
    });
  }
}
const uo = new class {
  constructor() {
    this.id = "polygonMask";
  }
  getPlugin(t2) {
    return new ho(t2);
  }
  needsPlugin(t2) {
    var e2, i2, o2;
    return (i2 = (e2 = t2 == null ? void 0 : t2.polygon) === null || e2 === void 0 ? void 0 : e2.enable) !== null && i2 !== void 0 ? i2 : ((o2 = t2 == null ? void 0 : t2.polygon) === null || o2 === void 0 ? void 0 : o2.type) !== void 0 && t2.polygon.type !== Ki.none;
  }
  loadOptions(t2, e2) {
    if (!this.needsPlugin(e2))
      return;
    const i2 = t2;
    let o2 = i2.polygon;
    (o2 == null ? void 0 : o2.load) === void 0 && (i2.polygon = o2 = new no()), o2.load(e2 == null ? void 0 : e2.polygon);
  }
}();
const vo = new class extends class {
  constructor() {
    Ei.set(this, void 0), Ii(this, Ei, false);
    const t2 = new S(), e2 = new mt(), i2 = new bt();
    vt.addShapeDrawer(W.line, new wt()), vt.addShapeDrawer(W.circle, new xt()), vt.addShapeDrawer(W.edge, t2), vt.addShapeDrawer(W.square, t2), vt.addShapeDrawer(W.triangle, new Pt()), vt.addShapeDrawer(W.star, new Mt()), vt.addShapeDrawer(W.polygon, new Rt()), vt.addShapeDrawer(W.char, e2), vt.addShapeDrawer(W.character, e2), vt.addShapeDrawer(W.image, i2), vt.addShapeDrawer(W.images, i2);
  }
  init() {
    Fi(this, Ei) || Ii(this, Ei, true);
  }
  loadFromArray(t2, e2, i2) {
    return Oi(this, void 0, void 0, function* () {
      return Ti.load(t2, e2, i2);
    });
  }
  load(t2, e2) {
    return Oi(this, void 0, void 0, function* () {
      return Ti.load(t2, e2);
    });
  }
  set(t2, e2, i2) {
    return Oi(this, void 0, void 0, function* () {
      return Ti.set(t2, e2, i2);
    });
  }
  loadJSON(t2, e2, i2) {
    return Ti.loadJSON(t2, e2, i2);
  }
  setOnClickHandler(t2) {
    Ti.setOnClickHandler(t2);
  }
  dom() {
    return Ti.dom();
  }
  domItem(t2) {
    return Ti.domItem(t2);
  }
  addShape(t2, e2, i2, o2, s2) {
    let n2;
    n2 = typeof e2 == "function" ? {afterEffect: o2, destroy: s2, draw: e2, init: i2} : e2, vt.addShapeDrawer(t2, n2);
  }
  addPreset(t2, e2) {
    vt.addPreset(t2, e2);
  }
  addPlugin(t2) {
    vt.addPlugin(t2);
  }
  addPathGenerator(t2, e2) {
    vt.addPathGenerator(t2, e2);
  }
} {
  constructor() {
    super(), this.addPlugin(qi), this.addPlugin(Ji), this.addPlugin(uo);
  }
}();
function po(e2) {
  let i2;
  return {c() {
    var t2;
    t2 = "div", i2 = document.createElement(t2), r(i2, "id", e2[0]);
  }, m(t2, e3) {
    !function(t3, e4, i3) {
      t3.insertBefore(e4, i3 || null);
    }(t2, i2, e3);
  }, p(t2, [e3]) {
    1 & e3 && r(i2, "id", t2[0]);
  }, i: t, o: t, d(t2) {
    t2 && a(i2);
  }};
}
vo.init(), ((t2) => {
  t2.dom();
})(vo);
function yo(t2, e2, i2) {
  let {options: o2 = {}} = e2, {url: s2 = ""} = e2, {id: n2 = "tsparticles"} = e2;
  const a2 = h();
  let r2 = n2;
  var l2;
  return l2 = () => {
    if (vo.init(), a2("particlesInit", vo), r2) {
      const t3 = vo.dom().find((t4) => t4.id === r2);
      t3 && t3.destroy();
    }
    if (n2) {
      const t3 = (t4) => {
        a2("particlesLoaded", {particles: t4}), r2 = n2;
      };
      s2 ? vo.loadJSON(n2, s2).then(t3) : o2 ? vo.load(n2, o2).then(t3) : console.error("You must specify options or url to load tsParticles");
    } else
      a2("particlesLoaded", {particles: void 0});
  }, d().$$.after_update.push(l2), t2.$$set = (t3) => {
    "options" in t3 && i2(1, o2 = t3.options), "url" in t3 && i2(2, s2 = t3.url), "id" in t3 && i2(0, n2 = t3.id);
  }, [n2, o2, s2];
}
class svelteParticles extends class {
  $destroy() {
    !function(t2, e2) {
      const i2 = t2.$$;
      i2.fragment !== null && (o(i2.on_destroy), i2.fragment && i2.fragment.d(e2), i2.on_destroy = i2.fragment = null, i2.ctx = []);
    }(this, 1), this.$destroy = t;
  }
  $on(t2, e2) {
    const i2 = this.$$.callbacks[t2] || (this.$$.callbacks[t2] = []);
    return i2.push(e2), () => {
      const t3 = i2.indexOf(e2);
      t3 !== -1 && i2.splice(t3, 1);
    };
  }
  $set(t2) {
    var e2;
    this.$$set && (e2 = t2, Object.keys(e2).length !== 0) && (this.$$.skip_bound = true, this.$$set(t2), this.$$.skip_bound = false);
  }
} {
  constructor(t2) {
    super(), R(this, t2, yo, po, n, {options: 1, url: 2, id: 0});
  }
  get options() {
    return this.$$.ctx[1];
  }
  set options(t2) {
    this.$set({options: t2}), x();
  }
  get url() {
    return this.$$.ctx[2];
  }
  set url(t2) {
    this.$set({url: t2}), x();
  }
  get id() {
    return this.$$.ctx[0];
  }
  set id(t2) {
    this.$set({id: t2}), x();
  }
}
var svelteParticles$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": svelteParticles
});
export {init$j as init, render};
